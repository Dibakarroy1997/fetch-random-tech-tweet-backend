[
    {
        "data": {
            "text": "Over the years, my \"here there be dragons\" list has gotten long.\n\nMixing threading and forking --&gt; page fault\nFloating point equality --&gt; page fault\nHigh serialization loads --&gt; page fault\nXML macros --&gt; page fault\n...\n\n4/4",
            "id": "1604180659085377536",
            "edit_history_tweet_ids": [
                "1604180659085377536"
            ],
            "conversation_id": "1604180654530650114"
        }
    },
    {
        "data": {
            "text": "For example with regexes, I don't have a mental catalog\nof all the ways to trigger quadratic behavior.\n\nBut I have mentally marked some patterns as\n\"here there be dragons\".\n\nWhen programming, I \"page fault\" and can either avoid the issue or pick up my sword and work through it.",
            "conversation_id": "1604180654530650114",
            "edit_history_tweet_ids": [
                "1604180657378205697"
            ],
            "id": "1604180657378205697"
        }
    },
    {
        "data": {
            "conversation_id": "1604180654530650114",
            "id": "1604180655990087681",
            "text": "In copy-on-write, we mark page table\nentries as read-only.  Subsequent accesses\ntrigger page-faults, allowing the copy on\ndemand.\n\nThe human equivalent is study-on-demand,\nmarking some areas of knowledge as needing\nto be filled in when needed.\n\n2/4",
            "edit_history_tweet_ids": [
                "1604180655990087681"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1604180654530650114",
            "id": "1604180654530650114",
            "text": "How do we #Python programmers manage the complexity of there just being too many things you need to know?\n\nI think a good model is study-on-demand, a hybrid of lazy evaluation and copy-on-write adapted for the human brain.\n\n1/4",
            "edit_history_tweet_ids": [
                "1604180654530650114"
            ]
        }
    },
    {
        "data": {
            "id": "1604125695394865158",
            "text": "#Python practices question:   Have you ever been able to put the builtin memoryview() to good use?\n\nISTM the underlying object typically already offers at least as many capabilities.",
            "edit_history_tweet_ids": [
                "1604125695394865158"
            ],
            "conversation_id": "1604125695394865158"
        }
    },
    {
        "data": {
            "conversation_id": "1602839429634310144",
            "text": "I was pretty impressed by the @RoyKishony's Quibbler demo.  It has the highest payoff for least amount of effort that I've seen in a long time.\n\nImagine converting static data analysis to interactive analysis with only one line of code.\n\nI recommend taking five minutes to try it. https://t.co/ikrX5VypFi",
            "id": "1602839429634310144",
            "edit_history_tweet_ids": [
                "1602839429634310144"
            ]
        }
    },
    {
        "data": {
            "id": "1601056596729073665",
            "conversation_id": "1601056595202277376",
            "edit_history_tweet_ids": [
                "1601056596729073665"
            ],
            "text": "Interestingly, I never get questions about mmap() in class, nor when I do code reviews for teams.\nIt seems absent from Twitter and blog posts. On the core development issue tracker, we don't get mmap() feature requests. And it doesn't come up in Python-ideas or tutor lists."
        }
    },
    {
        "data": {
            "conversation_id": "1601056595202277376",
            "edit_history_tweet_ids": [
                "1601056595202277376"
            ],
            "text": "Have any of you ever put #Python's mmap() module to good use?\n\nIt seems awesome and toy examples are easy to code, but I've never had occasion to apply it to real world problems.  I'm wonder whether I've missed an obvious but common use case.",
            "id": "1601056595202277376"
        }
    },
    {
        "data": {
            "conversation_id": "1600016393763577857",
            "text": "So come on and give it a try\nYou'll love what you can do with Python, oh Python!\n\n--- #GPTChat prompt: Write an advertising jingle for the #Python programming language.\n\n(2/2)",
            "edit_history_tweet_ids": [
                "1600016395626061824"
            ],
            "id": "1600016395626061824"
        }
    },
    {
        "data": {
            "conversation_id": "1600016393763577857",
            "text": "A #Python jingle:\n\nPython, oh Python\nThe language that's so fun\nFrom web development to data analysis\nPython gets the job done\n\nWith a simple and elegant syntax\nIt's easy to learn and use\nWhether you're a beginner or a pro\nPython is the way to go\n\n(1/2)",
            "id": "1600016393763577857",
            "edit_history_tweet_ids": [
                "1600016393763577857"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1596586512396980225",
            "text": "Your coding style controls the failure mode.\n\nDo you prefer \"fail fast, fail hard\" or do you prefer \"defensive coding\" that can obscure logic errors?",
            "id": "1596586516536594434",
            "edit_history_tweet_ids": [
                "1596586516536594434"
            ]
        }
    },
    {
        "data": {
            "text": "Suppose your reasoning is wrong and \"i\" can jump above \"n\" without hitting \"i==n\" first.\n\nWould you prefer an infinite loop or termination?\n\nIf the infinite loop surfaces during testing, you can find and fix the bug.\n\nBut if it happens in production, it might be embarrassing.",
            "conversation_id": "1596586512396980225",
            "id": "1596586514951024640",
            "edit_history_tweet_ids": [
                "1596586514951024640"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1596586512396980225",
            "text": "Consider incrementing i up to n.\n\nAn \"at the boundary\" test such as \"i != n\" expresses confidence that \"i &gt; n\" cannot occur without hitting \"i == n\" first.\n\nAn \"at or beyond the boundary\" test such as \"i &gt;= n\" tries to encompass cases that presumably cannot happen.",
            "edit_history_tweet_ids": [
                "1596586513759961088"
            ],
            "id": "1596586513759961088"
        }
    },
    {
        "data": {
            "id": "1596586512396980225",
            "edit_history_tweet_ids": [
                "1596586512396980225"
            ],
            "conversation_id": "1596586512396980225",
            "text": "#Python practices survey:  What is your style for checking boundary conditions?"
        }
    },
    {
        "data": {
            "id": "1594415208163905536",
            "text": "Integer arithmetic version:\n\npool = range(500)\nss = list(accumulate(map(lambda x: x*x, pool), initial=0))\nfor lo, mi, hi in combinations(pool, 3):\n    r1 = range(lo, mi)\n    r2 = range(mi, hi)\n    if ss[mi] - ss[lo] == ss[hi] - ss[mi]:\n        print(r1, r2)",
            "edit_history_tweet_ids": [
                "1594415208163905536"
            ],
            "conversation_id": "1594409295072104448"
        }
    },
    {
        "data": {
            "conversation_id": "1594409295072104448",
            "edit_history_tweet_ids": [
                "1594409297571627008"
            ],
            "text": "(3/3) #Python makes short work of this search.\n\nfrom itertools import combinations\nfrom math import hypot\n\nfor lo, mi, hi in combinations(range(500), 3):\n    r1 = range(lo, mi)\n    r2 = range(mi, hi)\n    if hypot(*r1) == hypot(*r2):\n        print(r1, r2)",
            "id": "1594409297571627008"
        }
    },
    {
        "data": {
            "conversation_id": "1594409295072104448",
            "text": "(2/3) There are many more of these and some are incredible:\n\nhypot(78, 79, 80, 81, 82, 83, 84) == hypot(85, 86, 87, 88, 89, 90)\n\nhypot(*range(12, 51)) == hypot(*range(51, 64))\n\nhypot(*range(16, 143)) == hypot(*range(143, 180))",
            "id": "1594409296346890241",
            "edit_history_tweet_ids": [
                "1594409296346890241"
            ]
        }
    },
    {
        "data": {
            "text": "(1/3) #Python amusement for numberphiles:\n\nfrom math import hypot\n\nhypot(3, 4) == hypot(5)\nhypot(10, 11, 12) == hypot(13, 14)\nhypot(21, 22, 23, 24) == hypot(25, 26, 27)\nhypot(36, 37, 38, 39, 40) == hypot(41, 42, 43, 44)\nhypot(55, 56, 57, 58, 59, 60) == hypot(61, 62, 63, 64, 65)",
            "conversation_id": "1594409295072104448",
            "edit_history_tweet_ids": [
                "1594409295072104448"
            ],
            "id": "1594409295072104448"
        }
    },
    {
        "data": {
            "text": "P.S. I had to repost this thread because Dropbox unrecoverably killed the source code link after a minor edit.",
            "conversation_id": "1592571075153776640",
            "edit_history_tweet_ids": [
                "1592571088831410177"
            ],
            "id": "1592571088831410177"
        }
    },
    {
        "data": {
            "text": "(10/10) I've come up with these tools by helping people with maintenance issues.\n\nIf you want to create other useful pattern matchers, a good way to start is by trying to convert existing if/elif/else code to match-case.\n\nEvery obstacle you encounter is a potential new tool.",
            "conversation_id": "1592571075153776640",
            "edit_history_tweet_ids": [
                "1592571087405342720"
            ],
            "id": "1592571087405342720"
        }
    },
    {
        "data": {
            "conversation_id": "1592571075153776640",
            "edit_history_tweet_ids": [
                "1592571086205440001"
            ],
            "text": "(9/10) Please try out the toolkit and provide feedback on what works for you.\n\nUltimately the goal is fulfill the PEP 622 deferred promise of \"a new Python standard library module which would contain a rich set of useful matchers.\"\n\nhttps://t.co/2Ij4QIANGD",
            "id": "1592571086205440001"
        }
    },
    {
        "data": {
            "text": "(8/10) You could skip all of these techniques by using wildcard cases with guard expressions, but then you've thrown away any of the benefits of match/case and should switch back to an if/elif/else chain.",
            "edit_history_tweet_ids": [
                "1592571084884287488"
            ],
            "conversation_id": "1592571075153776640",
            "id": "1592571084884287488"
        }
    },
    {
        "data": {
            "conversation_id": "1592571075153776640",
            "text": "(7/10) Cases have been written with floating point numbers, but you're getting mismatches due to round-off error.\n\nWhat you want is approximate matching.\n\nThe Approximately() class makes this fix trivially easy.",
            "id": "1592571083538198528",
            "edit_history_tweet_ids": [
                "1592571083538198528"
            ]
        }
    },
    {
        "data": {
            "id": "1592571082061803520",
            "text": "(6/10) Cases have been written using the or-pattern.\n\nPerhaps the number of alternatives is growing too large.\n\nOr perhaps the alternatives can change.\n\nWhat you really want is a set membership test.\n\nThe InSet() class solves this problem without much fuss.",
            "edit_history_tweet_ids": [
                "1592571082061803520"
            ],
            "conversation_id": "1592571075153776640"
        }
    },
    {
        "data": {
            "conversation_id": "1592571075153776640",
            "edit_history_tweet_ids": [
                "1592571080728018944"
            ],
            "id": "1592571080728018944",
            "text": "(5/10) Cases have been written with string constants, but a new requirement is to match regular expression patterns instead.\n\nInterestingly, this use case is often what people first think of when they hear about pattern matching.\n\nThe RegexEqual() class provides a solution."
        }
    },
    {
        "data": {
            "conversation_id": "1592571075153776640",
            "text": "(4/10) Cases have been written with string constants, but now a new requirement is to internationalize the strings with gettext. The target language can change at any time.\n\nProblem: You have to wrap the constants with function calls.\n\nThe FuncCall() class provides a solution.",
            "id": "1592571079373250562",
            "edit_history_tweet_ids": [
                "1592571079373250562"
            ]
        }
    },
    {
        "data": {
            "id": "1592571078022664192",
            "edit_history_tweet_ids": [
                "1592571078022664192"
            ],
            "conversation_id": "1592571075153776640",
            "text": "(3/10) A case has been written to match a constant, but now a new requirement arises and the constant will be user specified.\n\nProblem: You have to replace the constant with a variable.  \n\nIn this situation, the Var() class provides an easy solution."
        }
    },
    {
        "data": {
            "conversation_id": "1592571075153776640",
            "id": "1592571075153776640",
            "text": "(1/10) Here's a small toolkit to extend #Python Structural Pattern Matching beyond its core capabilities.\n\nhttps://t.co/hAHhPTBYTQ",
            "edit_history_tweet_ids": [
                "1592571075153776640"
            ]
        }
    },
    {
        "data": {
            "id": "1592566710082895873",
            "text": "New link:  https://t.co/hAHhPTBYTQ",
            "edit_history_tweet_ids": [
                "1592566710082895873"
            ],
            "conversation_id": "1592561986919108608"
        }
    },
    {
        "data": {
            "text": "(10/10) I've come up with these tools by helping people with maintenance issues.\n\nIf you want to create other useful pattern matchers, a good way to start is by trying to convert existing if/elif/else code to match-case.\n\nEvery obstacle you encounter is a potential new tool.",
            "conversation_id": "1592561986919108608",
            "edit_history_tweet_ids": [
                "1592562000479281153"
            ],
            "id": "1592562000479281153"
        }
    },
    {
        "data": {
            "conversation_id": "1592561986919108608",
            "text": "(9/10) Please try out the toolkit and provide feedback on what works for you.\n\nUltimately the goal is fulfill the PEP 622 deferred promise of \"a new Python standard library module which would contain a rich set of useful matchers.\"\n\nhttps://t.co/2Ij4QISWUL",
            "id": "1592561998835109889",
            "edit_history_tweet_ids": [
                "1592561998835109889"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1592561986919108608",
            "id": "1592561996977037312",
            "text": "(8/10) You could skip all of these techniques by using wildcard cases with guard expressions, but then you've thrown away any of the benefits of match/case and should switch back to an if/elif/else chain.",
            "edit_history_tweet_ids": [
                "1592561996977037312"
            ]
        }
    },
    {
        "data": {
            "text": "(7/10) Cases have been written with floating point numbers, but you're getting mismatches due to round-off error.\n\nWhat you want is approximate matching.\n\nThe Approximately() class makes this fix trivially easy.",
            "conversation_id": "1592561986919108608",
            "id": "1592561995492249601",
            "edit_history_tweet_ids": [
                "1592561995492249601"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1592561986919108608",
            "id": "1592561994053619712",
            "text": "(6/10) Cases have been written using the or-pattern.\n\nPerhaps the number of alternatives is growing too large.\n\nOr perhaps the alternatives can change.\n\nWhat you really want is a set membership test.\n\nThe InSet() class solves this problem without much fuss.",
            "edit_history_tweet_ids": [
                "1592561994053619712"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1592561986919108608",
            "edit_history_tweet_ids": [
                "1592561992774332421"
            ],
            "id": "1592561992774332421",
            "text": "(5/10) Cases have been written with string constants, but a new requirement is to match regular expression patterns instead.\n\nInterestingly, this use case is often what people first think of when they hear about pattern matching.\n\nThe RegexEqual() class provides a solution."
        }
    },
    {
        "data": {
            "conversation_id": "1592561986919108608",
            "text": "(4/10) Cases have been written with string constants, but now a new requirement is to internationalize the strings with gettext. The target language can change at any time.\n\nProblem: You have to wrap the constants with function calls.\n\nThe FuncCall() class provides a solution.",
            "id": "1592561991537004544",
            "edit_history_tweet_ids": [
                "1592561991537004544"
            ]
        }
    },
    {
        "data": {
            "id": "1592561990199021569",
            "edit_history_tweet_ids": [
                "1592561990199021569"
            ],
            "conversation_id": "1592561986919108608",
            "text": "(3/10) A case has been written to match a constant, but now a new requirement arises and the constant will be user specified.\n\nProblem: You have to replace the constant with a variable.  \n\nIn this situation, the Var() class provides an easy solution."
        }
    },
    {
        "data": {
            "text": "(2/10) Except for the named constants, I wouldn't recommend starting with any of these because you would likely be better off with an old-fashioned if/elif/else chain.\n\nMostly, these tools are helpful with solving issues that arise during maintenance of existing match/case code.",
            "edit_history_tweet_ids": [
                "1592561988479045632"
            ],
            "conversation_id": "1592561986919108608",
            "id": "1592561988479045632"
        }
    },
    {
        "data": {
            "text": "(1/10) Here's a small toolkit to extend #Python Structural Pattern Matching beyond its core capabilities.\n\nhttps://t.co/Ak5nd3CAPe",
            "conversation_id": "1592561986919108608",
            "edit_history_tweet_ids": [
                "1592561986919108608"
            ],
            "id": "1592561986919108608"
        }
    },
    {
        "data": {
            "text": "It would have been nice to use the callable() built-in function instead of having to import Callable from typing.\n\nAlas, callable() is a predicate, not a type.",
            "conversation_id": "1590110845308407809",
            "edit_history_tweet_ids": [
                "1590110847233593344"
            ],
            "id": "1590110847233593344"
        }
    },
    {
        "data": {
            "id": "1590110845308407809",
            "text": "The secret to adding #Python type annotations to lambda expressions is to write a variable annotation:\n\nf: Callable[[int, int], int] = lambda x, y: 3*x + y\n\nI don't think there is way to annotate in-line lambdas that aren't assigned to variables.",
            "edit_history_tweet_ids": [
                "1590110845308407809"
            ],
            "conversation_id": "1590110845308407809"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1589016946628235265",
                "1589017195274997760"
            ],
            "id": "1589017195274997760",
            "text": "It's ultimate irony day. Earlier today, we taught our son that if a book started with, \"It was a dark and stormy night\", then it probably wasn't a good book.\n\nLater, we went to the library and checked out, \"A Wrinkle in Time\", one of my childhood favorites.\n\nOops!  \ud83e\uddd0 https://t.co/RNe9eiTYys",
            "conversation_id": "1589017195274997760"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1588943332184854530"
            ],
            "id": "1588943332184854530",
            "text": "How not to factor your code ;-)\n\nstart, stop, step --&gt; art, op, ep",
            "conversation_id": "1588943332184854530"
        }
    },
    {
        "data": {
            "text": "Let's settle this:",
            "id": "1586170413700505601",
            "edit_history_tweet_ids": [
                "1586170413700505601"
            ],
            "conversation_id": "1586170413700505601"
        }
    },
    {
        "data": {
            "conversation_id": "1584593523986550784",
            "edit_history_tweet_ids": [
                "1584593523986550784"
            ],
            "text": "Today is my first day to teach #Python with version 3.11.\n\nThe improved error messages are a real joy.\n\nWhen the final release happens, likely later today, do yourself a favor and upgrade immediately.\n\nIt is mostly better, faster, and stronger but doesn't cost $6 million dollars.",
            "id": "1584593523986550784"
        }
    },
    {
        "data": {
            "text": "Presumably, this is right out:\n\naint_coprime(p, q)",
            "edit_history_tweet_ids": [
                "1581675718718550016"
            ],
            "conversation_id": "1581670191745757185",
            "id": "1581675718718550016"
        }
    },
    {
        "data": {
            "conversation_id": "1581670191745757185",
            "text": "Just asking for a friend ;-). How true to English should you make your #Python function names?\n\nis_coprime(p, q)\n\nor\n\nare_coprime(p, q)",
            "id": "1581670191745757185",
            "edit_history_tweet_ids": [
                "1581670191745757185"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1578866923642949632",
            "text": "The idea is to support write-once, read-many concatenation logic.\n\nThink about newsfeeds, worm drives, event logs, concatenating to file, accounting journals, ...\n\nFor linked lists in particular, the current abstract methods are irritating if all you want is append logic.",
            "edit_history_tweet_ids": [
                "1578866925240999936"
            ],
            "id": "1578866925240999936"
        }
    },
    {
        "data": {
            "text": "Would any of you #Python folks have a need for a new https://t.co/oLLyulh4Oc class called ExtendableSequence that only grows to the right?\n\nThe current MutableSequence has abtractmethods for __setitem__(), __delitem__(), and insert().\n\nExtendableSequence would only need append().",
            "edit_history_tweet_ids": [
                "1578866923642949632"
            ],
            "conversation_id": "1578866923642949632",
            "id": "1578866923642949632"
        }
    },
    {
        "data": {
            "conversation_id": "1575950841995210752",
            "text": "Hint:  Think in terms of use cases.  Why is the current behavior useful and why would the alternative be a PITA?",
            "edit_history_tweet_ids": [
                "1575956437632942082"
            ],
            "id": "1575956437632942082"
        }
    },
    {
        "data": {
            "id": "1575955622860066818",
            "text": "&gt;&gt;&gt; s = 'abc'\n\n&gt;&gt;&gt; s[5]\nTraceback\n  ...\nIndexError: string index out of range\n\n&gt;&gt;&gt; s[:5]\n'abc'\n\nAlso interesting:\n\n&gt;&gt;&gt; s[5:6]\n''\n&gt;&gt;&gt; s[5:]\n''",
            "edit_history_tweet_ids": [
                "1575955622860066818"
            ],
            "conversation_id": "1575950841995210752"
        }
    },
    {
        "data": {
            "conversation_id": "1575950841995210752",
            "edit_history_tweet_ids": [
                "1575950841995210752"
            ],
            "text": "One way to develop your #Python intuition is to explain some its design decisions in your own words.\n\nGiven a sequence s of length three, explain why s[5] raises an IndexError, but s[:5] doesn't.",
            "id": "1575950841995210752"
        }
    },
    {
        "data": {
            "text": "Another rule of thumb from Matthew: The number seconds in a year is about \u03c0 x 10\u2077",
            "conversation_id": "1573527758717784072",
            "edit_history_tweet_ids": [
                "1573527758717784072"
            ],
            "id": "1573527758717784072"
        }
    },
    {
        "data": {
            "id": "1569730933003001860",
            "conversation_id": "1569725172537610241",
            "edit_history_tweet_ids": [
                "1569730933003001860"
            ],
            "text": "A variant using set() is prettier but much slower and uses more memory.\n\ndef sieve(n) -&gt; set[int]:\n    'Primes less than n.'\n    s = set(range(2, n))\n    for c in range(2, isqrt(n)+1):\n        if c in s:\n            s.difference_update(range(c+c, n, c))\n    return s.copy()\n\n4/"
        }
    },
    {
        "data": {
            "id": "1569725175834509312",
            "conversation_id": "1569725172537610241",
            "edit_history_tweet_ids": [
                "1569725175834509312"
            ],
            "text": "If we had a builtin bitarray(), memory consumption could be reduced by a factor of eight.\n\nIf we had a new itertool called iter_index(), speed and clarity could be improved as well.\n\nThen \"compress(count(), data)\" could then be replaced with \"iter_index(data, 1)\".\n\n3/"
        }
    },
    {
        "data": {
            "text": "The imports are:\n\nfrom itertools import count, compress, islice\nfrom math import isqrt\n\nThe recipe is reasonably fast and memory efficient. To list all primes under 10**9, it takes 17 seconds and 1 extra Gb of RAM:\n\n&gt;&gt;&gt; len(sieve(10**9))\n50847534\n\n2/",
            "conversation_id": "1569725172537610241",
            "edit_history_tweet_ids": [
                "1569725174022545409"
            ],
            "id": "1569725174022545409"
        }
    },
    {
        "data": {
            "conversation_id": "1569725172537610241",
            "text": "Fun #Python recipe.\n\ndef sieve(n):\n   'Primes less than n'\n   data = bytearray([1]) * n\n   data[:2] = 0, 0\n   limit = isqrt(n) + 1\n   for c in compress(count(), islice(data, limit)):\n      data[c+c::c] = bytearray(len(range(c+c, n, c)))\n   return list(compress(count(), data))\n\n1/",
            "edit_history_tweet_ids": [
                "1569725172537610241"
            ],
            "id": "1569725172537610241"
        }
    },
    {
        "data": {
            "text": "#Python and #Sympy show that in the limit, the relationship is exact:\n\n&gt;&gt;&gt; a, b = symbols('a b')\n&gt;&gt;&gt; difference = 1/a - 1/b - 1/(a+b)\n&gt;&gt;&gt; phi = (1 + sqrt(5)) / 2\n&gt;&gt;&gt; difference.subs([(b, a*phi)]).simplify()\n0\n\nWhere phi is the Golden Ratio, the limit of F\u2099\u208a\u2081 / F\u2099.",
            "edit_history_tweet_ids": [
                "1567323557901787143"
            ],
            "conversation_id": "1567321337131155463",
            "id": "1567323557901787143"
        }
    },
    {
        "data": {
            "conversation_id": "1567321337131155463",
            "text": "Matthew's noticed an interesting relationship between Fibonacci reciprocals:\n\n1/5  + 1/8  \u2248 1/3\n1/8  + 1/13 \u2248 1/5\n1/13 + 1/21 \u2248 1/8\n1/21 + 1/34 \u2248 1/13\n  ...\n1/F\u2099 +  1/F\u2099\u208a\u2081 \u2248 1/F\u2099\u208b\u2081\n\nAs n gets larger, this approximation converges.  Pretty cool.",
            "id": "1567321337131155463",
            "edit_history_tweet_ids": [
                "1567321337131155463"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1566569890600943616",
            "text": "Kudos to the #MyPy team for a very high quality error message.\n\nIt first gives the difference between the inferred type and the expected type, then it refers you to the relevant section of the docs, and lastly, it makes an appropriate suggestion.\n\n4/",
            "id": "1566573034084995073",
            "edit_history_tweet_ids": [
                "1566573034084995073"
            ]
        }
    },
    {
        "data": {
            "id": "1566569892907737090",
            "text": "Here is the relevant reference to the #MyPy docs:\n\nhttps://t.co/wr4gonqNmD\n\n3/",
            "edit_history_tweet_ids": [
                "1566569892907737090"
            ],
            "conversation_id": "1566569890600943616"
        }
    },
    {
        "data": {
            "text": "Interestingly, both forms work when called with:\n\nsum_valid([10, 20])\n\nThe issue is that #MyPy infers that \"data = [10, 20]\" is of type list[int], but it cannot figure-out that sum_valid() only reads the data. It must assumes that sum_valid() could have:\n\ndata.append(None)\n\n2/",
            "id": "1566569891813097473",
            "edit_history_tweet_ids": [
                "1566569891813097473"
            ],
            "conversation_id": "1566569890600943616"
        }
    },
    {
        "data": {
            "text": "#Python typing tip:  Use immutable collections as annotations whenever possible.\n\nPrefer:\n\ndef sum_valid(data: Sequence[int | None]):\n   ...\n\nOver:\n\ndef sum_valid(data: list[int | None]):\n   ...\n\nThe latter will fail with:\n\ndata = [10, 20]\nsum_valid(data)\n\n1/",
            "conversation_id": "1566569890600943616",
            "edit_history_tweet_ids": [
                "1566569890600943616"
            ],
            "id": "1566569890600943616"
        }
    },
    {
        "data": {
            "id": "1565409199630286848",
            "edit_history_tweet_ids": [
                "1565409199630286848"
            ],
            "conversation_id": "1565403495792082951",
            "text": "SDD -&gt; SSD"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1565403498107359235"
            ],
            "id": "1565403498107359235",
            "text": "My favorite was in a Python course. We saved a file and a former physics professor asked \"where did it go?\"\n\nI said, \"it is in your laptop\".\n\nHe said, \"yes, but where\" as he looked all around it.\n\nIt took a physics level description of how data is stored in a SDD to satisfy him.",
            "conversation_id": "1565403495792082951"
        }
    },
    {
        "data": {
            "text": "Well the last one is easy.  You see, on a manifold in a connected metric space, a straight line is the locus of points such that local the curvature is everywhere zero except for ...\n\nWait, what I meant to say is that it is a line that doesn't wiggle.",
            "edit_history_tweet_ids": [
                "1565403496907685890"
            ],
            "conversation_id": "1565403495792082951",
            "id": "1565403496907685890"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1565403495792082951"
            ],
            "id": "1565403495792082951",
            "text": "The more basic the question, the harder it is to answer.\n\nMartial arts stack exchange:  How do weapons work?\n\nMy son: Why are there wars?\n\nTormenting a PhD in math:  What is a straight line?",
            "conversation_id": "1565403495792082951"
        }
    },
    {
        "data": {
            "text": "My child uses my YouTube account, so videos recommended to him are affected by what I watch.\n\nSo now we're in an odd situation where he's still learning 5th grade math but asking me questions about the p-adic number video he just watched. \ud83e\uddd0",
            "conversation_id": "1564008981210845185",
            "edit_history_tweet_ids": [
                "1564008981210845185"
            ],
            "id": "1564008981210845185"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1563635855624998920"
            ],
            "id": "1563635855624998920",
            "text": "&gt;&gt;&gt; data = 'AAABCCC'\n\n&gt;&gt;&gt; mode(data)\n'A'\n\n&gt;&gt;&gt; multimode(data)\n['A', 'C']\n\n&gt;&gt;&gt; mode([])\nTraceback\n...\nstatistics.StatisticsError: no mode for empty data\n\n&gt;&gt;&gt; multimode([])\n[]\n\n2/",
            "conversation_id": "1563635854320492545"
        }
    },
    {
        "data": {
            "id": "1563635854320492545",
            "text": "#Python tip:  In the statistics module, mode() returns the first mode encountered and multimode() returns all of the modes in the order they were first encountered.\n\nAlso mode() requires at least one datum while multimode() can handle an empty input.\n\n1/",
            "edit_history_tweet_ids": [
                "1563635854320492545"
            ],
            "conversation_id": "1563635854320492545"
        }
    },
    {
        "data": {
            "text": "What extra work does randrange() do?\n\n* Call start.__index__() to get an int\n* Verify that *step* and *stop* aren't specified\n* Verify that n &gt; 0\n* Count the bits in n.\n* Apply rejection sampling to achieve a uniform distribution using getrandbits() as the source.",
            "conversation_id": "1556898398502064128",
            "edit_history_tweet_ids": [
                "1557099999091212289"
            ],
            "id": "1557099999091212289"
        }
    },
    {
        "data": {
            "conversation_id": "1556898398502064128",
            "text": "The same holds for larger ranges:\n\n370 nsec: randrange(2**200)\n51.9 nsec: getrandbits(200)\n\nStill 7x faster!",
            "id": "1556898399810625536",
            "edit_history_tweet_ids": [
                "1556898399810625536"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1556898398502064128"
            ],
            "id": "1556898398502064128",
            "text": "#Python performance tip:   randrange() handles arbitrary ranges, but if all you need is a power of two, then getrandbits() blows it out of the water.\n\nPython 3.11 timings:\n\n166 nsec:  randrange(1024)\n22.6 nsec:  getrandbits(10)\n\n7x faster",
            "conversation_id": "1556898398502064128"
        }
    },
    {
        "data": {
            "id": "1555997671214796802",
            "edit_history_tweet_ids": [
                "1555997671214796802"
            ],
            "conversation_id": "1555997645621059586",
            "text": "from math import floor\n\nlevel = 0\ntotal = 0.0\nlast_uf = 1.0\nfor n in range(1, 100_000_001):\n    uf = 1 / n\n    total += uf\n    if floor(total) != level:\n        level = floor(total)\n        print(last_uf / uf)\n        last_uf = uf\n\n6/"
        }
    },
    {
        "data": {
            "id": "1555997665996972033",
            "text": "I wrote this in #Python and ran it out 100,000,000 steps.\n\nThe last integer boundary crossed at 18.00000000371793 and the last unit fraction ratio was 2.718281861553586.\n\nVerdict:  Not a coincidence!\n\n5/",
            "edit_history_tweet_ids": [
                "1555997665996972033"
            ],
            "conversation_id": "1555997645621059586"
        }
    },
    {
        "data": {
            "text": "Record the unit fractions that caused the accumulation to cross the integer boundary:\n[1.0, 0.25, 0.09090909090909091, 0.03225806451612903, ...]\n\nGet the ratios of consecutive pairs:\n[4.0, 2.75, 2.8181818181818183, 2.6774193548387095, 2.7349397590361444, ...]\n\n4/",
            "conversation_id": "1555997645621059586",
            "edit_history_tweet_ids": [
                "1555997659961376771"
            ],
            "id": "1555997659961376771"
        }
    },
    {
        "data": {
            "conversation_id": "1555997645621059586",
            "text": "Start with unit fractions:\n[1.0, 0.5, 0.3333333333333333, 0.25, 0.2, ...]\n\nAccumulate them:\n[1.0, 1.5, 1.8333333333333333, 2.083333333333333, ...]\n\nKeep only the ones that cross an integer boundary:\n[1.0, 2.083333333333333, 3.0198773448773446, 4.02724519543652, ...]\n\n3/",
            "id": "1555997654596943873",
            "edit_history_tweet_ids": [
                "1555997654596943873"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1555997645621059586",
            "edit_history_tweet_ids": [
                "1555997650159386626"
            ],
            "id": "1555997650159386626",
            "text": "Today while playing with MS Excel he said, \"I found e!\"\n\nHe presented me with a Byzantine procedure where 2.7 emerged after 250 steps. He hypothesized that this unlikely procedure would converge to e.\n\nI fired up #Python to test it.\n\nLo and behold, e emerged. \ud83e\uddd0\n\n2/"
        }
    },
    {
        "data": {
            "text": "Nurturing a #Python seedling:  How on earth can I feed my ten-year-old's amazing mind?\n\nI'm afraid that if I teach him conventional programming and mathematics that he will lose his natural, instinctive ability to successfully navigate uncharted waters.\n\n1/",
            "edit_history_tweet_ids": [
                "1555997645621059586"
            ],
            "conversation_id": "1555997645621059586",
            "id": "1555997645621059586"
        }
    },
    {
        "data": {
            "text": "I once used this harmonic number factlet in a #Python heapq module comment to analyze the running time for heapq.nsmallest() and heapq.nlargest() for random inputs.\n\nhttps://t.co/8g51b4uCmb",
            "conversation_id": "1553266037382004736",
            "edit_history_tweet_ids": [
                "1553266040708026368"
            ],
            "id": "1553266040708026368"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1553266039562981377"
            ],
            "id": "1553266039562981377",
            "text": "It's also pretty cool that in approximating the differences of harmonic numbers, the magic constant cancels out and only natural logs remain:\n\n# \u03a3 1/x from x=10,001 to x=20,000\n&gt;&gt;&gt; math.log(20_000) - math.log(10_000)\n0.6931471805599436\n&gt;&gt;&gt; H(20_000) - H(10_000)\n0.693122181184945",
            "conversation_id": "1553266037382004736"
        }
    },
    {
        "data": {
            "conversation_id": "1553266037382004736",
            "id": "1553266038501912576",
            "text": "def H(n):\n    'Sum of unit fractions up from 1/1 to 1/n.'\n    return math.fsum(1/x for x in range(1, n+1))\n\ndef EstimatedH(n):\n    'Nth harmonic number (approx).'\n    return math.log(n) + 0.57721_56649\n\n&gt;&gt;&gt; H(100_000)\n12.090146129863427\n\n&gt;&gt;&gt; EstimatedH(100_000)\n12.09014112987023",
            "edit_history_tweet_ids": [
                "1553266038501912576"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1553266037382004736",
            "text": "Today was another happy math question day:  Dad, what do all the unit fractions add up to?\n\nSo, we made a spreadsheet, wrote some #Python, talked about convergence and divergence, graphed H(n) vs ln(n), and derived the Euler\u2013Mascheroni constant.  \ud83e\uddd0",
            "edit_history_tweet_ids": [
                "1553266037382004736"
            ],
            "id": "1553266037382004736"
        }
    },
    {
        "data": {
            "conversation_id": "1552769759594262528",
            "text": "Matthew's math rule of thumb:   \u03c0 \u2248 3.15 \u2248 \u221a10\n\nHe checked by computing ratio ratio \u03c0/\u221a10 and getting 0.993",
            "id": "1552769759594262528",
            "edit_history_tweet_ids": [
                "1552769759594262528"
            ]
        }
    },
    {
        "data": {
            "id": "1551660234984329218",
            "edit_history_tweet_ids": [
                "1551660234984329218"
            ],
            "conversation_id": "1551660234984329218",
            "text": "The prefix \u201chypo\u201d means below or under, while the word \u201cchondriac\u201d means cartilage, referring to the cartilage of the ribs. Therefore, the hypochondriac region is located beneath the ribcage. https://t.co/zblq0xrxkU"
        }
    },
    {
        "data": {
            "id": "1551609261473529857",
            "edit_history_tweet_ids": [
                "1551609261473529857"
            ],
            "conversation_id": "1551609257472172034",
            "text": "Source for this wonderful fact let:\n\nhttps://t.co/QBgkhjYKUQ\n\n4/"
        }
    },
    {
        "data": {
            "conversation_id": "1551609257472172034",
            "id": "1551609260211052545",
            "text": "The approximation becomes more accurate with smaller changes:\n\n&gt;&gt;&gt; x1, x2 = 25.1, 25.4\n&gt;&gt;&gt; (x2 - x1) / x1\n0.011952191235059646\n&gt;&gt;&gt; log(x2) - log(x1)\n0.011881327886752224\n\nHere's the math:\n\nhttps://t.co/KNHcjZpf6C\n\n3/",
            "edit_history_tweet_ids": [
                "1551609260211052545"
            ]
        }
    },
    {
        "data": {
            "text": "It works for percentage decreases as well:\n\n&gt;&gt;&gt; x1, x2 = 25.1, 19.9\n&gt;&gt;&gt; (x2 - x1) / x1\n-0.20717131474103595\n&gt;&gt;&gt; log(x2) - log(x1)\n-0.23214811440729166\n\n2/",
            "edit_history_tweet_ids": [
                "1551609259129020421"
            ],
            "conversation_id": "1551609257472172034",
            "id": "1551609259129020421"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1551609257472172034"
            ],
            "id": "1551609257472172034",
            "text": "#Python Data science rule of thumb:  Percentage changes are approximated by the difference in natural logarithms.\n\n&gt;&gt;&gt; x1, x2 = 25.1, 29.7\n&gt;&gt;&gt; (x2 - x1) / x1\n0.18326693227091623\n&gt;&gt;&gt; log(x2) - log(x1)\n0.16827919967091542\n\nThis is useful for interpreting log plots.\n\n1/",
            "conversation_id": "1551609257472172034"
        }
    },
    {
        "data": {
            "text": "The lion's share of the speed-up is due to argument parsing.\n\nA tiny portion of the speed-up is algorithmic:\n\nhttps://t.co/hdrJOrE2PI\n\n4/",
            "edit_history_tweet_ids": [
                "1551282440777437184"
            ],
            "conversation_id": "1551282437510021120",
            "id": "1551282440777437184"
        }
    },
    {
        "data": {
            "conversation_id": "1551282437510021120",
            "text": "% python3.11 -m timeit -s 'from math import pi, log, log2' 'log(pi)'\n5000000 loops, best of 5: 42 nsec per loop\n\n% python3.11 -m timeit -s 'from math import pi, log, log2' 'log2(pi)'\n10000000 loops, best of 5: 23.2 nsec per loop\n\n3/",
            "id": "1551282439569526787",
            "edit_history_tweet_ids": [
                "1551282439569526787"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1551282437510021120",
            "text": "I just used this fact to get a 25% speed-up for the standard library's new random.binomialvariate() function.\n\n2/",
            "edit_history_tweet_ids": [
                "1551282438625808385"
            ],
            "id": "1551282438625808385"
        }
    },
    {
        "data": {
            "text": "#Python performance tip:  Specialized functions with simpler signatures tend to beat their more generalized counterparts.\n\nlog2(x) and log10(x) are almost twice as fast as log(x) and three times as fast as log(x, 2) or log(x, 2.0).\n\n1/",
            "conversation_id": "1551282437510021120",
            "edit_history_tweet_ids": [
                "1551282437510021120"
            ],
            "id": "1551282437510021120"
        }
    },
    {
        "data": {
            "id": "1547227459329957888",
            "conversation_id": "1547227455009734658",
            "edit_history_tweet_ids": [
                "1547227459329957888"
            ],
            "text": "More from the docs:\n\nThe replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\n5/"
        }
    },
    {
        "data": {
            "text": "Per the docs:\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed.\n\n4/",
            "conversation_id": "1547227455009734658",
            "edit_history_tweet_ids": [
                "1547227458256125952"
            ],
            "id": "1547227458256125952"
        }
    },
    {
        "data": {
            "text": "Even the type field can also be variable:\n\n&gt;&gt;&gt; n = 123\n&gt;&gt;&gt; t = 'd'; f'{n:{t}}'  # decimal\n'123'\n&gt;&gt;&gt; t = 'o'; f'{n:{t}}'  # octal\n'173'\n&gt;&gt;&gt; t = 'x'; f'{n:{t}}'  # hex\n'7b'\n\n3/",
            "conversation_id": "1547227455009734658",
            "edit_history_tweet_ids": [
                "1547227457257963521"
            ],
            "id": "1547227457257963521"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1547227456289087493"
            ],
            "id": "1547227456289087493",
            "text": "Interestingly, this works for any part of the format specifier, including justification:\n\n&gt;&gt;&gt; s = 'aloha'\n&gt;&gt;&gt; just = '&lt;'\n&gt;&gt;&gt; f'{s:{just}10}'\n'aloha     '\n\n&gt;&gt;&gt; just = '&gt;'\n&gt;&gt;&gt; f'{s:{just}10}'\n'     aloha'\n\n2/",
            "conversation_id": "1547227455009734658"
        }
    },
    {
        "data": {
            "conversation_id": "1547227455009734658",
            "text": "#Python tip: Create variable width fields in f-strings with an inner pair of curly braces.\n\n&gt;&gt;&gt; s = 'hello'\n&gt;&gt;&gt; n = 10\n&gt;&gt;&gt; f'{s:^{n}}'\n'  hello   '\n\n&gt;&gt;&gt; n = 20\n&gt;&gt;&gt; f'{s:^{n}}'\n'       hello        '\n\n1/",
            "edit_history_tweet_ids": [
                "1547227455009734658"
            ],
            "id": "1547227455009734658"
        }
    },
    {
        "data": {
            "text": "The bug in BTRS was much harder to find and involved tracing through all the mathematical reasoning and relating it back to the code step-by-step.\n\nhttps://t.co/iL0iGRCRHH",
            "conversation_id": "1545896314545790978",
            "edit_history_tweet_ids": [
                "1545896319067340801"
            ],
            "id": "1545896319067340801"
        }
    },
    {
        "data": {
            "text": "The error in BG only ate an hour.\n\nhttps://t.co/BB4ZuXZ3jM",
            "conversation_id": "1545896314545790978",
            "id": "1545896317611909121",
            "edit_history_tweet_ids": [
                "1545896317611909121"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1545896314545790978",
            "text": "This weekend, I implemented random.binomialvariate() for #Python.\n\nBOTH of the papers I relied on had errors in the algorithm specifications.  Argh!\n\nOn the plus side, after debugging their papers, I now understand the code much better ;-)\n\nhttps://t.co/bGoRsVz8Ed",
            "id": "1545896316013879298",
            "edit_history_tweet_ids": [
                "1545896316013879298"
            ]
        }
    },
    {
        "data": {
            "text": "Protip for the under appreciated:  If you're publishing an algorithm, be sure to put a subtle error in the code.\n\nThat will ensure the implementers have to thoroughly read, understand, and check every step before they can get a useful result.",
            "id": "1545896314545790978",
            "edit_history_tweet_ids": [
                "1545896314545790978"
            ],
            "conversation_id": "1545896314545790978"
        }
    },
    {
        "data": {
            "conversation_id": "1543592205268426757",
            "id": "1543592205268426757",
            "text": "#Python PEP 695 proposes a new syntax for declaring type parameters for generic classes, functions, and type aliases.\n\nThis will be a big win. The current state of affairs is a recurring source of confusion and is quite unpleasant.\n\nhttps://t.co/6dLNti4pm1",
            "edit_history_tweet_ids": [
                "1543592205268426757"
            ]
        }
    },
    {
        "data": {
            "text": "Takeways:\n\n* Sets, itertools, and collections make short work of problems like this.\n\n* Big-Oh running times matter.\n\n* Constant factors matter.\n\n* Discrete mathematics is a treasure trove of ideas.\n\n* It is hard to know what is best until you do analysis and run timings :-)\n\n2/",
            "conversation_id": "1542940114388750336",
            "edit_history_tweet_ids": [
                "1542940115638550528"
            ],
            "id": "1542940115638550528"
        }
    },
    {
        "data": {
            "conversation_id": "1542940114388750336",
            "text": "Some #Python questions on StackOverflow are surprisingly fertile. They teach you to not stop thinking once a first solution is found.\n\n1/\n\nhttps://t.co/XHceH6acMr",
            "edit_history_tweet_ids": [
                "1542940114388750336"
            ],
            "id": "1542940114388750336"
        }
    },
    {
        "data": {
            "conversation_id": "1541722007687020545",
            "edit_history_tweet_ids": [
                "1541722008987340801"
            ],
            "id": "1541722008987340801",
            "text": "The name indices() had been a proposed because a principal use case was associated values with the indices of those values.\n\n&gt;&gt;&gt; s = 'abc'\n&gt;&gt;&gt; list(enumerate(s))\n[(0, 'a'), (1, 'b'), (2, 'c')]\n&gt;&gt;&gt; s[0]\n'a'\n&gt;&gt;&gt; s[1]\n'b'\n&gt;&gt;&gt; s[2]\n'c'"
        }
    },
    {
        "data": {
            "text": "#Python tidbit:  Names matter.  If enumerate() had been called indices(), we never would have gotten a *start* argument.",
            "conversation_id": "1541722007687020545",
            "edit_history_tweet_ids": [
                "1541722007687020545"
            ],
            "id": "1541722007687020545"
        }
    },
    {
        "data": {
            "conversation_id": "1536105875441590279",
            "id": "1536120072867037184",
            "text": "I you want more background and detail, I created StackOverflow Q&amp;A for this topic:\n\nhttps://t.co/5tqawuU5tv\n\n5/",
            "edit_history_tweet_ids": [
                "1536120072867037184"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1536105875441590279",
            "edit_history_tweet_ids": [
                "1536105880185356291"
            ],
            "id": "1536105880185356291",
            "text": "The kwargs are there to support the rel_tol and abs_tol arguments for isclose().\n\nassert approx(1.1 + 2.2) != 3.4\nassert approx(1.1 + 2.2, abs_tol=0.2) == 3.4\n\nComplex values are supported.\n\nassert approx(1.1j + 2.2j) == 0.0 + 3.3j\n\n4/"
        }
    },
    {
        "data": {
            "text": "class approximately(complex):\n    def __new__(cls, x, /, **kwargs):\n        result = complex.__new__(cls, x)\n        result.kwargs = kwargs\n        return result\n    def __eq__(self, other):\n        return cmath.isclose(self, other, **self.kwargs)\n\n3/",
            "conversation_id": "1536105875441590279",
            "edit_history_tweet_ids": [
                "1536105878486654976"
            ],
            "id": "1536105878486654976"
        }
    },
    {
        "data": {
            "id": "1536105877006127105",
            "edit_history_tweet_ids": [
                "1536105877006127105"
            ],
            "conversation_id": "1536105875441590279",
            "text": "Without the approximately() wrapper, the case would not match due to round-off error.\n\n&gt;&gt;&gt; 1.1 + 2.2 == 3.3\nFalse\n\n&gt;&gt;&gt; 1.1 + 2.2\n3.3000000000000003\n\n&gt;&gt;&gt; 1.1 + 2.2 - 3.3\n4.440892098500626e-16\n\nSo, we need an approximate match wrapper.\n\n/2"
        }
    },
    {
        "data": {
            "conversation_id": "1536105875441590279",
            "edit_history_tweet_ids": [
                "1536105875441590279"
            ],
            "text": "Structural pattern matching in #Python supports float and complex literals in case statements.\n\nHowever, exact equality tests for float/complex are often a bad idea.\n\nHere's a fix.\n\nmatch approximately(1.1 + 2.2):\n    case 3.3:\n        print('hit!')\n\n1/",
            "id": "1536105875441590279"
        }
    },
    {
        "data": {
            "text": "&gt;&gt;&gt; Fraction(39, 143)\nFraction(3, 11)",
            "conversation_id": "1535635417306914820",
            "edit_history_tweet_ids": [
                "1535635420578553858"
            ],
            "id": "1535635420578553858"
        }
    },
    {
        "data": {
            "conversation_id": "1535635417306914820",
            "text": "There is a currently a proposal to add __match_args__ to Fraction.  Apparently, I'm the only one who thinks this is a bad idea:\n\nmatch Fraction(n, 143):\n    case Fraction(38, 143):\n        print('possible match')\n    case Fraction(39, 143):\n        print('this can never match')",
            "edit_history_tweet_ids": [
                "1535635419001405440"
            ],
            "id": "1535635419001405440"
        }
    },
    {
        "data": {
            "conversation_id": "1535635417306914820",
            "text": "#Python anti-pattern.   Don't use __match_args__ in classes where the stored attribute values don't agree with those used in the constructor.\n\n&gt;&gt;&gt; f = Fraction(6, 8)\n&gt;&gt;&gt; f.numerator == 6\nFalse\n\n1/",
            "id": "1535635417306914820",
            "edit_history_tweet_ids": [
                "1535635417306914820"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1534632938511400966",
            "edit_history_tweet_ids": [
                "1534642378522378240"
            ],
            "text": "If you switch to an infinite source of primes, the loop condition simplifies to \"n &gt;= 1\":\n\nn = 2759484\np = next(prime)\nwhile n &gt;= 1:\n    q, r = divmod(n, p)\n    if r:\n        p = next(prime)\n    else:\n        print(p, q)\n        n = q",
            "id": "1534642378522378240"
        }
    },
    {
        "data": {
            "conversation_id": "1534632938511400966",
            "text": "prime = iter((2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37))\n\nn = 2_759_484\np = next(prime)\nwhile True:\n    q, r = divmod(n, p)\n    if r == 0:\n        print(p)\n        n = q\n    if r != 0:\n        p = next(prime)\n    if q &lt; p:\n        break",
            "id": "1534632943078998016",
            "edit_history_tweet_ids": [
                "1534632943078998016"
            ]
        }
    },
    {
        "data": {
            "text": "n - number    p - prime   q - quotient   r - remainder\n\nq, r = divmod(n, p)\nif r == 0: then p is a factor and q is the new n\nif r != 0: set p to the next largest prime\nrepeat until q &lt; p",
            "edit_history_tweet_ids": [
                "1534632941594284033"
            ],
            "conversation_id": "1534632938511400966",
            "id": "1534632941594284033"
        }
    },
    {
        "data": {
            "attachments": {
                "media_keys": [
                    "3_1534624921485287424"
                ]
            },
            "conversation_id": "1534632938511400966",
            "text": "This #Python daddy is impressed. My ten year-old wanted to \"run a new algorithm\", so I sketched out a procedure for prime factorizations. He then manually factored 2,759,484 into 2*2*3*7*7*13*19*19.\n\nWe also wrote it in #Python so the computer could have some fun as well.  \ud83d\ude09 https://t.co/eUdH392DGM",
            "edit_history_tweet_ids": [
                "1534632938511400966"
            ],
            "id": "1534632938511400966"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1534624921485287424",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/FUwVPDyXoAARSxs.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "text": "My first intuition is that this is essentially the Euclidean GCD algorithm being run in reverse, generating all cases where gcd(m, n) = 1 and m &gt; n.\n\nBy covering all possible one-step reductions, it is guaranteed to be exhaustive.",
            "edit_history_tweet_ids": [
                "1534458121212645376"
            ],
            "conversation_id": "1534458117068668929",
            "id": "1534458121212645376"
        }
    },
    {
        "data": {
            "id": "1534458119132172289",
            "edit_history_tweet_ids": [
                "1534458119132172289"
            ],
            "conversation_id": "1534458117068668929",
            "text": "This exhaustively lists all combinations of relatively prime positive integers \u2014 pairs that don't have a common factor other than one.\n\nTo me, this seems like great magic.\n\nWikipedia attributes the algorithm to various Math Gazette articles (behind a paywall)."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1534458117068668929"
            ],
            "id": "1534458117068668929",
            "text": "Cute #Python math algorithm of the day:\n\ndef coprimes():\n    pairs = deque([(2,1), (3,1)])\n    while True:\n        m, n = p = pairs.popleft()\n        yield p\n        pairs.append((2*m - n, m))\n        pairs.append((2*m + n, m))\n        pairs.append((m + 2*n, n))",
            "conversation_id": "1534458117068668929"
        }
    },
    {
        "data": {
            "text": "This #StackOverflow #Python question is even worse.\n\nThe OP already knows they are using the wrong tool for the job but is persisting never-the-less.\n\n\"I know helicopters make bad submarines, but how would you do it anyway?\"\n\nhttps://t.co/tWlyL8KMWu",
            "id": "1533431676717744134",
            "edit_history_tweet_ids": [
                "1533431676717744134"
            ],
            "conversation_id": "1533399872669351938"
        }
    },
    {
        "data": {
            "conversation_id": "1533399872669351938",
            "text": "More and more, #Python questions on #StackOverflow are in the form: \"I have a shovel and rake. How do I modify the shovel to easily rake leaves, and how do I modify the rake to move easily shovel dirt?\"\n\nhttps://t.co/aexUj7czHP",
            "edit_history_tweet_ids": [
                "1533399872669351938"
            ],
            "id": "1533399872669351938"
        }
    },
    {
        "data": {
            "text": "The other conference hash tag is #PyConItalia",
            "edit_history_tweet_ids": [
                "1533370271092117505"
            ],
            "conversation_id": "1533369936739016705",
            "id": "1533370271092117505"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1533369947191140353"
            ],
            "id": "1533369947191140353",
            "text": "The PDF isn't pretty.  My slides are generated by Sphinx in a read-tuhe-docs format.  When I get a chance (and figure-out how), I'll post the beautiful version of the slides on Github pages.\n\nHopefully, by then I'll have a video link to post as well.\n\nEnjoy!",
            "conversation_id": "1533369936739016705"
        }
    },
    {
        "data": {
            "conversation_id": "1533369936739016705",
            "edit_history_tweet_ids": [
                "1533369945534472192"
            ],
            "id": "1533369945534472192",
            "text": "#Python 's Structural pattern matching is amazing.\n\nBut when you apply it to real world code, all kinds of interesting problems arise and the solutions aren't always obvious."
        }
    },
    {
        "data": {
            "id": "1533369943764488192",
            "conversation_id": "1533369936739016705",
            "edit_history_tweet_ids": [
                "1533369943764488192"
            ],
            "text": "I'll post a link to the presentation video when it is available, but I only had 30 minutes.\n\nPerhaps another conference has an open back to back timeslots for 60 to 75 minutes.\n\nThis is a super interesting topic."
        }
    },
    {
        "data": {
            "text": "There is a problems and solutions section:\n\n* Inverting case logic\n* Matching sets and frozensets\n* Exact type matches\n* Order of overlapping cases\n* Converting hasattr() duck typed cases\n* Handling difficult cases\n* Fooling aggressive linters\n* Floating point special values",
            "conversation_id": "1533369936739016705",
            "edit_history_tweet_ids": [
                "1533369942090948610"
            ],
            "id": "1533369942090948610"
        }
    },
    {
        "data": {
            "conversation_id": "1533369936739016705",
            "id": "1533369940153188353",
            "text": "We draw key learning points from real #Python applications:\n\n* Datetime formatting mini language\n* Language tokenizer\n* SQL logic for JSON lines\n* SQL logic for two level JSON\n* Traversing arbitrary depth JSON trees\n* Marshal style data serializer",
            "edit_history_tweet_ids": [
                "1533369940153188353"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1533369938559356929"
            ],
            "id": "1533369938559356929",
            "text": "You'll find #Python pattern matching recipes for:\n\n* Replacing literals with variables and named constants\n* Replacing literals with regexes\n* Replacing literals with function calls\n* Replacing literals with set membership tests",
            "conversation_id": "1533369936739016705"
        }
    },
    {
        "data": {
            "conversation_id": "1533369936739016705",
            "text": "Here's a PDF for my #Python #PyConIT2022 talk:  Structural Pattern Matching in the Real World:  New tooling, real code, problems solved.\n\nThis is intermediate and advanced level Structural Pattern Matching.\n\ntl;dr The \u201cgood stuff\u201d is in section 1.2\n\nhttps://t.co/CwguxhRaZS",
            "edit_history_tweet_ids": [
                "1533369936739016705"
            ],
            "id": "1533369936739016705"
        }
    },
    {
        "data": {
            "text": "This will be my first #Python conference since the start of the pandemic. It will be liberating to be among friends in-person once again. \ud83d\ude42\n\n3/",
            "conversation_id": "1530398887864897536",
            "edit_history_tweet_ids": [
                "1530398889852952580"
            ],
            "id": "1530398889852952580"
        }
    },
    {
        "data": {
            "conversation_id": "1530398887864897536",
            "text": "The keynote will be about the craft of writing unit tests.\n\nI also have an intermediate level talk about real world applications for structural pattern matching, the problems encountered and their solutions (one of which is truly magical, removing a major obstacle).\n\n2/",
            "edit_history_tweet_ids": [
                "1530398888888356865"
            ],
            "id": "1530398888888356865"
        }
    },
    {
        "data": {
            "id": "1530398887864897536",
            "edit_history_tweet_ids": [
                "1530398887864897536"
            ],
            "conversation_id": "1530398887864897536",
            "text": "Twelve years ago, I took my new bride to #PyItalia just before our honeymoon.\n\nIn just a few hours, we're leaving the U.S., destined once again for that cherished #Python conference.  This time, we'll have our ten year old child in tow ;-)\n\n1/"
        }
    },
    {
        "data": {
            "conversation_id": "1529917438728491029",
            "id": "1529920415052746762",
            "text": "It wouldn't be just for magic methods.\n\n# Examples from collections.UserLIst\n\ndef append(self, item):\n    https://t.co/ncHwUzZ0LU.append(item)\n\ndef insert(self, i, item):\n     https://t.co/ncHwUzZ0LU.insert(i, item)\n\ndef pop(self, i=-1):\n    return https://t.co/ncHwUzZ0LU.pop(i)",
            "edit_history_tweet_ids": [
                "1529920415052746762"
            ]
        }
    },
    {
        "data": {
            "id": "1529917438728491029",
            "conversation_id": "1529917438728491029",
            "edit_history_tweet_ids": [
                "1529917438728491029"
            ],
            "text": "#Python idea:  Would auto delegation be useful for you?\n\n@dataclass\nclass A:\n   seq: list\n   __len__ = delegate('seq')\n   __getitem__ = delegate('seq')\n\nSpelled-out equivalent code:\n\n  def __len__(self):\n    return len(self.seq)\n\n  def __getitem__(self, i):\n    return self.seq[I]"
        }
    },
    {
        "data": {
            "conversation_id": "1529534487465451521",
            "edit_history_tweet_ids": [
                "1529534491043274752"
            ],
            "text": "\"Write a data structure that works like collections.Counter that reduces the speed of the most_common(k) to O(k) but at the expense of O(log n) update costs.\"\n\nSo the hash table needs to be replaced by a balanced binary tree or by a sorted list updated by bisect.insort().",
            "id": "1529534491043274752"
        }
    },
    {
        "data": {
            "id": "1529534489889845250",
            "edit_history_tweet_ids": [
                "1529534489889845250"
            ],
            "conversation_id": "1529534487465451521",
            "text": "Another variation is for a teacher (or interviewer) to weight problem requirements so as to preclude the most common, obvious, or builtin solutions."
        }
    },
    {
        "data": {
            "text": "\"I have to reverse a list but cannot use slicing or call any methods or functions\".\n\nThat precludes, s[::-1], s.reverse(), and list(reversed(s)).\n\n2/",
            "id": "1529534488702754819",
            "edit_history_tweet_ids": [
                "1529534488702754819"
            ],
            "conversation_id": "1529534487465451521"
        }
    },
    {
        "data": {
            "conversation_id": "1529534487465451521",
            "id": "1529534487465451521",
            "text": "StackOverflow provides a testament to the richness of #Python tooling.\n\nOver and over, people post questions from teachers (or interviewers) in the form of \"Write a function that does x, but you're not allowed to use the tool that already does that\".\n\n1/",
            "edit_history_tweet_ids": [
                "1529534487465451521"
            ]
        }
    },
    {
        "data": {
            "text": "I'm curious. What do you all do?\n\na) Don't ever have a need for do-while\n\nb) while True: &lt;body&gt; if not &lt;cond&gt;: break\n\nc) Duplicate code.  &lt;body&gt; while &lt;cond&gt;: &lt;body&gt;\n\nAlso, do you like this?\n\ndo ... while &lt;cond&gt;:\n    &lt;body&gt;",
            "conversation_id": "1528772337306419200",
            "id": "1528772343211892738",
            "edit_history_tweet_ids": [
                "1528772343211892738"
            ]
        }
    },
    {
        "data": {
            "id": "1528772342024966144",
            "text": "I'm not happy with the status quo.  With two levels of indentation and an inverted test condition, it is awkward enough to where people seem to prefer duplicating code.\n\n&lt;body&gt;\nwhile &lt;cond&gt;:\n    &lt;same body&gt;\n\n5/",
            "edit_history_tweet_ids": [
                "1528772342024966144"
            ],
            "conversation_id": "1528772337306419200"
        }
    },
    {
        "data": {
            "conversation_id": "1528772337306419200",
            "text": "It was a mistake for the PEP to address the more general \"loop and a half\" problem \u2014 while loops where the termination test is in the middle.\n\nIt's the do-while case that is important.  Everything else was a distraction.\n\n4/",
            "id": "1528772340917600259",
            "edit_history_tweet_ids": [
                "1528772340917600259"
            ]
        }
    },
    {
        "data": {
            "id": "1528772339818717185",
            "edit_history_tweet_ids": [
                "1528772339818717185"
            ],
            "conversation_id": "1528772337306419200",
            "text": "If you want to avoid repeating code, our status quo solution/recommendation is this:\n\nwhile True:\n   &lt;body&gt;\n   if not &lt;cond&gt;:\n       break\n\n3/"
        }
    },
    {
        "data": {
            "id": "1528772338610839553",
            "conversation_id": "1528772337306419200",
            "edit_history_tweet_ids": [
                "1528772338610839553"
            ],
            "text": "To put the condition at the bottom, we have to fight #Python's pattern of a colon preceding an indented suite of statements terminated by unindenting.\n\nThat leads to awkward proposals like this:\n\ndo:\n    &lt;setup code&gt;\nwhile &lt;condition&gt;:\n    &lt;loop body&gt;\n\n2/"
        }
    },
    {
        "data": {
            "conversation_id": "1528772337306419200",
            "text": "Once upon a time in PEP 315, I explored adding a do-while loop to #Python.  No perfect fit was found.  The best candidate was:\n\ndo ... while &lt;cond&gt;:\n    &lt;body&gt;\n\nI liked this, but most core devs intensely disliked the condition being at the top of the loop.\n\n1/",
            "id": "1528772337306419200",
            "edit_history_tweet_ids": [
                "1528772337306419200"
            ]
        }
    },
    {
        "data": {
            "text": "The ChainMap order is helpful when the \"base\" dict defines keys in a meaningful order and the \"shallower\" dicts serve to override values or add new key/value pairs.\n\noptions = ChainMap(vars(comm_line_args), os.environ, application_defaults)\n\n4/",
            "edit_history_tweet_ids": [
                "1528436079992397825"
            ],
            "conversation_id": "1528436075689086977",
            "id": "1528436079992397825"
        }
    },
    {
        "data": {
            "text": "ChainMap resolves ordering differences by favoring the \"deepest\" dicts over the \"shallowest\":\n\n&gt;&gt;&gt; dict(ChainMap(dict(c=6, f=7), dict(a=1, b=2, c=3, d=4, e=5)))\n{'a': 1, 'b': 2, 'c': 6, 'd': 4, 'e': 5, 'f': 7}\n\n3/",
            "id": "1528436078880907269",
            "edit_history_tweet_ids": [
                "1528436078880907269"
            ],
            "conversation_id": "1528436075689086977"
        }
    },
    {
        "data": {
            "conversation_id": "1528436075689086977",
            "text": "The order for d |= e makes sense because it matches d.update(e).\n\nThis supports use cases where the \"base\" dict \"d\" defines a meaningful order and the update either overrides values or adds new key/value pairs.\n\n{**d, **e} behaves similarly.\n\n2/",
            "edit_history_tweet_ids": [
                "1528436077513547779"
            ],
            "id": "1528436077513547779"
        }
    },
    {
        "data": {
            "conversation_id": "1528436075689086977",
            "text": "#Python factlet:  When merging dicts with the \"|\" operator, ordering differences are resolved in favor of the leftmost dictionary.\n\n&gt;&gt; dict(a=1, b=2, c=3, d=4, e=5) | dict(c=6, f=7)\n{'a': 1, 'b': 2, 'c': 6, 'd': 4, 'e': 5, 'f': 7}\n\n'c' keeps original order\n'f' goes at the end\n\n1/",
            "id": "1528436075689086977",
            "edit_history_tweet_ids": [
                "1528436075689086977"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1527756863005138944",
            "text": "There's no intent to go down the path of Go, Rust, or Monads.\n\nThis is just a convenience for testing that two functions have the same API.  I need to loop over a variety of input values and assert that the outputs, either values or exceptions, are the same.\n\n5/",
            "id": "1527831693268242433",
            "edit_history_tweet_ids": [
                "1527831693268242433"
            ]
        }
    },
    {
        "data": {
            "id": "1527756866364874752",
            "text": "It might be better with a named tuple, but I haven't needed that yet:\n\nclass CallResult(NamedTuple):\n    exception: Exception\n    return_value: Any\n\n4/",
            "edit_history_tweet_ids": [
                "1527756866364874752"
            ],
            "conversation_id": "1527756863005138944"
        }
    },
    {
        "data": {
            "text": "def exc_and_value(func, *args, **kwargs):\n    try:\n        return (None, func(*args, **kwargs))\n    except Exception as e:\n        return (type(e), None)\n\n3/",
            "conversation_id": "1527756863005138944",
            "edit_history_tweet_ids": [
                "1527756865249193984"
            ],
            "id": "1527756865249193984"
        }
    },
    {
        "data": {
            "id": "1527756864120832004",
            "text": "This is especially helpful when writing tests to show that two functions are equivalent, both in regular operation and in raising exceptions:\n\nself.assertEqual(\n   exc_and_value(math.comb, n, r),\n   exc_and_value(pure_python.comb, n, r)\n)\n\n2/",
            "edit_history_tweet_ids": [
                "1527756864120832004"
            ],
            "conversation_id": "1527756863005138944"
        }
    },
    {
        "data": {
            "conversation_id": "1527756863005138944",
            "edit_history_tweet_ids": [
                "1527756863005138944"
            ],
            "text": "My new favorite #Python helper function makes a call and puts the results in an (exception, result) pair:\n\n&gt;&gt;&gt; exc_and_value('abcde'.index, 'd')\n(None, 3)\n&gt;&gt;&gt; exc_and_value('abcde'.index, 'f')\n(&lt;class 'ValueError'&gt;, None)\n\n1/",
            "id": "1527756863005138944"
        }
    },
    {
        "data": {
            "conversation_id": "1526654942429302784",
            "text": "#Python crowd sourcing:   The docstring for str.join() has as awkward sentence that only makes sense after you know what the method does.\n\nCan you suggest an improvement?\n\n\"The string whose method is called is inserted in between each given string.\"",
            "id": "1526654942429302784",
            "edit_history_tweet_ids": [
                "1526654942429302784"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1526204322744262656",
            "text": "Instead, you need to use a line continuation character:\n\nassert 'Active/Standby' in output or 'Active/Active' in output, \\\n       'Check failover in the licensed features'\n\n2/",
            "id": "1526204324078043136",
            "edit_history_tweet_ids": [
                "1526204324078043136"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1526204322744262656",
            "text": "#Python tip: Don't use parentheses for multiline assert statements \u2014 they form a non-empty tuple which is always True.\n\nassert ('Active/Standby' in output or 'Active/Active' in output,\n        'Check failover in the licensed features')\n\n1/",
            "id": "1526204322744262656",
            "edit_history_tweet_ids": [
                "1526204322744262656"
            ]
        }
    },
    {
        "data": {
            "id": "1525219029425717250",
            "text": "Hmm.  My previous #Python tweet seems to be on hold by Twitter.  I wonder what bot was triggered by a straight-forward technical tweet?\n\nThe impression count grew at a normal rate for a half-hour and then froze with zero additional views in the new half hour. https://t.co/1qjkkGUFMZ",
            "edit_history_tweet_ids": [
                "1525219029425717250"
            ],
            "conversation_id": "1525219029425717250"
        }
    },
    {
        "data": {
            "id": "1525193716113317888",
            "text": "In normal #Python code, a constant can always be replaced with a variable or expression.\n\nWith structural pattern matching, you need to replace a literal pattern with a value pattern so that an expression can be called outside of the case clause.\n\nhttps://t.co/pYmFqiGZjY",
            "edit_history_tweet_ids": [
                "1525193716113317888"
            ],
            "conversation_id": "1525193716113317888"
        }
    },
    {
        "data": {
            "conversation_id": "1524834238289301514",
            "text": "Also, people may be legitimately using ** unpacking:\n\n    randrange(**parameters)\n\nSo, deprecation would cause unnecessary pain.\n\n4/",
            "edit_history_tweet_ids": [
                "1524858058576384000"
            ],
            "id": "1524858058576384000"
        }
    },
    {
        "data": {
            "text": "We could deprecate having keyword arguments for randrange().  That would avoid the weird cases and harmonize the API with range() which never took keyword arguments.\n\nHowever, there are people who have cleanly and legitimately written:\n\n     randrange(start=100, stop=200)\n\n3/",
            "conversation_id": "1524834238289301514",
            "edit_history_tweet_ids": [
                "1524857588344668171"
            ],
            "id": "1524857588344668171"
        }
    },
    {
        "data": {
            "id": "1524834242571579392",
            "text": "I do have a patch to catch cases like this, but it is somewhat messy and gross.\n\n2/ https://t.co/CD7QAzQSeW",
            "attachments": {
                "media_keys": [
                    "3_1524834100271534106"
                ]
            },
            "edit_history_tweet_ids": [
                "1524834242571579392"
            ],
            "conversation_id": "1524834238289301514"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1524834100271534106",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/FSlMiQgWUBoMtLN.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1524834238289301514",
            "id": "1524834238289301514",
            "text": "The API for #Python's randrange() predates our ability to define positional-only arguments.\n\nSo we have to live with minor atrocities like this:\n\n&gt;&gt;&gt; randrange(start=100)\n64\n\n1/",
            "edit_history_tweet_ids": [
                "1524834238289301514"
            ]
        }
    },
    {
        "data": {
            "id": "1524801727593078784",
            "edit_history_tweet_ids": [
                "1524801727593078784"
            ],
            "conversation_id": "1524801727593078784",
            "text": "\"Sgr A* it completes an orbit in mere minutes. This means the brightness and pattern of the gas around Sgr A* was changing rapidly as the EHT Collaboration was observing it \u2014 a bit like trying to take a clear picture of a puppy quickly chasing its tail.\"\n\nhttps://t.co/ufkFZc31n5"
        }
    },
    {
        "data": {
            "conversation_id": "1524246957987975170",
            "text": "#Python pop quiz:\n\nIn bisect(array, value, key=somefunc), the key function is only applied to elements of the array but not the value.\n\nIn insort(array, value, key=somefunc), the key function is applied to both the elements of the array and the value.\n\nCan you figure-out why?",
            "edit_history_tweet_ids": [
                "1524246957987975170"
            ],
            "id": "1524246957987975170"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1523804319459549184"
            ],
            "id": "1523804319459549184",
            "text": "Interestingly, it wouldn't be hard to add that capability to dataclasses:\n\n  age: int = field(assert_isinstance=int)\n\nor\n\n  age: int = field(type_converter=int)\n\n3/",
            "conversation_id": "1523804316775362560"
        }
    },
    {
        "data": {
            "id": "1523804318238920704",
            "edit_history_tweet_ids": [
                "1523804318238920704"
            ],
            "conversation_id": "1523804316775362560",
            "text": "The effect is strong in beginners who've only recently been introduced to type annotations.\n\nThe effect is even stronger for people who have been exposed to ORMs, traitlets, argparse, or other tools where class variables are used to define actions at the instance level.\n\n2/"
        }
    },
    {
        "data": {
            "id": "1523804316775362560",
            "text": "When people first encounter @dataclass or NamedTuple in #Python, it is common for people to believe that the type annotations will generate type checks or type coercions.\n\n@ dataclass \nclass Person:\n  name: str\n  age: int\n\nPerson('Alice', '30')\n\n1/",
            "edit_history_tweet_ids": [
                "1523804316775362560"
            ],
            "conversation_id": "1523804316775362560"
        }
    },
    {
        "data": {
            "conversation_id": "1522414873065541632",
            "id": "1522417711061610496",
            "text": "#Python is great for simple demonstrations like this.\n\nA pencil and paper solution is too tedious and lacks the magic of having instant results:  Ukelele \u2248 Guitar and Flute \u2248 Recorder.",
            "edit_history_tweet_ids": [
                "1522417711061610496"
            ]
        }
    },
    {
        "data": {
            "text": "This was all a little hand wavy (include eyeball measurements of instruments, contrived model parameters, and very shallow learning), but he got the gist of it.\n\nComputers can be trained to recognize and generalize with math that a 4th grader can understand. \ud83d\ude09\n\n5/",
            "edit_history_tweet_ids": [
                "1522414878052556801"
            ],
            "conversation_id": "1522414873065541632",
            "id": "1522414878052556801"
        }
    },
    {
        "data": {
            "conversation_id": "1522414873065541632",
            "text": "# Validation set\nukulele = [0, 0, 2, 2, 6, 8, 7, 10, 8, 7, 2, 0]\nflute = [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]\n\n&gt;&gt;&gt; what_is_it(ukulele)\n'guitar'\n&gt;&gt; what_is_it(flute)\n'recorder'\n\n4/",
            "edit_history_tweet_ids": [
                "1522414876878123008"
            ],
            "id": "1522414876878123008"
        }
    },
    {
        "data": {
            "text": "def what_is_it(v):\n    total = sum(v_i * m_i for (v_i, m_i) in zip(v, model))\n    return 'guitar' if total &gt; 150 else 'recorder'\n\n&gt;&gt;&gt; what_is_it(guitar)\n'guitar'\n&gt;&gt;&gt; what_is_it(recorder)\n'recorder'\n\n3/",
            "edit_history_tweet_ids": [
                "1522414875724685312"
            ],
            "conversation_id": "1522414873065541632",
            "id": "1522414875724685312"
        }
    },
    {
        "data": {
            "id": "1522414874495754240",
            "text": "# Training set\n# Width of instruments at various heights\nguitar = [3, 2, 2, 2, 8, 10, 9, 10, 12, 14, 4, 2]\nrecorder = [0, 0, 0, 1, 0.80, .75, 0.70, 1, 0, 0, 0, 0]\n\n# Hand-built perceptron\nmodel = [10, 10, 10, 5, 8, -1, -1, -1, 1, 10, 10, 10]\n\n2/",
            "edit_history_tweet_ids": [
                "1522414874495754240"
            ],
            "conversation_id": "1522414873065541632"
        }
    },
    {
        "data": {
            "conversation_id": "1522414873065541632",
            "text": "Highlight of my day: My 10 year old son asked, \"What is AI?\" and \"How do machines learn?\".\n\nSo, we built a 12 element perceptron and hand-trained it to distinguish a guitar from a recorder.\n\nThe model generalized that Ukuleles are like Guitars and Flutes are like Recorders.\n\n1/",
            "id": "1522414873065541632",
            "edit_history_tweet_ids": [
                "1522414873065541632"
            ]
        }
    },
    {
        "data": {
            "id": "1522299643228573702",
            "edit_history_tweet_ids": [
                "1522299643228573702"
            ],
            "conversation_id": "1522299643228573702",
            "text": "In the past 24 hours, I've gained a new appreciation for the median_grouped() function in the #Python statistics module.\n\nLast night, I greatly improved the docstring with a reasonable use case and explained why this can be better than the usual median(),\n\nhttps://t.co/IFrzMtwZ6J"
        }
    },
    {
        "data": {
            "conversation_id": "1521949684897660934",
            "text": "When data in is binned, information is lost.\n\nIn particular, you lose the distribution of data within a bin.\n\nThe premise of median_grouped() is that some \"unbinning\" is possible if you assume the data was evenly distributed within the bin.\n\nOf course, you don't really know that.",
            "id": "1522025369003601920",
            "edit_history_tweet_ids": [
                "1522025369003601920"
            ]
        }
    },
    {
        "data": {
            "id": "1522011224929718273",
            "text": "I get what is doing but think the underlying premise is dubious.\n\nYou know there are 1,251 people in the 30-39 year old age group.\n\nNow, estimate the median of the *entire* population using the additional information of:\n\n* 497 people under 30\n* 953 people over 30\n\nAnswer: 36.82",
            "edit_history_tweet_ids": [
                "1522011224929718273"
            ],
            "conversation_id": "1521949684897660934"
        }
    },
    {
        "data": {
            "conversation_id": "1521949684897660934",
            "text": "#Python statistics people, do you ever use median_grouped()?\n\nDoes it even make sense?\n\nMy mind rebels at the concept.\n\n&gt;&gt;&gt; median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5])\n3.7\n&gt;&gt;&gt; median_grouped([1, 3, 3, 5, 7], interval=1)\n3.25\n&gt;&gt;&gt; median_grouped([1, 3, 3, 5, 7], interval=2)\n3.5",
            "id": "1521949684897660934",
            "edit_history_tweet_ids": [
                "1521949684897660934"
            ]
        }
    },
    {
        "data": {
            "id": "1521705875999707137",
            "conversation_id": "1521705875999707137",
            "edit_history_tweet_ids": [
                "1521705875999707137"
            ],
            "text": "#Python tip: bisect left and right work nicely together to locate the span of successive equal values.\n\n&gt;&gt;&gt; data = [20, 25, 30, 30, 30, 30, 40, 50]\n&gt;&gt;&gt; # Find all the 30's\n&gt;&gt;&gt; i = bisect_left(data, 30)\n&gt;&gt;&gt; j = bisect_right(data, 30)\n&gt;&gt;&gt; data[i : j]\n[30, 30, 30, 30]"
        }
    },
    {
        "data": {
            "text": "Roughly I'm looking for a definition a bit like this:\n\nA set of functions S is called _______ iff the domain and codomain are the same and \u2200f\u2208S, \u2200g\u2208S that f \u2218 g is well-defined.\n\nMaybe there is a category theory term for this (all arrows loop back or some such)?\n\n3/",
            "id": "1521362149154738176",
            "edit_history_tweet_ids": [
                "1521362149154738176"
            ],
            "conversation_id": "1521362146738778113"
        }
    },
    {
        "data": {
            "conversation_id": "1521362146738778113",
            "id": "1521362148131319808",
            "text": "Think square matrices, decorators, int-to-int functions, complex-to-complex etc:\n\nGiven these:\n\ndouble(x: int) -&gt; int\nsquare(x: int) -&gt; int\ndecrement(x: int) -&gt; int\n\nI could make these calls:\n\ndouble(square(decrement(double(x)))\nsquare(square(decrement(x)))\n\n2/",
            "edit_history_tweet_ids": [
                "1521362148131319808"
            ]
        }
    },
    {
        "data": {
            "id": "1521362146738778113",
            "text": "Okay math people or #Python people what is the technical term for a function or set of functions where the input and output signatures match so that they can be nested, chained, or composed arbitrarily?\n\nI've been using the term \"operator\" but that isn't quite right.\n\n1/",
            "edit_history_tweet_ids": [
                "1521362146738778113"
            ],
            "conversation_id": "1521362146738778113"
        }
    },
    {
        "data": {
            "conversation_id": "1517556935666589698",
            "text": "#Python typing gurus:  Is there a reason that Literal couldn't have used the curly brace set notation?\n\ndef open(filename: str, mode: {'r', 'w'}):\n    ...\n\nI like that better than:\n\ndef open(filename: str, mode: Literal['r', 'w']):\n    ...",
            "edit_history_tweet_ids": [
                "1517556935666589698"
            ],
            "id": "1517556935666589698"
        }
    },
    {
        "data": {
            "id": "1517355808136351744",
            "edit_history_tweet_ids": [
                "1517355808136351744"
            ],
            "conversation_id": "1517355807117127681",
            "text": "% python3.10 -m timeit 'x=2.5' 'x * x'\n20000000 loops, best of 5: 15.5 nsec per loop\n\n% python3.10 -m timeit 'x=2.5' 'x ** 2.0'\n10000000 loops, best of 5: 26.9 nsec per loop\n\n% python3.10 -m timeit 'x=2.5' 'x ** 2'\n10000000 loops, best of 5: 29.4 nsec per loop"
        }
    },
    {
        "data": {
            "text": "#Python factlet:  For floats, x*x is faster and more accurate than x**2.\n\n# Expect around 130 mismatches\nfor i in range(100_000):\n    x = expovariate(2**12) + expovariate(2**-12)\n    if x**2 != x*x:\n        print(x)",
            "conversation_id": "1517355807117127681",
            "edit_history_tweet_ids": [
                "1517355807117127681"
            ],
            "id": "1517355807117127681"
        }
    },
    {
        "data": {
            "text": "Whoa! \u201cTransforming Code into Beautiful, Idiomatic #Python\u201d is coming up on one million views.\n\nhttps://t.co/bMiN4PkqOW",
            "conversation_id": "1515792273518247938",
            "edit_history_tweet_ids": [
                "1515792273518247938"
            ],
            "id": "1515792273518247938"
        }
    },
    {
        "data": {
            "conversation_id": "1514290247705759745",
            "edit_history_tweet_ids": [
                "1514290247705759745"
            ],
            "text": "#Python student question: How can you replace literals with variables (not constants) in structural pattern matching?\n\nHere's one way:\n\nns = SimpleNamespace(limit=10)\n...\nns.limit += 1        # Update limit variable\n\nmatch value:\n    case ns.limit: ...   # Match current limit",
            "id": "1514290247705759745"
        }
    },
    {
        "data": {
            "text": "Today's student question:  Why doesn't #python have constants?\n\nAs in:\n\nconst pi = 3.1415926535\n\nWhat's your answer?",
            "conversation_id": "1513965648468185097",
            "edit_history_tweet_ids": [
                "1513965648468185097"
            ],
            "id": "1513965648468185097"
        }
    },
    {
        "data": {
            "conversation_id": "1513528027392655360",
            "text": "So what do *you* say in your mind (or to another dev) when reading an expression containing the walrus operator (a.k.a. an assignment expression)?\n\n3/",
            "id": "1513528029712105476",
            "edit_history_tweet_ids": [
                "1513528029712105476"
            ]
        }
    },
    {
        "data": {
            "id": "1513528028562923525",
            "edit_history_tweet_ids": [
                "1513528028562923525"
            ],
            "conversation_id": "1513528027392655360",
            "text": "The non-walrus code was wordier but had an obvious pronunciation:\n\nwhile True:\n    block = https://t.co/6b7mYPkERH(15)\n    if block == '':\n        break\n    blocks.append(block)\n\nRead as:  \"While True.  Block equals eff read fifteen. If block equals an empty string, break...\"\n\n2/"
        }
    },
    {
        "data": {
            "id": "1513528027392655360",
            "text": "Today, a learner asked an excellent #Python question, \"how do you mentally pronounce the following code?\"\n\nwhile (block := https://t.co/6b7mYPkERH(15)) != '':\n    blocks.append(block)\n\n1/",
            "edit_history_tweet_ids": [
                "1513528027392655360"
            ],
            "conversation_id": "1513528027392655360"
        }
    },
    {
        "data": {
            "conversation_id": "1512287657157607428",
            "edit_history_tweet_ids": [
                "1512287660626391045"
            ],
            "id": "1512287660626391045",
            "text": "\"Identical underlying dict\" was plausible and recently proposed as possible new semantics for dict.values().\n\nThis was a weak proposal, but it did fix the shocking lack of reflexivity in the current implementation:\n\n&gt;&gt;&gt; d = {}\n&gt;&gt;&gt; d.values() == d.values()\nFalse\n\n4/"
        }
    },
    {
        "data": {
            "conversation_id": "1512287657157607428",
            "id": "1512287659628154882",
            "text": "\"Unordered counts agree\" was plausible because keys() and items() are set like and because values don't have to be unique.\n\nd1 = dict(chris='eng', pat='sales', mark='eng')\nd2 = dict(mary='sales', sue='eng', dave='eng')\n\nBoth teams have two engineers and one sales rep.\n\n3/",
            "edit_history_tweet_ids": [
                "1512287659628154882"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1512287657157607428",
            "id": "1512287658516570112",
            "text": "\"Same order &amp; same counts\" was plausible because values() in Python 2 returned lists.\n\n# Python 2.7\n&gt;&gt;&gt; d1 = {1: 'x', 2: 'y', 3: 'y'}\n&gt;&gt;&gt; d2 = {4: 'x', 5: 'y', 6: 'y'}\n&gt;&gt;&gt; d1.values()\n['x', 'y', 'y']\n&gt;&gt;&gt; d2.values()\n['x', 'y', 'y']\n&gt;&gt;&gt; d1.values() == d2.values()\nTrue\n\n2/",
            "edit_history_tweet_ids": [
                "1512287658516570112"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1512287657157607428"
            ],
            "id": "1512287657157607428",
            "text": "Answer to the #Python quiz twitter poll: In Python 3, the expression d1.values() == d2.values() is never true.\n\nEach dict.values() method call returns a new ValuesView.\n\nThe inherited equality test only looks at object identity.\n\nHence: never equal\n\nhttps://t.co/jfn0I49DCT\n\n1/",
            "conversation_id": "1512287657157607428"
        }
    },
    {
        "data": {
            "id": "1511548621216358408",
            "text": "#Python quiz: Given dicts d1 and d2, when does d1.values() == d2.values() return True?",
            "edit_history_tweet_ids": [
                "1511548621216358408"
            ],
            "conversation_id": "1511548621216358408"
        }
    },
    {
        "data": {
            "id": "1511151184098254852",
            "edit_history_tweet_ids": [
                "1511151184098254852"
            ],
            "conversation_id": "1511151184098254852",
            "text": "#Python development survey.  Do any of you have a use case for the one argument form of super() that returns an unbound super object?\n\nWould you miss it?  Would removing it break any of your code?"
        }
    },
    {
        "data": {
            "id": "1510675860562583564",
            "text": "#Python tip:  It is sometimes handy to define:\n\n    U = frozenset().union\n\nso that you can write:\n\n    combined = U(*sets)\n\nand have it handle the edge case where the input iterable is empty.\n\nThe variable name was chosen to match the \\bigcup notation.",
            "edit_history_tweet_ids": [
                "1510675860562583564"
            ],
            "conversation_id": "1510675860562583564"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1508451119634255883"
            ],
            "id": "1508451119634255883",
            "text": "Today's lesson in tech ethics:  Don't be the one who designs the Death Star for the Emperor Palpatine.\n\nhttps://t.co/nKvBaw5VdL",
            "conversation_id": "1508451119634255883"
        }
    },
    {
        "data": {
            "text": "#Python programmers: We have a monopoly on bad variable names.\n\n@TxDOT: Hold my beer.\n\nLoop = TypeVar('Loop', bound=StraightLineConnector)\n\nhttps://t.co/s6uV5aNCFa",
            "id": "1508138571189960712",
            "edit_history_tweet_ids": [
                "1508138571189960712"
            ],
            "conversation_id": "1508138571189960712"
        }
    },
    {
        "data": {
            "conversation_id": "1507221523853152257",
            "text": "#Python itertools pop quiz:  Why is chain.from_iterable(source) preferable to chain(*source)?",
            "edit_history_tweet_ids": [
                "1507221523853152257"
            ],
            "id": "1507221523853152257"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1504266219402280965"
            ],
            "id": "1504266219402280965",
            "text": "Groups can also be given names:\n\n&gt;&gt;&gt; script = 'There are 4 lights!'\n&gt;&gt;&gt; mo =https://t.co/wyz8pxPXIU(r'[Tt]here are (?P&lt;count&gt;\\d+) lights', script)\n&gt;&gt;&gt; mo[1] == https://t.co/mviw1UXbwm(1) == mo['count'] == https://t.co/mviw1UXbwm('count')\nTrue\n&gt;&gt;&gt; mo.groupdict()\n{'count': '4'}\n\n/2",
            "conversation_id": "1504266218315919361"
        }
    },
    {
        "data": {
            "conversation_id": "1504266218315919361",
            "text": "#Python tip:  In regexes, captured subgroups are numbered starting from one.  Group zero is reserved for the entire match.  Groups can be accessed in two equivalent ways:\n\n    https://t.co/mviw1UXbwm(1) == mo[1]\n\n1/",
            "id": "1504266218315919361",
            "edit_history_tweet_ids": [
                "1504266218315919361"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1503500740752465930",
            "text": "Typo!  That should be:\n\n    z = z ** 2 + c\n\nor \n\n   z = z * z + c",
            "id": "1503552615468122112",
            "edit_history_tweet_ids": [
                "1503552615468122112"
            ]
        }
    },
    {
        "data": {
            "text": "Here is how it works:\n\nhttps://t.co/RKwpPNyCGo\n\n3/",
            "conversation_id": "1503500740752465930",
            "id": "1503500742824497152",
            "edit_history_tweet_ids": [
                "1503500742824497152"
            ]
        }
    },
    {
        "data": {
            "id": "1503500741687848965",
            "text": "Here's the full recipe from a decade ago.\n\nhttps://t.co/WszZmyVg3O\n\n2/",
            "edit_history_tweet_ids": [
                "1503500741687848965"
            ],
            "conversation_id": "1503500740752465930"
        }
    },
    {
        "data": {
            "conversation_id": "1503500740752465930",
            "text": "#Python Pi Day celebration:\n\n&gt;&gt;&gt; n = 0\n&gt;&gt;&gt; z = c = -0.75 + 1e-7j\n&gt;&gt;&gt;while abs(z) &lt; 2:\n...    n += 1\n...    z = z ** z + c\n...\n&gt;&gt;&gt; n\n31415926\n\n1/",
            "id": "1503500740752465930",
            "edit_history_tweet_ids": [
                "1503500740752465930"
            ]
        }
    },
    {
        "data": {
            "text": "Happy Pi day.\n\n&gt;&gt;&gt; 4 * sum((-1.0)**n / (2.0*n + 1.0) for n in reversed(range(100_000)))\n3.1415826535897935",
            "conversation_id": "1503453493109080065",
            "edit_history_tweet_ids": [
                "1503453493109080065"
            ],
            "id": "1503453493109080065"
        }
    },
    {
        "data": {
            "id": "1503407161011023878",
            "conversation_id": "1503407161011023878",
            "edit_history_tweet_ids": [
                "1503407161011023878"
            ],
            "text": "IRS payment tip:  The IRS cannot accept individual checks (even cashier's checks) for more than $100,000,000.\n\nFor amounts larger than this, be sure to send multiple checks.\n\nHope this tip reaches you in time. This is a common mistake ;-)\n\nFor details, see Form 7004 instructions."
        }
    },
    {
        "data": {
            "id": "1503378976559054850",
            "text": "Also, for arcane reasons, lookups in dicts() are a little faster than for defaultdicts.\n\n5/",
            "edit_history_tweet_ids": [
                "1503378976559054850"
            ],
            "conversation_id": "1502332146446479364"
        }
    },
    {
        "data": {
            "conversation_id": "1502332146446479364",
            "text": "As an added bonus, the __str__, __repr__ and pprint outputs look much nicer with a regular dict.\n\nNice looking:\n\n    {'a': 0,\n     'b': 1,\n     'c': 2}\n\nIcky looking:\n\n    defaultdict(&lt;class 'int'&gt;,\n                {'a': 0,\n                 'b': 1,\n                 'c': 2})\n\n4/",
            "edit_history_tweet_ids": [
                "1502332149982187526"
            ],
            "id": "1502332149982187526"
        }
    },
    {
        "data": {
            "conversation_id": "1502332146446479364",
            "text": "Converting back to a regular dictionary is cheap.\n\nThe hash values are reused rather than recomputed. The new dict is presized in a single step.  The key and value pointers are copied rather than inserted. The only slow part is updating all the reference counts.\n\n3/",
            "id": "1502332148757536771",
            "edit_history_tweet_ids": [
                "1502332148757536771"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1502332147604017155"
            ],
            "id": "1502332147604017155",
            "text": "# During build-up, we want the factory magic.\nd = defaultdict(list)\nfor elem in data:\n    d[feature(elem)].append(elem)\n\n# Magic is no longer useful.\nd = dict(d)\n\n# Lookups are now safe.\nprint(d[some_feature])\n\n2/",
            "conversation_id": "1502332146446479364"
        }
    },
    {
        "data": {
            "conversation_id": "1502332146446479364",
            "id": "1502332146446479364",
            "text": "#Python tip:  The default_factory feature of a defaultdict is only useful when building up a dictionary (automatically adding missing keys).\n\nHowever, that feature is a menace when doing lookups (risking accidental dict mutation).\n\nConsider converting back to a regular dict.\n\n1/",
            "edit_history_tweet_ids": [
                "1502332146446479364"
            ]
        }
    },
    {
        "data": {
            "text": "Today, the red bar derailed an otherwise successful lesson about combinatorics:\n\nfrom math import factorial, comb, perm\n\nfrom itertools import product, combinations, permutations\n\n3/",
            "edit_history_tweet_ids": [
                "1501700906424971267"
            ],
            "conversation_id": "1501700903870468099",
            "id": "1501700906424971267"
        }
    },
    {
        "data": {
            "id": "1501700905338818560",
            "text": "Reproducer:\n\n* In the shell, type \"from math\" and press return. That gets the red bar.\n\n* Then type a correct line \"from math import comb\".  The line will run but the bar remains.\n\n* Now type \"[]]\" and press return.  The old bar disappears and a new short one emerges.\n\n2/",
            "edit_history_tweet_ids": [
                "1501700905338818560"
            ],
            "conversation_id": "1501700903870468099"
        }
    },
    {
        "data": {
            "text": "OMG!  When teaching #Python to kids using IDLE, it's almost impossible to recapture their attention when a giant red bar splashes across the screen.\n\nEven when the SyntaxError is fixed on a subsequent line, the red bar remains until another SyntaxError occurs. \ud83d\ude2c\n\n1/",
            "conversation_id": "1501700903870468099",
            "id": "1501700903870468099",
            "edit_history_tweet_ids": [
                "1501700903870468099"
            ]
        }
    },
    {
        "data": {
            "id": "1501584819112890368",
            "text": "In newer Pythons, adding defaults is much easier:\n\nAccount = namedtuple('Account', ['owner_name', 'acct_num', 'balance'], defaults=[0.0])",
            "edit_history_tweet_ids": [
                "1501584819112890368"
            ],
            "conversation_id": "953173419486359552"
        }
    },
    {
        "data": {
            "conversation_id": "1500160801130389508",
            "text": "When updating an existing key in a #Python dict:\n* the old key is kept\n* the value is replaced\n* order doesn't change\n\n&gt;&gt;&gt; d = {1: 'a', 2: 'b'}\n&gt;&gt;&gt; d[1.0] = 'c'\n&gt;&gt;&gt; d\n{1: 'c', 2: 'b'}\n     ^-- new val\n ^------ old key\n\nThis is the way!",
            "edit_history_tweet_ids": [
                "1500160801130389508"
            ],
            "id": "1500160801130389508"
        }
    },
    {
        "data": {
            "id": "1498505641685618694",
            "conversation_id": "1498505639651332101",
            "edit_history_tweet_ids": [
                "1498505641685618694"
            ],
            "text": "While I'm on the subject of completely sensible yet completely opposite conventions:\n\nIn English, the knob labeled C has Cold water.\n\nIn Spanish, the knob labeled C has aqua Caliente (hot water).\n\nI'm wonder how often this has resulted in unexpected surprises."
        }
    },
    {
        "data": {
            "text": "I like the Jupyter convention a little better because A comes before B in the alphabet.\n\nHowever, grep significantly predates Jupyter.\n\nIt would have been nice if the conventions matched.",
            "id": "1498505640649629697",
            "edit_history_tweet_ids": [
                "1498505640649629697"
            ],
            "conversation_id": "1498505639651332101"
        }
    },
    {
        "data": {
            "id": "1498505639651332101",
            "edit_history_tweet_ids": [
                "1498505639651332101"
            ],
            "conversation_id": "1498505639651332101",
            "text": "#Python dyslexia:\n\nIn Jupyter notebooks, \ud83c\udd30 stands for insert Above and \ud83c\udd31 for insert Below.\n\nWith grep, -A stands for After context and -B stands for Before content."
        }
    },
    {
        "data": {
            "text": "\"Liskov violations\" are everywhere.\n\n* A Penguin is a Bird that swims but doesn't fly.\n* A Bat is a Mammal that flies.\n* A Dolphin is a Mammal that swims.\n* Flying fish swim and fly.\n* A Dict is an Object that isn't hashable.",
            "edit_history_tweet_ids": [
                "1498135234277167109"
            ],
            "conversation_id": "1498135234277167109",
            "id": "1498135234277167109"
        }
    },
    {
        "data": {
            "conversation_id": "1496385245859528704",
            "edit_history_tweet_ids": [
                "1496385247084175361"
            ],
            "text": "The solution to the chicken and egg problem is that both type() and object() came into being at the same time, neither begat the other, yet they are both inextricably linked to one another in an infinite circular reference. \u262f\n\n&gt;&gt;&gt; object.__class__.__mro__[-1] is object\nTrue",
            "id": "1496385247084175361"
        }
    },
    {
        "data": {
            "id": "1496385245859528704",
            "edit_history_tweet_ids": [
                "1496385245859528704"
            ],
            "conversation_id": "1496385245859528704",
            "text": "#Python strange loop:  I like to think of classes as inheriting from object() and metaclasses as inheriting from type(). So it messes with my worldview to know that type inherits from object.\n\n&gt;&gt;&gt; object.__class__\n&lt;class 'type'&gt;\n&gt;&gt;&gt; type.__mro__\n(&lt;class 'type'&gt;, &lt;class 'object'&gt;)"
        }
    },
    {
        "data": {
            "conversation_id": "1495840358869176322",
            "edit_history_tweet_ids": [
                "1495840361066938378"
            ],
            "id": "1495840361066938378",
            "text": "Here's a fun talk about the basic dance moves with super():\n\nhttps://t.co/VHYV0wcI5r"
        }
    },
    {
        "data": {
            "conversation_id": "1495840358869176322",
            "text": "Learning to use super() well is another story.\n\nhttps://t.co/vV0CaKvyX3",
            "edit_history_tweet_ids": [
                "1495840359880003593"
            ],
            "id": "1495840359880003593"
        }
    },
    {
        "data": {
            "id": "1495840358869176322",
            "conversation_id": "1495840358869176322",
            "edit_history_tweet_ids": [
                "1495840358869176322"
            ],
            "text": "Under the hood, #Python's super() is remarkably simple.\n\nhttps://t.co/7wvztwOfiy"
        }
    },
    {
        "data": {
            "conversation_id": "1495444804959940616",
            "text": "For len(d), I'm thinking that dict_length() needs to be moved from dict_as_mapping to dict_as_sequence..\n\nThe latter is given preference in PyObject_Size().",
            "id": "1495474663161532419",
            "edit_history_tweet_ids": [
                "1495474663161532419"
            ]
        }
    },
    {
        "data": {
            "id": "1495448124860637185",
            "text": "Go figure.  I can beat an exact dict just by subclassing dict.\n\nSurreal!",
            "edit_history_tweet_ids": [
                "1495448124860637185"
            ],
            "conversation_id": "1495444804959940616"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1495448123983990787"
            ],
            "id": "1495448123983990787",
            "text": "I like to test Python's speed-up by benchmarking the pure Python OrderedDict versus a regular dict in C.\n\nIteration is now only 3.3x slower. Lookups are only 1.5x slower. Store new/existing keys is 5.9/1.8 slower.\n\nBut somehow, len() and get() are faster!  How is this possible?",
            "conversation_id": "1495444804959940616"
        }
    },
    {
        "data": {
            "conversation_id": "1495444804959940616",
            "text": "Running #Python's timeit can cause you to question the nature your reality.\n\npython3.10 -m timeit -s 'd=dict()' 'len(d)'\n10000000 loops, best of 5: 21.4 nsec per loop\n\npython3.10 -m timeit -s 'class D(dict): pass' -s 'd=D()' 'len(d)'\n10000000 loops, best of 5: 20.1 nsec per loop",
            "edit_history_tweet_ids": [
                "1495444804959940616"
            ],
            "id": "1495444804959940616"
        }
    },
    {
        "data": {
            "text": "4/\n\nNotice that the mechanism is completely independent from __new__ or __init__.\n\nThe __match_args__ tuple isn't tied to the actual constructor signature.\n\nYou probably *should* make the two correspond, but it certainly isn't required.",
            "conversation_id": "1494925658362986498",
            "id": "1495039262164668416",
            "edit_history_tweet_ids": [
                "1495039262164668416"
            ]
        }
    },
    {
        "data": {
            "text": "class G:\n    'Getattr version'\n    __match_args__ = ('a',)\n    def __getattr__(self, attr):\n        return 30 if attr == 'a' else 0\n\n&gt;&gt;&gt; match G():\n...     case G(30):\n...         print('hit')\n...\nhit",
            "conversation_id": "1494925658362986498",
            "id": "1495031796278386691",
            "edit_history_tweet_ids": [
                "1495031796278386691"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1494925658362986498",
            "id": "1495031347198500865",
            "text": "class D:\n    'Descriptor'\n    __match_args__ = ('a',)\n    \n@property\n\n    def a(self):\n        return 20\n\n&gt;&gt;&gt; match D():\n...     case D(20):\n...         print('hit')\n...\nhit\n\n3/",
            "edit_history_tweet_ids": [
                "1495031347198500865"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1494925658362986498",
            "text": "class V:\n    'Virtual attribute'\n    __match_args__ = ('a',)\n    def __getattribute__(self, attr):\n        return 10 if attr == 'a' else 0\n\n&gt;&gt;&gt; match V():\n...     case V(10):\n...         print('hit')\n...\nhit\n\n2/",
            "id": "1494925659327680512",
            "edit_history_tweet_ids": [
                "1494925659327680512"
            ]
        }
    },
    {
        "data": {
            "id": "1494925658362986498",
            "edit_history_tweet_ids": [
                "1494925658362986498"
            ],
            "conversation_id": "1494925658362986498",
            "text": "#Python structural pattern matching factlet:\n\nClass patterns with positional arguments match by attribute lookup on the names in __match_args__.\n\nAccordingly, they match normal attributes, descriptors, and virtual attributes implemented with __getattribute__ or __getattr__.\n\n1/"
        }
    },
    {
        "data": {
            "conversation_id": "1492897892121591818",
            "text": "If you provide a custom __repr__, it flows through to str() and format().\n\nIf you provide a custom __str__, it flows only to format().\n\nIf you provide a custom __format__, it doesn't affect str() or repr().\n\nOtherwise, you get the default:\n'&lt;__main__.A object at 0x10a070ca0&gt;'\n\n2/",
            "edit_history_tweet_ids": [
                "1492897893308669957"
            ],
            "id": "1492897893308669957"
        }
    },
    {
        "data": {
            "text": "#Python factlets:\n* f-strings call __format__ by default\n* object.__format__ delegates to object.__str__\n* object.__str__ delegates to object object.__repr__\n* object.__repr__ gives \"&lt;%s object at %p&gt;\" for the type name and object id.\n\n1/",
            "conversation_id": "1492897892121591818",
            "id": "1492897892121591818",
            "edit_history_tweet_ids": [
                "1492897892121591818"
            ]
        }
    },
    {
        "data": {
            "id": "1492274322899152897",
            "conversation_id": "1492007450224046250",
            "edit_history_tweet_ids": [
                "1492274322899152897"
            ],
            "text": "The adjacent state heatmap color differences seem to spread across whole states, so this don't seem to just be an edge effect (mountains, rivers, etc), especially when a whole state like Tennessee is uniformly darker across all sides and the middle."
        }
    },
    {
        "data": {
            "conversation_id": "1492007450224046250",
            "text": "FWIW, the caption says, \"Average Daily Cases Per 100,000 People in the Last Week\".\n\nThat rules out daily collection fluctuations (i.e. not reporting on weekends) and population density variations (it is per 100,000 people).",
            "id": "1492273671586598912",
            "edit_history_tweet_ids": [
                "1492273671586598912"
            ]
        }
    },
    {
        "data": {
            "id": "1492007450224046250",
            "conversation_id": "1492007450224046250",
            "edit_history_tweet_ids": [
                "1492007450224046250"
            ],
            "text": "Data science question:  Why are some states clearly outlined by the Covid heatmap?\n\nI'm not talking about the white outlines. The actual covid rates show state boundaries. I wouldn't have expected this.\n\nhttps://t.co/mB0b1ArOiX"
        }
    },
    {
        "data": {
            "text": "References:\n\nhttps://t.co/DdGd2lJ8Oa\n\nhttps://t.co/pi4JlePk3E\n\n8/",
            "edit_history_tweet_ids": [
                "1491189199252639746"
            ],
            "conversation_id": "1491187805636407298",
            "id": "1491189199252639746"
        }
    },
    {
        "data": {
            "conversation_id": "1491187805636407298",
            "id": "1491187813311987712",
            "text": "Here's what we're leaving behind:\n\nSelfType = TypeVar('SelfType', bound='P')\n\nclass P:\n    \n    @classmethod\n    def from_half(cls: Type[SelfType], x: int) -&gt; SelfType:\n        return cls(x * 2)\n\nGood riddance.\n\n7/",
            "edit_history_tweet_ids": [
                "1491187813311987712"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1491187805636407298",
            "id": "1491187812112437248",
            "text": "It can also be nested in other types:\n\ndef returns_list(self) -&gt; list[Self]:\n    ...\n\n6/",
            "edit_history_tweet_ids": [
                "1491187812112437248"
            ]
        }
    },
    {
        "data": {
            "text": "The __new__ method benefits as well:\n\ndef __new__(cls, value: int) -&gt; Self:\n    ...\n\n5/",
            "conversation_id": "1491187805636407298",
            "id": "1491187810929635328",
            "edit_history_tweet_ids": [
                "1491187810929635328"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1491187805636407298",
            "id": "1491187809658765313",
            "text": "Classmethods are dramatically easier to annotate:\n\n@classmethod\ndef from_config(cls, config: dict[str, float]) -&gt; Self:\n    return cls(config['scale'])\n\n4/",
            "edit_history_tweet_ids": [
                "1491187809658765313"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1491187805636407298",
            "id": "1491187808442421253",
            "text": "The __enter__ method for context managers is sometimes a beneficiary:\n\ndef __enter__(self) -&gt; Self:\n    return self\n\n3/",
            "edit_history_tweet_ids": [
                "1491187808442421253"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1491187805636407298",
            "text": "This works great for methods that return self.\n\ndef set_scale(self, scale: float) -&gt; Self:\n        self.scale = scale\n        return self\n\n2/",
            "edit_history_tweet_ids": [
                "1491187807154761728"
            ],
            "id": "1491187807154761728"
        }
    },
    {
        "data": {
            "text": "#Python news:  It was always awkward to write a type annotation for methods that returned self (an instance of the current class). As of yesterday, typing.Self was added to make this much easier and more readable.\n\nIt is a big win.\n\n1/",
            "conversation_id": "1491187805636407298",
            "id": "1491187805636407298",
            "edit_history_tweet_ids": [
                "1491187805636407298"
            ]
        }
    },
    {
        "data": {
            "text": "One possibility is to have aliased it to \"until\".\n\nI'm looking for a word that communicates that the exception is expected and that it is how the loop ends.",
            "id": "1490929563509325824",
            "edit_history_tweet_ids": [
                "1490929563509325824"
            ],
            "conversation_id": "1490749277240537089"
        }
    },
    {
        "data": {
            "conversation_id": "1490749277240537089",
            "text": "Aliasing \"suppress\" to \"catch\" reads nicely in this context (no pun intended), but it still falls short of being exactly the right word.\n\nWhat is \"le mot juste\"?\n\nWhat would you have called suppess() aka ignore() aka catch()?\n\n3/3",
            "id": "1490749279400570882",
            "edit_history_tweet_ids": [
                "1490749279400570882"
            ]
        }
    },
    {
        "data": {
            "text": "Yesterday, I wrote this:\n\nfrom contextlib import suppress as catch\n\ndef runner(listen, respond):\n with catch(StopRunning):\n   while True:\n     task = listen()\n     result = task()\n     respond(result)\n\n2/3",
            "edit_history_tweet_ids": [
                "1490749278352031744"
            ],
            "conversation_id": "1490749277240537089",
            "id": "1490749278352031744"
        }
    },
    {
        "data": {
            "text": "#Python 3.4 added the contextlib.suppress() as an elegant way to write the pattern:\n \n  try:\n      &lt;suite&gt;\n  except SomeException:\n      pass\n\nOriginally, I called it ignore() rather than suppress(),\nbut it is still not clear what the right name should have been.\n\n1/3",
            "edit_history_tweet_ids": [
                "1490749277240537089"
            ],
            "conversation_id": "1490749277240537089",
            "id": "1490749277240537089"
        }
    },
    {
        "data": {
            "conversation_id": "1490377975749128198",
            "id": "1490377975749128198",
            "text": "In older movies, \"data\" is often used as an adjective to make something sound more technical.\n\nFrom Runaway (1984):\n- I was gonna be a data programmer.\n- I need data files.",
            "edit_history_tweet_ids": [
                "1490377975749128198"
            ]
        }
    },
    {
        "data": {
            "text": "10 ** 32 is a precomputed constant\n10 ** 33 is a runtime computation\n\n1e308 is an actual constant\n1e-308 is also an actual constant",
            "edit_history_tweet_ids": [
                "1490017501652164608"
            ],
            "conversation_id": "1490011194228367364",
            "id": "1490017501652164608"
        }
    },
    {
        "data": {
            "conversation_id": "1490011194228367364",
            "id": "1490011194228367364",
            "text": "#Python factlet:   10**6 is an int and 1E6 is a float.",
            "edit_history_tweet_ids": [
                "1490011194228367364"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1489044756248334338",
            "text": "This isn't just a programming issue. It shows up in the real world.\n\nVice-president:  Give me a forecast every Monday morning.  (Assumes you can easily cut and paste into Excel)\n\nVice-president:  Hire McKinsey to do MBA work every week. (Significant difference in cost.)",
            "id": "1489044757368250375",
            "edit_history_tweet_ids": [
                "1489044757368250375"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1489044756248334338",
            "text": "#Python tip:  Because properties look like attribute lookups, it is implied that they are cheap.  If that is not the case, use a regular method instead.\n\nCompare:\n\n    score = text.originality\n\nversus\n\n    score = text.count_related_articles()",
            "edit_history_tweet_ids": [
                "1489044756248334338"
            ],
            "id": "1489044756248334338"
        }
    },
    {
        "data": {
            "conversation_id": "1488173548418080770",
            "text": "Accordingly, the Counter docs don't feed you a rationalization.  They give reality:\n\nA Counter is a dict subclass where missing keys return zero.  It is unrestricted in what kind of values are stored.  It also offers methods supporting a variety of use cases.",
            "id": "1488189596357828611",
            "edit_history_tweet_ids": [
                "1488189596357828611"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1488173548418080770",
            "id": "1488189595405766669",
            "text": "Getting back to Parnas and Clements though, it is clear that Counter's are rationalization challenged.\n\nWe can't just say, \"it is a multiset\" or \"it is a sparse array\".  Even the loose and ambiguous \"it is a counting dictionary\" misses the gestalt.",
            "edit_history_tweet_ids": [
                "1488189595405766669"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1488173548418080770",
            "text": "Counter's are so flexible that there has been a need a draw a line and not have it grow methods supporting sparse array operations, histogram operations, or probability mass functions.",
            "edit_history_tweet_ids": [
                "1488189594491408390"
            ],
            "id": "1488189594491408390"
        }
    },
    {
        "data": {
            "conversation_id": "1488173548418080770",
            "edit_history_tweet_ids": [
                "1488189593467904002"
            ],
            "text": "The hard requirement to be an unrestricted dict subclass pushed Counter is a different direction.\n\nMostly, it worked out well. Mostly, substitutable for dicts. Reasonably fast. Flexible enough to support a huge variety of use cases.\n\nThe main surprise is the lack of restrictions.",
            "id": "1488189593467904002"
        }
    },
    {
        "data": {
            "id": "1488189592532619271",
            "conversation_id": "1488173548418080770",
            "edit_history_tweet_ids": [
                "1488189592532619271"
            ],
            "text": "Here is what Counter originally aspired to be:\n\nhttps://t.co/nxLeygMigA"
        }
    },
    {
        "data": {
            "text": "However, a hard gatekeeper requirement was that Counter be a dict subclass, no more restrictive than a regular dict, but simplifying the common pattern:  d[x] = d.get(x, 0) + 1.\n\nGiven this seed, the rest is inevitable:\n\nclass Counter(dict):\n  def __missing__(self):\n    return 0",
            "id": "1488189591509159950",
            "edit_history_tweet_ids": [
                "1488189591509159950"
            ],
            "conversation_id": "1488173548418080770"
        }
    },
    {
        "data": {
            "id": "1488189590561304576",
            "edit_history_tweet_ids": [
                "1488189590561304576"
            ],
            "conversation_id": "1488173548418080770",
            "text": "Our minds are use case driven. Typically, we want to think of a Counter as a self contained multiset with only positive integer counts.\n\nInspired by success with Smalltalk's Bag class, that was my aspiration."
        }
    },
    {
        "data": {
            "conversation_id": "1488173548418080770",
            "text": "For collections.Counter, the rationalization is tenuous and only barely holds together:\n\nA Counter is a dictionary that treats missing keys as defaulting to zero. It has extra methods to support use cases as bags, counters, or multisets.",
            "edit_history_tweet_ids": [
                "1488181434833641472"
            ],
            "id": "1488181434833641472"
        }
    },
    {
        "data": {
            "text": "Continued:\n\nAnalogous reasoning applies to software. Those who read the software documentation want to understand the programs, not to relive their discovery. By presenting rationalized documentation, we provide what they need.",
            "edit_history_tweet_ids": [
                "1488177949140570133"
            ],
            "conversation_id": "1488173548418080770",
            "id": "1488177949140570133"
        }
    },
    {
        "data": {
            "conversation_id": "1488173548418080770",
            "id": "1488177948070924295",
            "text": "Another gem:\n\nEven mathematics, the discipline that many of us regard as the most rational of all, follows this procedure. Mathematicians diligently polish their proofs, usually presenting a proof very different from the first one they discovered.",
            "edit_history_tweet_ids": [
                "1488177948070924295"
            ]
        }
    },
    {
        "data": {
            "text": "Source:\n\nhttps://t.co/bFOjSZ5WNV",
            "edit_history_tweet_ids": [
                "1488173550154432514"
            ],
            "conversation_id": "1488173548418080770",
            "id": "1488173550154432514"
        }
    },
    {
        "data": {
            "text": "This thought is equally interesting if you switch the judgment from \"burdened\" to \"empowered\".\n\nEither way, the core idea remains than programs have a human dimension that transcends requirements and \"rational design\".",
            "id": "1488173549269532673",
            "edit_history_tweet_ids": [
                "1488173549269532673"
            ],
            "conversation_id": "1488173548418080770"
        }
    },
    {
        "data": {
            "text": "We are often burdened by preconceived ideas, ideas that we invented, acquired on related projects, or heard about in class. Sometimes we undertake a project in order to try out a favorite idea. Such ideas may not be derived from our requirements by a rational process -\u2014  Parnas",
            "conversation_id": "1488173548418080770",
            "edit_history_tweet_ids": [
                "1488173548418080770"
            ],
            "id": "1488173548418080770"
        }
    },
    {
        "data": {
            "conversation_id": "1487878096304943108",
            "id": "1487878965775802369",
            "text": "https://t.co/sd8T6frysP",
            "edit_history_tweet_ids": [
                "1487878965775802369"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1487878096304943108",
            "id": "1487878096304943108",
            "text": "Sign of the times:  Today I was writing about multiset equality and inclusion operations.   Twice, it came out of my fingers as multiset equity and inclusion. \ud83e\udd14\n\n\u2200x \u2208 (M\u2081 \u222a M\u2082):  M\u2081[x] = M\u2082[x]    # Equality\n\u2200x \u2208 (M\u2081 \u222a M\u2082):  M\u2081[x] &lt;= M\u2082[x]   # Inclusion",
            "edit_history_tweet_ids": [
                "1487878096304943108"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1486863239283494915",
            "edit_history_tweet_ids": [
                "1486863239283494915"
            ],
            "text": "#Python functional programming tip:  Use islice() to skip past headers in data files.\n\n&gt;&gt;&gt; with open('austin_weather_2_2021.txt') as f:\n...     mean(map(int, islice(f, 3, None)))\n...\n38.107\n\nAustin, TX\nFeb 2021\n-----------\n41\n40\n45\n55\n44\n48\n40\n51\n46\n37\n31\n29\n26\n13\n 8\n 7\n24\n24\n \u2026",
            "id": "1486863239283494915"
        }
    },
    {
        "data": {
            "id": "1485763859680055297",
            "text": "#Python technique tip:\n\ndef next_power_of_two(n: int) -&gt; int:\n    ' Return 2\u2071 such than 2\u2071\u207b\u00b9 \u2264 n &lt; 2\u2071. '\n    return 1 &lt;&lt; n.bit_length()\n\n4 \u27f6 8\n5 \u27f6 8\n6 \u27f6 8\n7 \u27f6 8\n8 \u27f6 16\n9 \u27f6 16\n10 \u27f6 16\n11 \u27f6 16\n12 \u27f6 16\n13 \u27f6 16\n14 \u27f6 16\n15 \u27f6 16\n16 \u27f6 32",
            "edit_history_tweet_ids": [
                "1485763859680055297"
            ],
            "conversation_id": "1485763859680055297"
        }
    },
    {
        "data": {
            "text": "There is also this bit flipping hack:\n\nnot (x - 1) &amp; x",
            "conversation_id": "1483948152906522625",
            "edit_history_tweet_ids": [
                "1483948799974383630"
            ],
            "id": "1483948799974383630"
        }
    },
    {
        "data": {
            "conversation_id": "1483948152906522625",
            "text": "#Python technique tip:\n\ndef is_power_of_two(x: int) -&gt; bool:\n    return x &gt; 0 and x.bit_count() == 1",
            "edit_history_tweet_ids": [
                "1483948152906522625"
            ],
            "id": "1483948152906522625"
        }
    },
    {
        "data": {
            "conversation_id": "1482808337808904198",
            "id": "1482808340098990081",
            "text": "Dataclasses are in more hazy position.\n\nAdding a field will break any code using astuple(), but the structural pattern matching will still work as long (though field order still matters for positional matches).\n\n3/",
            "edit_history_tweet_ids": [
                "1482808340098990081"
            ]
        }
    },
    {
        "data": {
            "id": "1482808338987507714",
            "text": "A case like {'city': city, 'state': 'texas', size: size} can match a large dictionary.\n\nHowever, a case like (city, 'texas', size) can only match a three tuple.\n\n2/",
            "edit_history_tweet_ids": [
                "1482808338987507714"
            ],
            "conversation_id": "1482808337808904198"
        }
    },
    {
        "data": {
            "id": "1482808337808904198",
            "text": "For me, #Python structural pattern matching clarified and codified an essential point about data structures.\n\nGenerally, you can add new fields to a dict without breaking consumer code.  But with tuples, changing the size breaks unpacking code.\n\n1/",
            "edit_history_tweet_ids": [
                "1482808337808904198"
            ],
            "conversation_id": "1482808337808904198"
        }
    },
    {
        "data": {
            "conversation_id": "1482225220475883522",
            "text": "I'm not sure what to say to defuse this thread.\n\nBlack is good product. IPython is a good tool. The people involved are good developers.\n\nIdeally, let's focus on the problem rather the people. The main thread identifies five specific usability problems. That's what we care about.",
            "edit_history_tweet_ids": [
                "1482537473368637446"
            ],
            "id": "1482537473368637446"
        }
    },
    {
        "data": {
            "conversation_id": "1482225220475883522",
            "edit_history_tweet_ids": [
                "1482404874990104578"
            ],
            "id": "1482404874990104578",
            "text": "Note that #SymPy does the right thing here:\n\n&gt;&gt;&gt; from sympy import var\n&gt;&gt;&gt; var('x')\nx\n&gt;&gt;&gt; ((3*x + 5) * (2*x - 4)).expand()\n6*x**2 - 2*x - 20"
        }
    },
    {
        "data": {
            "id": "1482227947843031043",
            "text": "It wasn't long ago that IDLE became unusable for teaching.  And now IPython decides to rewrite my inputs so that students never see what I actually typed.\n\nArgh!!!",
            "edit_history_tweet_ids": [
                "1482227947843031043"
            ],
            "conversation_id": "1482225220475883522"
        }
    },
    {
        "data": {
            "conversation_id": "1482225220475883522",
            "text": "Even if you usually like how Black formats your scripts and modules, why would you ever do this line by line in a CLI?",
            "edit_history_tweet_ids": [
                "1482226991269089280"
            ],
            "id": "1482226991269089280"
        }
    },
    {
        "data": {
            "conversation_id": "1482225220475883522",
            "text": "Yes, this can be turned off, but you have to get a whole classroom of mixed Windows, Mac, and Linux users to monkey through the steps to get back to a normal environment where you can see what you typed into the computer rather than what it wanted you to type.",
            "edit_history_tweet_ids": [
                "1482225226998063107"
            ],
            "id": "1482225226998063107"
        }
    },
    {
        "data": {
            "conversation_id": "1482225220475883522",
            "id": "1482225225760661509",
            "text": "It's no longer possible to show students how to use the semicolon to separate statements:\n\n&gt;&gt;&gt; time.sleep(5); print(\"Done\")\n\nIn #IPython, this gets rewritten to:\n\nIn [15]: sleep(5)\n    ...: print(\"Done\")\nDone",
            "edit_history_tweet_ids": [
                "1482225225760661509"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1482225224607277060"
            ],
            "id": "1482225224607277060",
            "text": "For teaching purposes, it is especially annoying to have in-line comments smushed to two spaces after the code ends. And more so, when it splits your input lines.\n\nif n == 0: return 0   # 1st known case\nif n == 1: return 1     # 2nd known case\nreturn n * fact(n-1)   # Recurse",
            "conversation_id": "1482225220475883522"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1482225223629950978"
            ],
            "id": "1482225223629950978",
            "text": "Black's quotation rewrites are especially distracting in a REPL where it clearly conflicts the language's internal preferences:\n\nIn [11]: {\"x\": 10}\nOut[11]: {'x': 10}",
            "conversation_id": "1482225220475883522"
        }
    },
    {
        "data": {
            "id": "1482225222677848067",
            "text": "When doing math, you improve readability by grouping your terms as shown in PEP 8:\n\n3*x**2 - 5*x + 10\n\nHowever, the new #Ipython CLI immediately expands it to:\n\n3 * x ** 2 - 5 * x + 10",
            "edit_history_tweet_ids": [
                "1482225222677848067"
            ],
            "conversation_id": "1482225220475883522"
        }
    },
    {
        "data": {
            "id": "1482225221432131585",
            "text": "In a #Python course, if you want to demonstrate that print('hello') and print(\"hello\") are the same, then too bad.  The CLI rewrites both to use double quotes and the students can't see what you were demonstrating.",
            "edit_history_tweet_ids": [
                "1482225221432131585"
            ],
            "conversation_id": "1482225220475883522"
        }
    },
    {
        "data": {
            "text": "Argh!  Who thought Black should be automatically applied to lines in the IPython CLI?\n\nThe makes it less useful for education purposes, less useful for interactive math, and annoying when it rewrites your input across multiple lines.",
            "conversation_id": "1482225220475883522",
            "id": "1482225220475883522",
            "edit_history_tweet_ids": [
                "1482225220475883522"
            ]
        }
    },
    {
        "data": {
            "id": "1481723600797585409",
            "text": "The last version could be made purely functional and point free, but it is less readable and likely slower.\n\n&gt;&gt;&gt; from operator import itemgetter, sub\n&gt;&gt;&gt; swap = itemgetter(1, 0)\n&gt;&gt;&gt; list(starmap(sub, map(swap, pairwise(cumulative))))\n[11, 13, 15, 18, 9, 6, 30]",
            "edit_history_tweet_ids": [
                "1481723600797585409"
            ],
            "conversation_id": "1481381046520360965"
        }
    },
    {
        "data": {
            "conversation_id": "1481381046520360965",
            "text": "#Python tip:  The pairwise() itertool can undo an accumulation.\n\n&gt;&gt;&gt; daily = [11, 13, 15, 18, 9, 6, 30]\n\n&gt;&gt;&gt; (cumulative := list(accumulate(daily, initial=534)))\n[534, 545, 558, 573, 591, 600, 606, 636]\n\n&gt;&gt;&gt; [q - p for p, q in pairwise(cumulative)]\n[11, 13, 15, 18, 9, 6, 30]",
            "id": "1481381046520360965",
            "edit_history_tweet_ids": [
                "1481381046520360965"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1480630939290066946",
            "text": "Human beings with time on their hands can be amazingly creative. https://t.co/SZK2mGu2dY",
            "edit_history_tweet_ids": [
                "1480630939290066946"
            ],
            "id": "1480630939290066946"
        }
    },
    {
        "data": {
            "conversation_id": "1480578691386290176",
            "text": "DeMorgan's laws generalize to cover multiple variables:\n\n    \u00ac(P \u2228 Q \u2228 R)  \u27fa  (\u00acP) \u2227 (\u00acQ) \u2227 (\u00acR)\n    \u00ac(P \u2227 Q \u2227 Q)  \u27fa  (\u00acP) \u2228 (\u00acQ) \u2228 (\u00acR)",
            "id": "1480605073898041346",
            "edit_history_tweet_ids": [
                "1480605073898041346"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1480578691386290176",
            "text": "No one doesn't do well with single negatives rather than double negatives. \ud83d\ude09\n\nLogically, it's either raining or it's not raining.  It's not not raining; therefore, it's raining.",
            "edit_history_tweet_ids": [
                "1480578693470818304"
            ],
            "id": "1480578693470818304"
        }
    },
    {
        "data": {
            "conversation_id": "1480578691386290176",
            "id": "1480578692506173450",
            "text": "Also consider inverting conditionals to eliminate a \"not\":\n\n- status = 'standby' if not test(x) else 'ready'\n+ status = 'ready' if test(x) else 'standby'",
            "edit_history_tweet_ids": [
                "1480578692506173450"
            ]
        }
    },
    {
        "data": {
            "id": "1480578691386290176",
            "edit_history_tweet_ids": [
                "1480578691386290176"
            ],
            "text": "De Morgan's laws can be a #Python programmer's best friend.\n\n    \u00ac(P \u2228 Q)  \u27fa  (\u00acP) \u2227 (\u00acQ)\n    \u00ac(P \u2227 Q)  \u27fa  (\u00acP) \u2228 (\u00acQ)\n\n- if not((word in blocked) or (word not in encougaged)):\n+ if (word not in blocked) and (word in encougaged)",
            "conversation_id": "1480578691386290176"
        }
    },
    {
        "data": {
            "id": "1479506242817175553",
            "edit_history_tweet_ids": [
                "1479506242817175553"
            ],
            "conversation_id": "1479506242817175553",
            "text": "#Python code review pop quiz:  What does this code do?\n\nassert(0 &lt;= i &lt; len(s), 'index out of bounds')"
        }
    },
    {
        "data": {
            "conversation_id": "1478139464350412802",
            "edit_history_tweet_ids": [
                "1478139467651244036"
            ],
            "id": "1478139467651244036",
            "text": "Regular dicts already have d.popitem() which does the same as od.popitem(True) for OrderedDicts.\n\nOrdered dicts have an od.move_to_end(key, 0) that moves entries to the beginning.  There is no fast, clean equivalent for regular dicts.\n\n3/"
        }
    },
    {
        "data": {
            "id": "1478139465851973637",
            "text": "These two methods are all you need to efficiently implement your own LRU cache variants:\n\n# Cache miss:  Store new entry and remove oldest\nd[args] = func(*args)\nif len(d) &gt; maxsize:\n    d.popitem(0)\n\n# Cache hit:  Refresh position \nd.move_to_end(args)\n\nhttps://t.co/ptZfq1ZOO7\n\n2/",
            "edit_history_tweet_ids": [
                "1478139465851973637"
            ],
            "conversation_id": "1478139464350412802"
        }
    },
    {
        "data": {
            "id": "1478139464350412802",
            "edit_history_tweet_ids": [
                "1478139464350412802"
            ],
            "conversation_id": "1478139464350412802",
            "text": "Regular #python dicts can efficiently emulate methods exclusive to OrderedDict:\n\n# Remove oldest\n# od.popitem(0)\n&gt;&gt;&gt; d = dict(a=1, b=2, c=3)\n&gt;&gt;&gt; del d[next(iter(d))]\n&gt;&gt;&gt; d\n{'b': 2, 'c': 3}\n\n# Refresh position\n# od.move_to_end('b')\n&gt;&gt;&gt; d['b'] = d.pop('b')\n&gt;&gt;&gt; d\n{'c':3, 'b': 2}\n\n1/"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1477343405801832449"
            ],
            "conversation_id": "1477343405801832449",
            "id": "1477343405801832449",
            "text": "Relatively unknown #Python function that everyone needs sooner or later:  textwrap.dedent().\n\nThis gem removes the common leading whitespace from indented multiline strings."
        }
    },
    {
        "data": {
            "text": "It's not just individuals who succumb to self serving equivocations and prevarications.\n\nToday, the #CDC shortened the #Covid isolation period for health workers.\n\nIs this new science that only applies to them or do they just need these folks back at work?",
            "conversation_id": "1474180653801377794",
            "edit_history_tweet_ids": [
                "1474222559872765958"
            ],
            "id": "1474222559872765958"
        }
    },
    {
        "data": {
            "id": "1474206006942920705",
            "edit_history_tweet_ids": [
                "1474206006942920705"
            ],
            "text": "Of the tens of thousands who die from Covid over the next few months, I wonder how many of them will have been refused early and effective treatment because their BMI wasn't quite big enough.",
            "conversation_id": "1474200986851835906"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1474204552505147394"
            ],
            "text": "In a case near and dear to me, the doctor was ready to give a therapy but couldn't find a matching checkbox.\n\nShe said, your BMI is 22 but the cutoff is 25.\n\nSo if you overeat during the holidays, it will help your case. Thanks for nothing @US_FDA.",
            "conversation_id": "1474200986851835906",
            "id": "1474204552505147394"
        }
    },
    {
        "data": {
            "conversation_id": "1474200986851835906",
            "id": "1474200989775192064",
            "text": "We're two years into the pandemic.  Science has given us great tools.  But all you get is a recommendation to stay hydrated.  No proven therapies for you!",
            "edit_history_tweet_ids": [
                "1474200989775192064"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1474200988718272513"
            ],
            "conversation_id": "1474200986851835906",
            "id": "1474200988718272513",
            "text": "So, if you test positive, the doctor will pretty much tell you, \"stay home, isolate, and call us back if you're pulse-ox drops to 92\".\n\nThen, they will tell you, \"Hmm, you would have been so much better off if we had treated you early.  Sorry.\""
        }
    },
    {
        "data": {
            "id": "1474200987812335621",
            "text": "BTW, this might make sense if it were a rationing policy (allocating resources where there are the most effective), but that's not the story.\n\nEven if the supply were plentiful, the FDA approvals are only for those at high risk.\n\nWe have treatments but won't give them to you.",
            "edit_history_tweet_ids": [
                "1474200987812335621"
            ],
            "conversation_id": "1474200986851835906"
        }
    },
    {
        "data": {
            "id": "1474200986851835906",
            "edit_history_tweet_ids": [
                "1474200986851835906"
            ],
            "text": "#Covid catch-22:   Antivirals and monoclonal antibodies work best if given early, but the-powers-that-be won't give them to you unless you're in a high risk group.\n\nSo, if you're medium-risk, the only way to demonstrate you need the treatment is to wait until it's too late.",
            "conversation_id": "1474200986851835906"
        }
    },
    {
        "data": {
            "conversation_id": "1474180653801377794",
            "id": "1474194403145125894",
            "edit_history_tweet_ids": [
                "1474194403145125894"
            ],
            "text": "Especially if their symptoms are/were mild, it will be easy to talk themselves into boarding an aircraft."
        }
    },
    {
        "data": {
            "conversation_id": "1474180653801377794",
            "edit_history_tweet_ids": [
                "1474193617312911364"
            ],
            "id": "1474193617312911364",
            "text": "It will be worse after the holidays.  People will have picked up an infection during their family gatherings but need to get home, back to school, and/or back to work.\n\nAlmost certainly, a huge number of people will misreport their infection status or number of days of isolation."
        }
    },
    {
        "data": {
            "id": "1474180653801377794",
            "edit_history_tweet_ids": [
                "1474180653801377794"
            ],
            "conversation_id": "1474180653801377794",
            "text": "#Covid tip: Air travel is much less safe right now.\n\nHoliday travel commitments are compelling and humans have an unlimited ability to rationalize away their behaviors.\n\nAlso people mostly haven't recalibrated their risk assessments in the face of Omicron's high transmissibility."
        }
    },
    {
        "data": {
            "conversation_id": "1474154401673539591",
            "edit_history_tweet_ids": [
                "1474154401673539591"
            ],
            "id": "1474154401673539591",
            "text": "#Covid tip:  If you get a positive result with a rapid antigen kit, don't doubt the result.\n\nAny concerns you heard about reliability have to do with the sensitivity of the test.  This is different from specificity.\n\nIf you get two red lines, then covid proteins are present."
        }
    },
    {
        "data": {
            "id": "1472446813357719560",
            "text": "The juxtaposition of three Nones with different meanings feels a bit off.\n\n     def f(y: int | None = None) -&gt; None\n\n1st None if really a NoneType\n2nd None an instance of NoneType\n3rd None really means that no value at all is returned.\n\nx = f(7)  # This fails to typecheck",
            "edit_history_tweet_ids": [
                "1472446813357719560"
            ],
            "conversation_id": "1472426960349548549"
        }
    },
    {
        "data": {
            "text": "Hmm, I didn't know you could do this in #Python:\n\n&gt;&gt;&gt; float(bytes([51, 46, 49, 52]))\n3.14",
            "conversation_id": "1472431060512395264",
            "edit_history_tweet_ids": [
                "1472431060512395264"
            ],
            "id": "1472431060512395264"
        }
    },
    {
        "data": {
            "conversation_id": "1472426960349548549",
            "edit_history_tweet_ids": [
                "1472428419346481155"
            ],
            "id": "1472428419346481155",
            "text": "Typo:  The first assignment should be a colon.\n\ndef f(x: A | B, y: int | None = None) -&gt; dict[tuple[str, str]]: \n    ..."
        }
    },
    {
        "data": {
            "text": "A little birdie told me that #Python typing Optional and Union are going away.  It's all or-operators from here:\n\ndef f(x: A | B, y = int | None = None) -&gt; dict[tuple[str, str]]: ...\n\nI won't miss Union, but Optional was pleasantly readable.\n\nf(x: A | B, y: Optional[int] = None):",
            "conversation_id": "1472426960349548549",
            "edit_history_tweet_ids": [
                "1472426960349548549"
            ],
            "id": "1472426960349548549"
        }
    },
    {
        "data": {
            "conversation_id": "1472331122797264897",
            "edit_history_tweet_ids": [
                "1472331122797264897"
            ],
            "id": "1472331122797264897",
            "text": "#Python people, answer me this.  Is your metaclass appropriate or inappropriate?\n\nhttps://t.co/AdoLd8r3WP"
        }
    },
    {
        "data": {
            "text": "I'm concerned about the Christmas holidays.   Omicron is so transmissible that it will infect entire families all at once.\n\nHopefully, the early reports of it being mild will turn out to be true.",
            "id": "1471943898452963329",
            "edit_history_tweet_ids": [
                "1471943898452963329"
            ],
            "conversation_id": "1471943898452963329"
        }
    },
    {
        "data": {
            "conversation_id": "1471713288153096193",
            "text": "QOTD: \"Breaking an addiction to false certainty is as hard as breaking any other addiction. But the first step is admitting you have a problem.\"\n\nhttps://t.co/YfpjMZvegQ",
            "edit_history_tweet_ids": [
                "1471713288153096193"
            ],
            "id": "1471713288153096193"
        }
    },
    {
        "data": {
            "text": "It may just be old-timer's disease, but I think reason I find this unsettling is that what #Python does is diverging greatly from my mental model.\n\nI used to find the language to be more predictable and less willing to do the tricks used by C compilers.",
            "id": "1471293819702415368",
            "edit_history_tweet_ids": [
                "1471293819702415368"
            ],
            "conversation_id": "1471293377580838922"
        }
    },
    {
        "data": {
            "id": "1471293380240224257",
            "text": "16 LOAD_CONST         0 (None)\n     18 RETURN_VALUE\n  &gt;&gt; 20 LOAD_CONST         0 (None)\n     22 RETURN_VALUE",
            "edit_history_tweet_ids": [
                "1471293380240224257"
            ],
            "conversation_id": "1471293377580838922"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1471293378956599296"
            ],
            "text": "&gt;&gt;&gt; dis(f)\n2     0 LOAD_FAST          0 (x)\n      2 POP_JUMP_IF_FALSE 10 (to 20)\n\n3 &gt;&gt;  4 LOAD_FAST          0 (x)\n      6 LOAD_CONST         1 (1)\n      8 INPLACE_SUBTRACT\n     10 STORE_FAST         0 (x)\n\n2    12 LOAD_FAST          0 (x)\n     14 POP_JUMP_IF_TRUE   2 (to 4)",
            "id": "1471293378956599296",
            "conversation_id": "1471293377580838922"
        }
    },
    {
        "data": {
            "id": "1471293377580838922",
            "text": "#Python's word code generation has been changing quite a bit.  Perhaps it's for the good, but some parts are unsettling.\n\ndef f(x):\n    while x:\n        x -= 1\n\nThe test appears twice.\nThe lines numbers are no longer ascending.\nThere are two exits.\nSometimes NOPs appear.",
            "edit_history_tweet_ids": [
                "1471293377580838922"
            ],
            "conversation_id": "1471293377580838922"
        }
    },
    {
        "data": {
            "conversation_id": "1469705426136616975",
            "edit_history_tweet_ids": [
                "1469705428674228224"
            ],
            "text": "As expected, the CPU is fast, the RAM is fast, the SSD is fast, the GPU supports multiple external monitors, and it is quiet.\n\nLikely, I over-provisioned with 64GB of RAM, but then who ever regrets having too much memory ;-)",
            "id": "1469705428674228224"
        }
    },
    {
        "data": {
            "text": "The finger print reader is a little large and that feels a little weird but maybe the smaller one on MacAir wasn't working well for some users.",
            "conversation_id": "1469705426136616975",
            "edit_history_tweet_ids": [
                "1469705427361447938"
            ],
            "id": "1469705427361447938"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1469705426136616975"
            ],
            "id": "1469705426136616975",
            "text": "I'm pretty happy with the new 16\" MacBook Pro M1 Max.\n\nSo far, the only thing I don't like is that side air vents are now large enough and sharp enough to be a little uncomfortable when carrying the laptop.",
            "conversation_id": "1469705426136616975"
        }
    },
    {
        "data": {
            "conversation_id": "1468783337011564548",
            "id": "1468795729355456513",
            "edit_history_tweet_ids": [
                "1468795729355456513"
            ],
            "text": "There are also issues that no one really thinks are important or valid but if the OP is insistent or persistent, no one wants to go out on a limb to close it.\n\nIn an era where one can be quickly savaged on the interwebs or by CoC complaints, ignoring an issue is the safe play."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1468788647445078020"
            ],
            "conversation_id": "1468783337011564548",
            "id": "1468788647445078020",
            "text": "I would be surprised if any normal use case could fail.\n\nI would not be surprised if someone used a SAT solver to find an exotic combination of method overrides, callbacks, __del__ methods, and thread ordering that could make it segfault or drop entries."
        }
    },
    {
        "data": {
            "text": "An example of the latter is the C code for the lru_cache(). \n\nIt is clearly, mostly correct, but it would be a somewhat difficult undertaking to prove it for all possible forms of callback reentrancy and thread orderings.",
            "id": "1468788646098649094",
            "edit_history_tweet_ids": [
                "1468788646098649094"
            ],
            "conversation_id": "1468783337011564548"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1468788645100404736"
            ],
            "text": "Generally, the only important issues that sit for a long time is when there is agreement on a problem but no clear path to fixing it without breaking something else. \n\nAlso some problems are just hard (but we don't have many of those).",
            "id": "1468788645100404736",
            "conversation_id": "1468783337011564548"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1468788643947061250"
            ],
            "id": "1468788643947061250",
            "text": "Part of the reason, I think age is valid evidence of importance is the responsiveness I see on other issues.\n\nTypos, obvious errors, failure to support key use cases, code breakages and whatnot tend to get discussed and fixed rapidly.",
            "conversation_id": "1468783337011564548"
        }
    },
    {
        "data": {
            "text": "There are some old issues that are valid.  Perhaps they haven't had sufficient attention.  Perhaps, a reasonable solution hasn't been found.\n\nBut sometimes an old age issue means that the concerns were unfounded.",
            "id": "1468785240499961862",
            "edit_history_tweet_ids": [
                "1468785240499961862"
            ],
            "conversation_id": "1468783337011564548"
        }
    },
    {
        "data": {
            "conversation_id": "1468783337011564548",
            "edit_history_tweet_ids": [
                "1468785238855802882"
            ],
            "id": "1468785238855802882",
            "text": "The presence of the integer is likely a code smell, but it isn't clearly an error.\n\nGiven that the unused string variable \"x\" must be ignored, why is it important to type check all the inputs?\n\nI contend that a decade of inaction on the issue suggests it wasn't a real problem."
        }
    },
    {
        "data": {
            "conversation_id": "1468783337011564548",
            "edit_history_tweet_ids": [
                "1468783339230351360"
            ],
            "id": "1468783339230351360",
            "text": "Do we care about 10 being in the dict?\n\n&gt;&gt;&gt; d = {'answer': 'correct', 10: 'never used', 'x': 'unused'}\n\n&gt;&gt;&gt; \"You're %(answer)s\" % d\n\"You're correct\"\n\n&gt;&gt;&gt; \"You're {answer}\".format(**d)\n\"You're correct\"\n\n&gt;&gt;&gt; \"You're {answer}\".format_map(d)\n\"You're correct\""
        }
    },
    {
        "data": {
            "text": "For example, a person is worried that \"template.format(**d)\" and \"template % d\" don't raise an exception if the dict has some non-string keys.\n\nThese methods are 13 years old and 25 years old respectively.  If there were a real world problem, we would have known long ago.",
            "id": "1468783338244739073",
            "edit_history_tweet_ids": [
                "1468783338244739073"
            ],
            "conversation_id": "1468783337011564548"
        }
    },
    {
        "data": {
            "text": "#Python core development thought for the day:  If a tracker issue has been open for a decade with little activity, it is evidence that the problem at hand isn't really important in practice.",
            "id": "1468783337011564548",
            "edit_history_tweet_ids": [
                "1468783337011564548"
            ],
            "conversation_id": "1468783337011564548"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1468052783123292164"
            ],
            "conversation_id": "1468052783123292164",
            "id": "1468052783123292164",
            "text": "#Python quirk:  1 &lt;&lt; 65 constant folds but 2 ** 65 doesn't.\n\n&gt;&gt;&gt; dis(lambda: (1 &lt;&lt; 65, 2 ** 65))\n   0 LOAD_CONST        1 (36893488147419103232)\n   2 LOAD_CONST        2 (2)\n   4 LOAD_CONST        3 (65)\n   6 BINARY_POWER\n   8 BUILD_TUPLE       2\n  10 RETURN_VALUE"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1467218332948615177"
            ],
            "text": "#Python tip:  y=heappushpop(h, x) is equivalent to but faster than heappush(h, x) followed by y=heappop(h).\n\nLikewise, y=heapreplace(h, x) is equivalent to but faster than y=heappop(h) followed by heappush(h, x).\n\nBoth keep the size unchanged and do fewer sifting operations.",
            "conversation_id": "1467218332948615177",
            "id": "1467218332948615177"
        }
    },
    {
        "data": {
            "id": "1466893123943079941",
            "edit_history_tweet_ids": [
                "1466893123943079941"
            ],
            "conversation_id": "1466893123943079941",
            "text": "#Python typing question:  If an optional framework method call is guarded by hasattr(), can you use anything other than type:ignore on the actual call?\n\n        if hasattr(self, 'setup'):\n            self.setup()                # type: ignore"
        }
    },
    {
        "data": {
            "conversation_id": "1466536919257518083",
            "edit_history_tweet_ids": [
                "1466841170022215680"
            ],
            "id": "1466841170022215680",
            "text": "For those wanting a bigger dataset, the Norway outbreak is informative:\n\nhttps://t.co/4vwKJ1Ps1F"
        }
    },
    {
        "data": {
            "id": "1466616803170263041",
            "edit_history_tweet_ids": [
                "1466616803170263041"
            ],
            "conversation_id": "1466536919257518083",
            "text": "One more case just in:\n\nIn CA, (los angeles), traveled to South Africa, fully vaccinated, improving condition without treatment.\n\nhttps://t.co/f0mF48BN69"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1466582740577497089"
            ],
            "conversation_id": "1466536919257518083",
            "id": "1466582740577497089",
            "text": "More data:\n* In HI, mild to moderate case, no travel, previously infected\n* In NY, mild case, 67 y/o female, back from SA, at least one dose of vaccine\n* In NY, four other cases, 2 queens, 1 brooklyn, 1 nyc.  No info on severity, travel, or vaccination status."
        }
    },
    {
        "data": {
            "id": "1466539693340872715",
            "edit_history_tweet_ids": [
                "1466539693340872715"
            ],
            "conversation_id": "1466536919257518083",
            "text": "This is a data science quiz.  Can you populate a beta distribution for the ability to overcome a vaccine or the probability of a mild case?\n\nDo the priors matter?  What percentage of international travelers are fully vaccinated. What percentage of people in CO are full vacc, etc?"
        }
    },
    {
        "data": {
            "text": "Data science small sample pop quiz. What can you infer from the first three Omicron cases in the U.S.?\n\n* In CA, mild case, back South Africa, full vacc.\n* In CO, mild case, back from SA, full vacc.\n* In MN, mild case, back from NYC, vacc and booster.",
            "conversation_id": "1466536919257518083",
            "edit_history_tweet_ids": [
                "1466536919257518083"
            ],
            "id": "1466536919257518083"
        }
    },
    {
        "data": {
            "conversation_id": "1465890976824766468",
            "id": "1465890978007556100",
            "edit_history_tweet_ids": [
                "1465890978007556100"
            ],
            "text": "class A:\n    @recursive_repr()\n    def __repr__(self):\n        return f'{self.__class__.__name__}({list(https://t.co/ncHwUzZ0LU)})'\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; https://t.co/RWeMrp5bKY = [10, 20, 30]\n&gt;&gt;&gt; https://t.co/RWeMrp5bKY.append(a)\n&gt;&gt;&gt; print(repr(a))\nA([10, 20, 30, ...])\n\n2/"
        }
    },
    {
        "data": {
            "id": "1465890976824766468",
            "text": "#Python tip:  The reprlib.recursive_repr() decorator prevents infinite recursion in containers that can potentially reference themselves.\n\n1/",
            "edit_history_tweet_ids": [
                "1465890976824766468"
            ],
            "conversation_id": "1465890976824766468"
        }
    },
    {
        "data": {
            "conversation_id": "1465050874200399875",
            "id": "1465050875546775555",
            "edit_history_tweet_ids": [
                "1465050875546775555"
            ],
            "text": "The operator.countOf() function is very old and predates the lowercase and underscore naming convention."
        }
    },
    {
        "data": {
            "conversation_id": "1465050874200399875",
            "id": "1465050874200399875",
            "edit_history_tweet_ids": [
                "1465050874200399875"
            ],
            "text": "#python factlet:  The operator module provides a countOf() function that works like the count() method for sequences but works on any iterable including generators:\n\n&gt;&gt;&gt; countOf('abracadabra', 'a')\n5\n\n&gt;&gt;&gt; countOf(map(attrgetter('age'), cohort), 30)\n9538"
        }
    },
    {
        "data": {
            "id": "1463651850780127235",
            "attachments": {
                "media_keys": [
                    "3_1463651518855458817"
                ]
            },
            "text": "Before moving to #Python we put this in an Excel spreadsheet.\n\nAdd commas and eliminating digits after the decimal point was easier than in Python. https://t.co/H7jtHYTE47",
            "edit_history_tweet_ids": [
                "1463651850780127235"
            ],
            "conversation_id": "1463594856748658697"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1463651518855458817",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/FE_vTThXMAE3Z1-.png"
                }
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1463594856748658697",
            "edit_history_tweet_ids": [
                "1463596933407195140"
            ],
            "text": "I taught the algorithm but failed to mention that it is spelled \u201csquare root\u201d instead of \u201csquare route\u201d.\n\nThe box to the right means \u201cif it is too hard to compute the average in your head, write the sum of the guess and x in the third column.\u201d",
            "id": "1463596933407195140"
        }
    },
    {
        "data": {
            "conversation_id": "1463594856748658697",
            "text": "His line wrapping blew my mind.  Instead of 41,110.6, he wrote on two lines:\n\n4111\n  0.6",
            "edit_history_tweet_ids": [
                "1463595946353344514"
            ],
            "id": "1463595946353344514"
        }
    },
    {
        "data": {
            "text": "each \u27f6 easy",
            "id": "1463595344609124353",
            "edit_history_tweet_ids": [
                "1463595344609124353"
            ],
            "conversation_id": "1463594856748658697"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1463594887950094339"
            ],
            "conversation_id": "1463594856748658697",
            "id": "1463594887950094339",
            "text": "Successful run!\n\nEnter a square: 610,652,380,806.25\nEnter a guess:  800,000\nOur best guess is 781,657.738004\nOur best guess is 781,442.529634\nOur best guess is 781,442.500000\nOur best guess is 781,442.500000\n\n15/"
        }
    },
    {
        "data": {
            "conversation_id": "1463594856748658697",
            "id": "1463594886758809602",
            "edit_history_tweet_ids": [
                "1463594886758809602"
            ],
            "text": "from math import isclose\n\nsquare = float(input('Enter a square: ').replace(',', ''))\nguess =float(input('Enter a guess:  ').replace(',', ''))\nwhile True:\n  x = square / guess\n  guess = (guess + x) / 2\n  print(f'Our best guess is {guess:,f}')\n  if isclose(guess, x):\n    break\n\n14/"
        }
    },
    {
        "data": {
            "text": "Difficulty:  Testing floats for equality is perilous.\n\nThe solution is to use math.isclose().  Interestingly, Matthew had enough experience with calculators being slightly off to understand why this was needed:\n\n    if isclose(guess, x):\n        break\n\n13/",
            "id": "1463594885496385542",
            "edit_history_tweet_ids": [
                "1463594885496385542"
            ],
            "conversation_id": "1463594856748658697"
        }
    },
    {
        "data": {
            "id": "1463594884321976323",
            "edit_history_tweet_ids": [
                "1463594884321976323"
            ],
            "conversation_id": "1463594856748658697",
            "text": "Difficulty:  mean() takes a single iterable input, so this doesn't work.\n\n    guess = average(guess, x)\n\nThe solution was to give-up on the standard library function:\n\n    guess = (guess + x) / 2\n\n12/"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1463594883109863425"
            ],
            "conversation_id": "1463594856748658697",
            "id": "1463594883109863425",
            "text": "Difficulty:  The statistics.mean() function isn't called average().\n\nThe solution is to rename it the during the import:\n\n    from statistics import mean as average\n\n11/"
        }
    },
    {
        "data": {
            "id": "1463594881876643848",
            "edit_history_tweet_ids": [
                "1463594881876643848"
            ],
            "text": "Difficulty:  The flowchart loop naturally translates to an \"if\" and \"goto\", but #Python doesn't have a goto.\n\nThe solution involved a \"while True\" with a test and break at the bottom.\n\nwhile True:\n   ...\n   if guess == x:\n       break\n\nThe \"==\" notation was also confusing.\n\n10/",
            "conversation_id": "1463594856748658697"
        }
    },
    {
        "data": {
            "id": "1463594880597385218",
            "text": "Difficulty:  He wanted commas in the output\n\nThe solution involved formatted strings.  Surprisingly, he accepted this at face value as if it is obvious that \":,f\" means to add commas:\n\n    print(f'Our best guess is {guess:,f}')\n\n9/",
            "edit_history_tweet_ids": [
                "1463594880597385218"
            ],
            "conversation_id": "1463594856748658697"
        }
    },
    {
        "data": {
            "id": "1463594879364255752",
            "text": "Difficulty:  He tried a decimal input.\n\n    Enter a square: 610,652,380,806.25\n\nThis raised a ValueError. The solution involved converting to a float.  The difference between ints and floats was easy to explain:\n\n    square = float(input('Enter a square: ').replace(',', ''))\n\n8/",
            "edit_history_tweet_ids": [
                "1463594879364255752"
            ],
            "conversation_id": "1463594856748658697"
        }
    },
    {
        "data": {
            "conversation_id": "1463594856748658697",
            "id": "1463594878236082186",
            "edit_history_tweet_ids": [
                "1463594878236082186"
            ],
            "text": "Difficulty:  He used commas in his input\n\n   Enter a square: 54,479,161\n\nThe raised a ValueError.  The solution was to strip the commas.  The code took a lot of explaining:\n\n    square = int(input('Enter a square: ').replace(',', ''))\n\n7/"
        }
    },
    {
        "data": {
            "id": "1463594877061681163",
            "edit_history_tweet_ids": [
                "1463594877061681163"
            ],
            "conversation_id": "1463594856748658697",
            "text": "Translating the flowchart into #Python was fraught with difficulties.\n\n    square = input('Enter a square: ')\n\nDifficulty:  The type of square is a str but needs to be an integer.\n\n    square = int(input('Enter a square: '))\n\n6/"
        }
    },
    {
        "data": {
            "attachments": {
                "media_keys": [
                    "3_1463594071751110657"
                ]
            },
            "conversation_id": "1463594856748658697",
            "id": "1463594873567723530",
            "edit_history_tweet_ids": [
                "1463594873567723530"
            ],
            "text": "After mastering doing the algorithm by hand, we wrote a flowchart for the algorithm.  That was easy.\n\nHe also asked for a decision logic table, but they are only helpful for algorithms with complex decision trees.\n\n5/ https://t.co/qidnaj6YeC"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1463594071751110657",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/FE-7DcYXsAE1SJ7.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1463594856748658697",
            "text": "His next input was 7,801,305,625.\n\nThe math challenge was learning to estimate the initial guess:\n\n78|01|30|56|25\n 9  0  0  0  0\n\n4/",
            "edit_history_tweet_ids": [
                "1463594867129565203"
            ],
            "id": "1463594867129565203"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1463594865858592776"
            ],
            "id": "1463594865858592776",
            "text": "Matthew immediately wanted larger inputs.\n\n54,479,161 \u00f7 5,000 \u2192 10,896 sums to 15,896\n54,479,161 \u00f7 7,948 \u2192  6,854 sums to 14,802\n54,479,161 \u00f7 7,401 \u2192  7,361 sums to 14,762\n54,479,161 \u00f7 7,381 -&gt; 7,381\n\n3/",
            "conversation_id": "1463594856748658697"
        }
    },
    {
        "data": {
            "conversation_id": "1463594856748658697",
            "edit_history_tweet_ids": [
                "1463594862691946503"
            ],
            "id": "1463594862691946503",
            "attachments": {
                "media_keys": [
                    "3_1463593990578745359"
                ]
            },
            "text": "We started by writing a table by hand, doing the divisions with a calculator:\n\n361 \u00f7 20 \u2192 18.05 sums to 38.05 \u00f7 2 \u2192 19.025\n361 \u00f7 19.025 \u2192 18.975 sums to 38 \u00f7 2 \u2192 19\n\n2/ https://t.co/DpdSfPqFwB"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1463593990578745359",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/FE-6-t_XsA8VEcy.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "text": "Teaching my nine-year-old about the divide and average method for computing square roots.\n\nThe math was each to teach, but the #Python coding presented many challenges.\n\nIn instructor-speak, these are called \u201clearning points\u201d  \ud83d\ude09\n\n1/",
            "id": "1463594856748658697",
            "edit_history_tweet_ids": [
                "1463594856748658697"
            ],
            "conversation_id": "1463594856748658697"
        }
    },
    {
        "data": {
            "conversation_id": "1462857022689456132",
            "id": "1463049022382485506",
            "edit_history_tweet_ids": [
                "1463049022382485506"
            ],
            "text": "The reason behind the camelCase spelling of indexOf is interesting.\n\nThe lowercase and underscore convention didn't emerge until Python had been in use for many years.\n\nThe operator.indexOf() function was created by Guido in July 1996.\n\nhttps://t.co/8ssL7xiIYL"
        }
    },
    {
        "data": {
            "text": "I recently saw it used to find the first key matching a target value in a dictionary:\n\n  i = indexOf(d.values(), target_value)\n  k = next(islice(d.keys(), i, i+1))\n\nThat works but this is more readable:\n\n  k = next(key for (key, value) in d.items() if value==target_value)",
            "id": "1462857024140627972",
            "edit_history_tweet_ids": [
                "1462857024140627972"
            ],
            "conversation_id": "1462857022689456132"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1462857022689456132"
            ],
            "id": "1462857022689456132",
            "text": "#Python's operator module has an interesting function called indexOf().\n\nIt behaves like the index() method for sequences but will also work on other iterables and iterators:\n\n&gt;&gt;&gt; squares = (x**2 for x in range(100))\n&gt;&gt;&gt; indexOf(squares, 64)\n8",
            "conversation_id": "1462857022689456132"
        }
    },
    {
        "data": {
            "id": "1462461275951271936",
            "edit_history_tweet_ids": [
                "1462461275951271936"
            ],
            "conversation_id": "1462435365730635789",
            "text": "This technique is handy with space characters:\n\n    # space characters, comma, and underscore\n    r'[\\s,_]'"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1462435365730635789"
            ],
            "text": "#Python tip:  Character sets in regular expressions can be specified with character classes as well as individual characters.\n\n    hex_pattern = r'[\\da-f]'\n\nis equivalent to:\n\n    hex_pattern = r'[0-9a-f]'",
            "id": "1462435365730635789",
            "conversation_id": "1462435365730635789"
        }
    },
    {
        "data": {
            "conversation_id": "1461743474542268416",
            "edit_history_tweet_ids": [
                "1461743479860649986"
            ],
            "id": "1461743479860649986",
            "text": "In the grand scheme, this change isn't important, but it does make the language slightly nicer.\n\n5 of 5"
        }
    },
    {
        "data": {
            "conversation_id": "1461743474542268416",
            "edit_history_tweet_ids": [
                "1461743478174629892"
            ],
            "id": "1461743478174629892",
            "text": "Another use case was harmonizing  _pyio.open  with https://t.co/ftH19e19Tz:\n\nhttps://t.co/0U4g3K7Tlo\n\n4 of 5"
        }
    },
    {
        "data": {
            "conversation_id": "1461743474542268416",
            "edit_history_tweet_ids": [
                "1461743476983353356"
            ],
            "text": "One valid use case was using a staticmethod inside a class definition as a function default argument to another class.\n\nhttps://t.co/0nq5St2qge\n\n3 of 5",
            "id": "1461743476983353356"
        }
    },
    {
        "data": {
            "conversation_id": "1461743474542268416",
            "edit_history_tweet_ids": [
                "1461743475838398464"
            ],
            "id": "1461743475838398464",
            "text": "It took two decades to add this functionality because it wasn't clear there were any use cases for it.\n\nThe biggest benefit is that it matches the simple mental model of being a function pass-through rather the more complex model with descriptor specific logic.\n\n2 of 5"
        }
    },
    {
        "data": {
            "conversation_id": "1461743474542268416",
            "edit_history_tweet_ids": [
                "1461743474542268416"
            ],
            "id": "1461743474542268416",
            "text": "In #Python3.10 instances of staticmethod() became callable without having to go through a class or instance.\n\n&gt;&gt; sm = staticmethod(ord)\n&gt;&gt; sm('A')\n65\n\n1 of 5"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1461619976943640576"
            ],
            "id": "1461619976943640576",
            "text": "Wow.  I'm impressed.  Tonight was the best lunar eclipse I've ever seen.",
            "conversation_id": "1461619976943640576"
        }
    },
    {
        "data": {
            "conversation_id": "1461442988157067269",
            "text": "How do you pronounce #Python 3.10's new aiter() builtin function?",
            "edit_history_tweet_ids": [
                "1461442988157067269"
            ],
            "id": "1461442988157067269"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1461183802865299460"
            ],
            "text": "The final result passes mypy with a --strict option but it still needs more work.\n\nWhen a key function is supplied, the data can be any type and the key function return value must support comparison.\n\nWithout a key function, the input type must support direct comparison.",
            "id": "1461183802865299460",
            "conversation_id": "1461151307285336064"
        }
    },
    {
        "data": {
            "id": "1461183128538652672",
            "edit_history_tweet_ids": [
                "1461183128538652672"
            ],
            "text": "Some time was lost by entering Tuple[T] instead of Tuple[T, ...].\n\nI already knew the correct way, but my fingers got reprogrammed after entering Iterable[T] a few times.\n\nThis was never a problem before, but the asymmetry between tuple and other container types makes it a risk.",
            "conversation_id": "1461151307285336064"
        }
    },
    {
        "data": {
            "text": "Writing the function and testing it took no more than 15 minutes.\n\nGetting the type annotations correct took about six hours in total (not contiguous).\n\nOnce or twice, I almost accepted defeat.  The mypy error messages can be inscrutable and provide no hint about how to proceed.",
            "conversation_id": "1461151307285336064",
            "edit_history_tweet_ids": [
                "1461158549254549509"
            ],
            "id": "1461158549254549509"
        }
    },
    {
        "data": {
            "id": "1461157239486619650",
            "text": "When using overloading, mypy checks to make sure that \nthe overloaded function implementation accepts all possible arguments of each overload.\n\nThe / and * restrictions are essential in this regard.",
            "edit_history_tweet_ids": [
                "1461157239486619650"
            ],
            "conversation_id": "1461151307285336064"
        }
    },
    {
        "data": {
            "conversation_id": "1461151307285336064",
            "id": "1461155790459449346",
            "edit_history_tweet_ids": [
                "1461155790459449346"
            ],
            "text": "We have abstract base class for Sized, Hashable, Iterable, etc.   But to determine whether an object is orderable, we need a Protocol() that can detect __gt__.\n\nInterestingly, this isn't thrown-off by object() already having __gt__ method."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1461154952991195140"
            ],
            "id": "1461154952991195140",
            "text": "When mypy can't make a deduction across a conditional branch, a cast() is required to narrow the possibilities.",
            "conversation_id": "1461151307285336064"
        }
    },
    {
        "data": {
            "conversation_id": "1461151307285336064",
            "id": "1461154950763974663",
            "text": "The two argument trick was needed to distinguish a one argument case from a two-or-more argument case.\n\nSince *args means zero-or-more, two fixed args are needed:\n\n@overload\ndef f(arg1: T, arg2: T, *args):\n    ...\n\n@overload\ndef f(arg: T):\n    ...",
            "edit_history_tweet_ids": [
                "1461154950763974663"
            ]
        }
    },
    {
        "data": {
            "id": "1461154949593812999",
            "edit_history_tweet_ids": [
                "1461154949593812999"
            ],
            "conversation_id": "1461151307285336064",
            "text": "MyPy has a known issue picking apart unions in the form:  Union[T, Iterable[T].\n\nSo, overloads were needed as a work-around.\n\n# https://t.co/uIIievQilP"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1461154948683554818"
            ],
            "conversation_id": "1461151307285336064",
            "id": "1461154948683554818",
            "text": "I normally use the \"is\" operator to test for sentinel values but mypy needs an instance() check to distinguish that case.\n\nChecking ininstance(x, object) always matches, so a custom Sentinel class was required."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1461151307285336064"
            ],
            "text": "#Python success:  I was finally able to make a type annotated pure python version of max().\n\nAll it took was a protocol bound to a typevar, a custom sentinel class, unions, overloads, isinstance checks, casts, repeated arguments, and the / and * notation.\n\nhttps://t.co/KOqZ46Pmcj",
            "conversation_id": "1461151307285336064",
            "id": "1461151307285336064"
        }
    },
    {
        "data": {
            "conversation_id": "1460829569326456832",
            "edit_history_tweet_ids": [
                "1460852638782828544"
            ],
            "id": "1460852638782828544",
            "text": "@overload\ndef mymax(*args: T,\n          key = Optional[Callable[[T], Any]]) -&gt; T:\n    ...\n\ndef mymax(*args: Union[Iterable[T], T],\n          default: Union[Sentinel, D] = sentinel,\n          key: Optional[Callable[[T], Any]] = None) -&gt; Union[D, T]:\n\n#MyPy is not happy!"
        }
    },
    {
        "data": {
            "text": "Hmm, I couldn't get mypy to accept any variation, so I'm stuck on this last step.\n\n@overload\ndef mymax(iterable: Iterable[T],\n          *,\n          default: Union[Sentinel, D],\n          key: Optional[Callable[[T], Any]]) -&gt; Union[D, T]:\n    ...",
            "id": "1460852637570588672",
            "edit_history_tweet_ids": [
                "1460852637570588672"
            ],
            "conversation_id": "1460829569326456832"
        }
    },
    {
        "data": {
            "id": "1460840210258927619",
            "edit_history_tweet_ids": [
                "1460840210258927619"
            ],
            "text": "Triple extra credit if you can figure-out how to how to type annotate the max() function including its *key* and *default* options.\n\nHint: overloading and typevars are required.",
            "conversation_id": "1460829569326456832"
        }
    },
    {
        "data": {
            "conversation_id": "1460829569326456832",
            "id": "1460830518161858561",
            "edit_history_tweet_ids": [
                "1460830518161858561"
            ],
            "text": "For a more accurate answer, start by reading the docs:\n\nhttps://t.co/RMfQlzunjN"
        }
    },
    {
        "data": {
            "conversation_id": "1460829569326456832",
            "id": "1460829570593169408",
            "edit_history_tweet_ids": [
                "1460829570593169408"
            ],
            "text": "Extra credit if you know which comparison operator to use and the order of its arguments.\n\nDouble extra credit if you find a way to make the signature nicer with __text_signature__.  (I only half succeeded at this step)."
        }
    },
    {
        "data": {
            "text": "#Python argument handling challenge:  Write max() in pure python including both the iterable form and the multi-argument form.  Include the *key* and *default* keyword arguments and error handling.\n\nhttps://t.co/hw9d8H3qrA",
            "id": "1460829569326456832",
            "edit_history_tweet_ids": [
                "1460829569326456832"
            ],
            "conversation_id": "1460829569326456832"
        }
    },
    {
        "data": {
            "conversation_id": "1459660308935495691",
            "edit_history_tweet_ids": [
                "1459936316871880705"
            ],
            "text": "Short proof for the relationship:\n\nhttps://t.co/hzxjMVOuJa",
            "id": "1459936316871880705"
        }
    },
    {
        "data": {
            "text": "In case you're wondering where the \"b**2 - b - 1\" comes from, see this proof of Binet's formula for the Fibonacci sequence.\n\nhttps://t.co/Hkk8W4J5iR",
            "id": "1459660313750614024",
            "edit_history_tweet_ids": [
                "1459660313750614024"
            ],
            "conversation_id": "1459660308935495691"
        }
    },
    {
        "data": {
            "conversation_id": "1459660308935495691",
            "edit_history_tweet_ids": [
                "1459660312408383494"
            ],
            "text": "The relationship holds for other bases as well:\n\n&gt;&gt;&gt; base = 12\n\n&gt;&gt;&gt; fsum(fib / base**(i + 1) for i, fib in enumerate(fibs))\n0.007633587786259542\n\n1 / (base ** 2 - base - 1)\n0.007633587786259542 https://t.co/fqsIlw0cSP",
            "attachments": {
                "media_keys": [
                    "3_1459659281113006084"
                ]
            },
            "id": "1459660312408383494"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1459659281113006084",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/FEHAYe_XwAQ03Ei.png"
                }
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1459660310353227786"
            ],
            "id": "1459660310353227786",
            "text": "Playing around with a calculator, Matthew noticed the Fibonacci sequence embedded in the decimal expansion of 1 / 89th.\n\nThis identity isn't new, but he did discover it on his own. Needless to say, his dad is proud.  \n\n\u201cChance favors only the prepared mind.\u201d \u2014 Louis Pasteur",
            "conversation_id": "1459660308935495691"
        }
    },
    {
        "data": {
            "id": "1459660308935495691",
            "edit_history_tweet_ids": [
                "1459660308935495691"
            ],
            "conversation_id": "1459660308935495691",
            "text": "#Python fun courtesy of my son (aged 9):\n\n# Fibonacci sequence\n&gt;&gt;&gt; fibs = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n\n&gt;&gt;&gt; fsum(fib / 10**(i + 1) for i, fib in enumerate(fibs))\n0.011235955056179775\n\n&gt;&gt;&gt; 1 / 89\n0.011235955056179775"
        }
    },
    {
        "data": {
            "conversation_id": "1459024249600028673",
            "edit_history_tweet_ids": [
                "1459038551102926848"
            ],
            "id": "1459038551102926848",
            "text": "For those answering, \"yes, and I use it\", it would be helpful for my research to have a link to where it is used so I can look at the context."
        }
    },
    {
        "data": {
            "conversation_id": "1459024249600028673",
            "id": "1459024249600028673",
            "text": "#Python knowledge survey:  Before this tweet, did you know that __instancecheck__ can be used to override isinstance() ?",
            "edit_history_tweet_ids": [
                "1459024249600028673"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1458857054362345474",
            "edit_history_tweet_ids": [
                "1458857057831067654"
            ],
            "text": "Since pattern matching is effectively an if-elif chain, ordering is important.\n\nSpecial cases should precede general cases.\n\n4 of 4",
            "id": "1458857057831067654"
        }
    },
    {
        "data": {
            "text": "match sales_report:\n    case {'dept': dept, 'holiday': event}:\n        # Holiday case must precede other cases\n        ...\n    case {'dept': 'shoes'}:\n        ...\n    case {'dept': 'hats'}:\n        ...\n\n3 of 4",
            "id": "1458857056778215425",
            "edit_history_tweet_ids": [
                "1458857056778215425"
            ],
            "conversation_id": "1458857054362345474"
        }
    },
    {
        "data": {
            "conversation_id": "1458857054362345474",
            "id": "1458857055612289024",
            "edit_history_tweet_ids": [
                "1458857055612289024"
            ],
            "text": "match x:\n    case bool():\n        ...\n    case int():\n        assert not isinstance(x, bool)\n        ...\n    case Counter():\n        ...\n    case dict():\n        assert not isinstance(x, Counter)\n    case _:\n        raise TypeError\n\n2 of 4"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1458857054362345474"
            ],
            "text": "#Python's structural pattern matching is new, so the best practices aren't yet known.\n\nJust added to my personal list: Add a comment or assertion noting when case ordering is important.  \n\nOtherwise, a future maintainer will be bitten by the illusion of case independence.\n\n1 of 4",
            "id": "1458857054362345474",
            "conversation_id": "1458857054362345474"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1458496961858920449"
            ],
            "text": "#Python mystery ;-)   There is a function called \"i saw a i table\" in the inspect module.  What do you think it does?  Can you see a ii table or iii table as well?",
            "id": "1458496961858920449",
            "conversation_id": "1458496961858920449"
        }
    },
    {
        "data": {
            "id": "1458160126427377668",
            "text": "Correction:\n\nmatch obj:\n    case Hashable():\n        ...",
            "edit_history_tweet_ids": [
                "1458160126427377668"
            ],
            "conversation_id": "1458155867719733265"
        }
    },
    {
        "data": {
            "conversation_id": "1458155867719733265",
            "edit_history_tweet_ids": [
                "1458155872606212097"
            ],
            "id": "1458155872606212097",
            "text": "Note that matches only detect a promise that an API has been implemented.  It can't detect whether a call to the API will succeed.\n\nThe classic example is that issubclass(tuple, Hashable) returns true, but hashing a tuple will fail if its components are unhashable."
        }
    },
    {
        "data": {
            "text": "For more complex ABCs, such as Sequence and Mapping, the presence of the required methods is insufficient.\n\nThe object's class needs to either inherit from the ABC or be registered with the ABC.",
            "conversation_id": "1458155867719733265",
            "edit_history_tweet_ids": [
                "1458155870886535175"
            ],
            "id": "1458155870886535175"
        }
    },
    {
        "data": {
            "conversation_id": "1458155867719733265",
            "id": "1458155869275832326",
            "edit_history_tweet_ids": [
                "1458155869275832326"
            ],
            "text": "Matching a collection ABC is preferable to looking for the required methods directly.\n\nThe complication is that those methods may be present but could be set to None.\n\nThe ABCs listed above handle the None checks for you."
        }
    },
    {
        "data": {
            "text": "#Python tip:  Structural pattern matching works with abstract base classes such as: Contains, Hashable, Iterable, Iterator, Reversible, Generator, Sized, Callable, and Collection.\n\nmatch obj:\n    case Hashable:\n        ...",
            "id": "1458155867719733265",
            "edit_history_tweet_ids": [
                "1458155867719733265"
            ],
            "conversation_id": "1458155867719733265"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1457847399578279939"
            ],
            "id": "1457847399578279939",
            "text": "#Python factlet:  Calling the close() method on a generator is equivalent to calling throw(GeneratorExit) and then verifying that the generator actually terminates, either with a GeneratorExit or a StopIteration exception.",
            "conversation_id": "1457847399578279939"
        }
    },
    {
        "data": {
            "conversation_id": "1456342023531864068",
            "edit_history_tweet_ids": [
                "1456342025805123600"
            ],
            "id": "1456342025805123600",
            "text": "Matching set constants is mainly useful when nested inside a class pattern:\n\ncase Request(action='delete', permissions=Perm.FULL):\n    ...\n\n3 of 3"
        }
    },
    {
        "data": {
            "conversation_id": "1456342023531864068",
            "text": "Also note that a frozenset would match:\n\nmatch frozenset({3, 2, 1}):\n    case C.ones:\n        print('ones')\n    case C.tens:\n        print('tens')\n\n2 of 3",
            "edit_history_tweet_ids": [
                "1456342024714694656"
            ],
            "id": "1456342024714694656"
        }
    },
    {
        "data": {
            "conversation_id": "1456342023531864068",
            "edit_history_tweet_ids": [
                "1456342023531864068"
            ],
            "id": "1456342023531864068",
            "text": "#Python structural pattern matching tip:  To match on sets, use the constant pattern.\n\nclass C:\n    ones = {1, 2, 3}\n    tens = {10, 20, 30}\n\nmatch {3, 2, 1}:\n    case C.ones:\n        print('ones')\n    case C.tens:\n        print('tens')\n\n1 of 3"
        }
    },
    {
        "data": {
            "conversation_id": "1456270600335335432",
            "edit_history_tweet_ids": [
                "1456270600335335432"
            ],
            "text": "#Python tip: Class patterns in structural pattern matching perform an isinstance() check.  For an exact type match, add a guard:\n\nmatch x:\n    case int() if type(x) is int:\n        print('exact int')\n    case str() if type(x) is str:\n        print('exact str')",
            "id": "1456270600335335432"
        }
    },
    {
        "data": {
            "conversation_id": "1454865294120325124",
            "edit_history_tweet_ids": [
                "1454865294120325124"
            ],
            "text": "Cool #Python feature:  The constructor for functools.partial() detects nesting and automatically flattens itself to a more efficient form.\n\n&gt;&gt;&gt; partial(partial(partial(f, 10), 20), 30)\nfunctools.partial(&lt;function f at 0x10a8d5510&gt;, 10, 20, 30)",
            "id": "1454865294120325124"
        }
    },
    {
        "data": {
            "conversation_id": "1452338081240125458",
            "id": "1452338081240125458",
            "edit_history_tweet_ids": [
                "1452338081240125458"
            ],
            "text": "#Python factlet:  The os module provides access to environment variables either as strings or as bytes:\n\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ['USER']\n'raymond'\n&gt;&gt;&gt; os.environb[b'USER']\nb'raymond'"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1450539365827072001"
            ],
            "text": "Interestingly, a similar result can be modeled by sorting a uniform distribution:\n\narrivals = sorted(uniform(0.0, n*rate) for i in range(n))\n\n2/2",
            "conversation_id": "1450539364430266373",
            "id": "1450539365827072001"
        }
    },
    {
        "data": {
            "id": "1450539364430266373",
            "edit_history_tweet_ids": [
                "1450539364430266373"
            ],
            "conversation_id": "1450539364430266373",
            "text": "#Python factlet: The interval between request arrival times can be modeled with random.expovariate().\n\nn = 1000\nrate = 5.0\n\narrivals = []\narrival_time = 0.0\nfor i in range(n):\n    interval = expovariate(1 / rate)\n    arrival_time += interval\n    arrivals.append(arrival_time)\n\n1/2"
        }
    },
    {
        "data": {
            "conversation_id": "1446191250470735878",
            "id": "1446191250470735878",
            "edit_history_tweet_ids": [
                "1446191250470735878"
            ],
            "text": "#Python pop quiz:  Is this code valid?  If so, what does it do?\n\ndef f():\n    yield 10\n    return 20\n\ng = f()\nprint(next(g))\nprint(next(g))"
        }
    },
    {
        "data": {
            "conversation_id": "1443238950919938054",
            "text": "If you want to understand #Python's global interpreter lock, I recommend this blog post.  It is well written and well researched.\n\nhttps://t.co/hNlcyOuLn6",
            "edit_history_tweet_ids": [
                "1443238950919938054"
            ],
            "id": "1443238950919938054"
        }
    },
    {
        "data": {
            "conversation_id": "1441077960161865731",
            "edit_history_tweet_ids": [
                "1441103156956434433"
            ],
            "id": "1441103156956434433",
            "text": "For a fixed comparison function, the benefit occurs in only one of the partitioning passes \u2014 in particular, the one where the segment is split into mostly equal sized groups.\n\nWhat is really needed is an adaptive comparison that becomes more fine grained on successive passes."
        }
    },
    {
        "data": {
            "conversation_id": "1441077960161865731",
            "id": "1441077960161865731",
            "edit_history_tweet_ids": [
                "1441077960161865731"
            ],
            "text": "Fun #Python exercise:  Adapt a sort algorithm to take advantage of a more than 3-way comparison function, perhaps giving:  way under, under, a little under, exact, a little over, over, and way over.\n\nhttps://t.co/WppPQpLYT2"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1440354762247999491"
            ],
            "id": "1440354762247999491",
            "text": "The code is here:\n\nhttps://t.co/zJ5pZuzrNX\n\nAnd the subtype test is here:\n\nhttps://t.co/vV47YAT9Kw",
            "conversation_id": "1440354754421411849"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1440354760540844040"
            ],
            "id": "1440354760540844040",
            "text": "The logic is documented here:\n\nhttps://t.co/ZhCV0XWscI",
            "conversation_id": "1440354754421411849"
        }
    },
    {
        "data": {
            "text": "Virtual subclassing is not considered, so isinstance() isn't called.  Instead the test scans the MRO of type(b) to see if type(a) is present.",
            "id": "1440354758154330119",
            "edit_history_tweet_ids": [
                "1440354758154330119"
            ],
            "conversation_id": "1440354754421411849"
        }
    },
    {
        "data": {
            "text": "#Python factlet:  The comparison a&lt;b calls b.__gt__(a) first if the operands are of different types, and right operand\u2019s type is a direct or indirect subclass of the left operand\u2019s type.\n\nOtherwise a.__lt__(b) is called first. If NotImplemented is returned, b.__gt__(a) is called.",
            "conversation_id": "1440354754421411849",
            "edit_history_tweet_ids": [
                "1440354754421411849"
            ],
            "id": "1440354754421411849"
        }
    },
    {
        "data": {
            "conversation_id": "1438538379545747457",
            "edit_history_tweet_ids": [
                "1438538379545747457"
            ],
            "id": "1438538379545747457",
            "text": "#Python pop quiz:  Which of these is fastest?  Why?"
        }
    },
    {
        "data": {
            "conversation_id": "1437804595720474628",
            "text": "#Python tip:  A ChainMap view can easily collapsed into a regular dictionary:\n\nview = ChainMap(d1, d2, d3)\ncollapsed = dict(view)",
            "edit_history_tweet_ids": [
                "1437804595720474628"
            ],
            "id": "1437804595720474628"
        }
    },
    {
        "data": {
            "text": "#Python factlet:  s[0] is faster than s.__getitem__(0) even if you use a boundmethod for the latter.\n\nThe first compiles to BINARY_SUBSCR.\n\nThe second compiles to a LOAD_METHOD and CALL_METHOD.\n\nBoth are pathways to the same underlying implementation, but the first is faster.",
            "id": "1437026009942007819",
            "edit_history_tweet_ids": [
                "1437026009942007819"
            ],
            "conversation_id": "1437026009942007819"
        }
    },
    {
        "data": {
            "conversation_id": "1434199216562315277",
            "text": "#Python typing question:  Is there a way to annotate this:\n\n    def lowbit(x: int) -&gt; Literal[0, 1]:\n        return x &amp; 1\n\nwithout changing the actual code to something less efficient:\n\n    return 1 if x &amp; 1 else 0",
            "edit_history_tweet_ids": [
                "1434199216562315277"
            ],
            "id": "1434199216562315277"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1433611458370228224"
            ],
            "text": "If you're getting serious about using #Python's type annotations, I recommend @AdamChainz 's excellent write-up about the overload decorator.\n\nhttps://t.co/LlALksKEYK",
            "id": "1433611458370228224",
            "conversation_id": "1433611458370228224"
        }
    },
    {
        "data": {
            "conversation_id": "1433555551133343746",
            "edit_history_tweet_ids": [
                "1433555551133343746"
            ],
            "id": "1433555551133343746",
            "text": "#Python typing question:  How do you annotate a __getitem__ method that returns a int when the index is an int and returns a list when the index is a slice?\n\ns[0] -&gt; 10\ns[:3] -&gt; [10, 20, 30]"
        }
    },
    {
        "data": {
            "id": "1432468641195466772",
            "edit_history_tweet_ids": [
                "1432468641195466772"
            ],
            "conversation_id": "1432468641195466772",
            "text": "#Python factlets:  \n\nint(x) always returns an instance of int or a strict int subclass.  Returning int subclasses is deprecated.\n\nmath.trunc(x) can return any data type.  It is documented to \u201ctruncate a Real to the nearest Integral toward 0\u201d but that isn't checked."
        }
    },
    {
        "data": {
            "conversation_id": "1431016905276633088",
            "id": "1431016906740359169",
            "text": "Dealing with concurrency and reentrancy issues is tricky.\n\nTo my eyes, the PR correctly covers all possible cases.  However, some deadlocked buildbots say otherwise ;-)",
            "edit_history_tweet_ids": [
                "1431016906740359169"
            ]
        }
    },
    {
        "data": {
            "id": "1431016905276633088",
            "edit_history_tweet_ids": [
                "1431016905276633088"
            ],
            "text": "Anyone want to help me rescue #Python's cached_property decorator?\n\nIf I can't fix the race condition in my proposed fix, we're likely going to rip out locking entirely, losing the guarantee that a method cannot be called more than once per instance.\n\nhttps://t.co/dFzGyKNyqb",
            "conversation_id": "1431016905276633088"
        }
    },
    {
        "data": {
            "id": "1430565266136698882",
            "edit_history_tweet_ids": [
                "1430565266136698882"
            ],
            "conversation_id": "1430540901772898306",
            "text": "Other conventions:\n\ndef invalid_method():\n    \"Override a method that will never make sense for this subclass\"\n    raise NotImplentedError\n\ndef binop(self, other):\n    \"Allow reversed call to other\"\n    if not isinstance(other, KnownType):\n         return NotImplemented\n    ..."
        }
    },
    {
        "data": {
            "id": "1430540901772898306",
            "edit_history_tweet_ids": [
                "1430540901772898306"
            ],
            "conversation_id": "1430540901772898306",
            "text": "Suggested #Python convention:  Mark stub functions with \"...\" and reserve \"pass\" for intentionally empty statement blocks.\n\ndef stub_function():\n   \"Going to write this someday\"\n    ...\n\nclass NewError(Exception):\n    \"Old errors aren't good enough\"\n    pass"
        }
    },
    {
        "data": {
            "id": "1430212867274461191",
            "text": "Face the facts.   \n\nAt some point @US_FDA WILL approve a vaccine for children under 12; otherwise, every child in country will eventually get covid.\n\nThe vaccine @US_FDAs approve WILL be the Pfizer vaccine, nothing else is in the works.\n\nKids are back in school, don't delay!",
            "edit_history_tweet_ids": [
                "1430212867274461191"
            ],
            "conversation_id": "1430212865928142849"
        }
    },
    {
        "data": {
            "id": "1429885389796478978",
            "edit_history_tweet_ids": [
                "1429885389796478978"
            ],
            "conversation_id": "1429885389796478978",
            "text": "What is the best #Python approach to removing a default XML namespace?\n\n&lt;svg width=\"1346pt\" height=\"1550pt\"\n viewBox=\"0.00 0.00 1346.19 1550.00\" xmlns=\"https://t.co/409dJTfRmW\"&gt;\n\nI really don't want these tag qualifiers:\n\n&lt;Element '{https://t.co/409dJTfRmW}svg' at 0x1053b7b00&gt;"
        }
    },
    {
        "data": {
            "conversation_id": "1429865101281185795",
            "id": "1429865101281185795",
            "edit_history_tweet_ids": [
                "1429865101281185795"
            ],
            "text": "OH:  When this is all over, we're going to party like it's 2019."
        }
    },
    {
        "data": {
            "text": "#Python tip:  Debuggers are wonderful, but sometimes just adding \"print(locals())\" is the easiest way to go ;-)",
            "id": "1429490076388630529",
            "edit_history_tweet_ids": [
                "1429490076388630529"
            ],
            "conversation_id": "1429490076388630529"
        }
    },
    {
        "data": {
            "conversation_id": "1428457757674508289",
            "edit_history_tweet_ids": [
                "1428457760186851328"
            ],
            "id": "1428457760186851328",
            "text": "Papers tended to use phrasing like, \"let n be the smallest integer such that ...\""
        }
    },
    {
        "data": {
            "text": "This reminds me of the early days of BASIC when mathematically inclined people where uncomfortable with \"=\" for variable assignments, so the useless verb \"LET\" was used to mimic the style used in papers:\n\n10 LET PI = 3.1415926535\n20 LET E = 2.781281828",
            "id": "1428457758941138948",
            "edit_history_tweet_ids": [
                "1428457758941138948"
            ],
            "conversation_id": "1428457757674508289"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1428457757674508289"
            ],
            "conversation_id": "1428457757674508289",
            "id": "1428457757674508289",
            "text": "#Python tip:  Don't unnecessarily prefix function names with \"get\".\n\nIn the sys module, getsizeof() should have been named sizeof().  The \"get\" is useless baggage."
        }
    },
    {
        "data": {
            "conversation_id": "1427754865359474689",
            "edit_history_tweet_ids": [
                "1427754866542325762"
            ],
            "id": "1427754866542325762",
            "text": "This is the general rule.  When there is an exceptions to the rule, it is always called out in the documentation.\n\nFor example, the __missing__ method for dict subclasses, do_get() method for HTTP handers, or the do_xxx() methods for the cmd module."
        }
    },
    {
        "data": {
            "text": "In general, the methods from #Python's builtin types are independent of one another.\n\nIf a dict subclass overrides __getitem__(), other methods such as get() or pop() are unaffected.\n\nhttps://t.co/RiXJqo0GDc\n\n1/",
            "id": "1427754865359474689",
            "edit_history_tweet_ids": [
                "1427754865359474689"
            ],
            "conversation_id": "1427754865359474689"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1426924966944051203"
            ],
            "text": "I would also like to see opt-out biweekly pool testing for early detection of classroom spread.\n\nIf delta is in fact as contagious as chickenpox and can spread asymptomatically, then testing is the only opportunity for intervention.",
            "id": "1426924966944051203",
            "conversation_id": "1426718121281343489"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1426718121281343489"
            ],
            "conversation_id": "1426718121281343489",
            "id": "1426718121281343489",
            "text": "A whole country with kids going back to school is going to pay a price for every day the @US_FDA delays approving a vaccine for children 5 to 12.\n\nA mask is very weak measure compared to an actual vaccination.\n\nhttps://t.co/wGHD9SXJlj"
        }
    },
    {
        "data": {
            "conversation_id": "1425177486418141187",
            "id": "1425177488406286339",
            "text": "GHG:  Greenhouse gases\n\nCryosphere:  Frozen surface water (glaciers, permafrost)\n\nAustral:  Southern hemisphere\n\nEvapotranspiration:  Evaporation plus transpiration from plants\n\nLow probability, high impact event:  Russian Roulette\n\nCIDs:  Climate impact drivers",
            "edit_history_tweet_ids": [
                "1425177488406286339"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1425177487487741958"
            ],
            "conversation_id": "1425177486418141187",
            "id": "1425177487487741958",
            "text": "Don't be intimidated the size of the full report.\n\nThe \"Summary for PolicyMakers\" has what you need to know and can be read in about 45 minutes, or get just the essentials in 15 to 20 minutes.\n\nThere are links from the summary to drill down into the details as needed."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1425177486418141187"
            ],
            "text": "I suggest investing 15-20 minutes to read the Climate Change 2021 report for yourself.\n\nDon't let your knowledge be limited to just headlines and interpretations by others.\n\nhttps://t.co/Krn87Sdxdo",
            "conversation_id": "1425177486418141187",
            "id": "1425177486418141187"
        }
    },
    {
        "data": {
            "id": "1422776981893140482",
            "edit_history_tweet_ids": [
                "1422776981893140482"
            ],
            "conversation_id": "1422776981893140482",
            "text": "#Python tip:   For sets, the discard() method removes an element if present, and does nothing if the element is not present:\n\n    someset.discard(element)\n\nThe equivalent for dictionaries is:\n\n    somedict.pop(key, None)"
        }
    },
    {
        "data": {
            "id": "1421856677763207173",
            "edit_history_tweet_ids": [
                "1421856677763207173"
            ],
            "conversation_id": "1421856674730496001",
            "text": "Key learning point:  \n\nYour spidey sense should start to tingle whenever you see a lock being held for the duration of an arbitrary function call.\n\nhttps://t.co/4co9j4uDvx\n\n4 of 4"
        }
    },
    {
        "data": {
            "id": "1421856676806807555",
            "edit_history_tweet_ids": [
                "1421856676806807555"
            ],
            "text": "There is an open bug report for this small catastrophe:\n\nhttps://t.co/nVMHi5F5YL\n\n3 of 4",
            "conversation_id": "1421856674730496001"
        }
    },
    {
        "data": {
            "text": "For the most part, you would be better off with a dirt simple, lockless implementation:\n\nhttps://t.co/rK7oIE9zvq\n\n2 of 4",
            "conversation_id": "1421856674730496001",
            "edit_history_tweet_ids": [
                "1421856675913469957"
            ],
            "id": "1421856675913469957"
        }
    },
    {
        "data": {
            "text": "#Python limitation: The functools.cached_property() decorator blocks parallel calculation of cached values, even for *distinct* instances of the same class.\n\nThis makes it completely unsuitable for I/O bound methods in a threaded environment.\n\nhttps://t.co/UmSh7k1Vkd\n\n1 of 4",
            "id": "1421856674730496001",
            "edit_history_tweet_ids": [
                "1421856674730496001"
            ],
            "conversation_id": "1421856674730496001"
        }
    },
    {
        "data": {
            "conversation_id": "1410249807571165186",
            "id": "1410249807571165186",
            "edit_history_tweet_ids": [
                "1410249807571165186"
            ],
            "text": "Fields are commonly delimited with commas, tabs, newlines, ampersands, and vertical bars (|).\n\nBut these need to be escaped if they appear in the data.\n\nInstead, try the ASCII unit separator (US), 'x1f'.\n\nAFAICT, the only disadvantage is that it isn't printable."
        }
    },
    {
        "data": {
            "text": "Useful #Python quirk:  The interactive REPL saves an expression result in a variable called \"_\" but only if the result is not None.\n\n&gt;&gt;&gt; s = [10, None]\n&gt;&gt;&gt; s[0]\n10\n&gt;&gt;&gt; _\n10\n&gt;&gt;&gt; s[1]\n&gt;&gt;&gt; _\n10",
            "conversation_id": "1404637229084024832",
            "edit_history_tweet_ids": [
                "1404637229084024832"
            ],
            "id": "1404637229084024832"
        }
    },
    {
        "data": {
            "conversation_id": "1401745336868110338",
            "id": "1401745336868110338",
            "text": "My friend Grant makes everything better :-) https://t.co/vtl4R5e4H9",
            "edit_history_tweet_ids": [
                "1401745336868110338"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1401275497066110977",
            "edit_history_tweet_ids": [
                "1401275497066110977"
            ],
            "text": "The early days of computing were a fertile time for creative thought.   Besides the ALGOL derivatives, there were so many wondrous ways of expressing code:  APL, Forth, Prolog, Lisp.",
            "id": "1401275497066110977"
        }
    },
    {
        "data": {
            "conversation_id": "1400679343345397762",
            "id": "1400679343345397762",
            "edit_history_tweet_ids": [
                "1400679343345397762"
            ],
            "text": "From the very beginning of my #Python career, I've liked the shelve module.  Sometimes though, I wonder if I'm the only one."
        }
    },
    {
        "data": {
            "id": "1397766237023707136",
            "edit_history_tweet_ids": [
                "1397766237023707136"
            ],
            "conversation_id": "1397765939823714306",
            "text": "How does one design their code to make it as PyPy friendly as possible?"
        }
    },
    {
        "data": {
            "conversation_id": "1397765939823714306",
            "edit_history_tweet_ids": [
                "1397765939823714306"
            ],
            "id": "1397765939823714306",
            "text": "Are there any resources detailing which constructs work best with #PyPy ?\n\nWhich is better: a closure, an equivalent partial(), or an equivalent class?\n\nIs indexing preferred over iterators or vice versa?\n\nSpeed differences between globals, locals, instance vars, class vars, etc?"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1397633146791677954"
            ],
            "text": "#Python question: What is the correct type annotation for the return value of a class method?\n\nclass P:\n\n    @classmethod \n    def from_half(cls, x: int) -&gt; ???:\n        return cls(x * 2)\n\nclass C(P):\n    pass",
            "conversation_id": "1397633146791677954",
            "id": "1397633146791677954"
        }
    },
    {
        "data": {
            "id": "1396976883812773891",
            "text": "#Python tip: Add a count to str.replace to prevent too many substitutions:\n\n&gt;&gt;&gt; s = 'There is a flow in the flowchart'\n\n&gt;&gt;&gt; s.replace('flow', 'flaw')  # Too much!\n'There is a flaw in the flawchart'\n\n&gt;&gt;&gt; s.replace('flow', 'flaw', 1) # Just right.\n'There is a flaw in the flowchart'",
            "edit_history_tweet_ids": [
                "1396976883812773891"
            ],
            "conversation_id": "1396976883812773891"
        }
    },
    {
        "data": {
            "conversation_id": "1393733384573095936",
            "text": "#Python factlet: The int() function supports base conversions from base-2 to base-36 using 0-9A-Z.\n\n&gt;&gt;&gt; [int('11', base) for base in range(2, 37)]\n[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37]",
            "edit_history_tweet_ids": [
                "1393733384573095936"
            ],
            "id": "1393733384573095936"
        }
    },
    {
        "data": {
            "conversation_id": "1393331948286668800",
            "edit_history_tweet_ids": [
                "1393337066956541955"
            ],
            "id": "1393337066956541955",
            "text": "This intent of the problem is to come up with a way to exploit the known sort order.\n\nThe OP could have specified that the data elements are not hashable and only support ordering operations.\n\nAnd, further that this output is required to be sorted."
        }
    },
    {
        "data": {
            "conversation_id": "1393331948286668800",
            "id": "1393331948286668800",
            "edit_history_tweet_ids": [
                "1393331948286668800"
            ],
            "text": "#Python diversion:  Once in a while you get a good algorithmic question on StackOverflow. This one was fun.\n\nCompute the intersection of multiple sorted lists without using sets.  Ideally aim for O(n) time, minimal memory use, and a single pass over data.\n\nhttps://t.co/ta1RD4db6N"
        }
    },
    {
        "data": {
            "id": "1392565989993193472",
            "edit_history_tweet_ids": [
                "1392565989993193472"
            ],
            "text": "In the software context where I want to use it, Extensible is likely the correct word.\n\nBut to my ear it sounds and feels a little off.",
            "conversation_id": "1392177673581985792"
        }
    },
    {
        "data": {
            "text": "To emulate list(data)[-n : ], use this recipe:\n\ndef tail(n, iterable):\n    # tail(3, 'ABCDEFG') --&gt; E F G\n    return iter(collections.deque(iterable, maxlen=n))\n\nThis keeps no more than n items in memory.\n\nIt reads entire input and is not lazy. Don't use with infinite inputs.\n\n4/",
            "conversation_id": "1392560300952494083",
            "edit_history_tweet_ids": [
                "1392560303242547201"
            ],
            "id": "1392560303242547201"
        }
    },
    {
        "data": {
            "id": "1392560302504386562",
            "edit_history_tweet_ids": [
                "1392560302504386562"
            ],
            "text": "Performance notes:\n\nThe emulation still reads the entire input iterable; otherwise, there's no way to detect the endpoint.\n\nAlso, n elements are kept in memory by tee().\n\nIt works lazily and won't fail if the input happens to be infinite.\n\n3/",
            "conversation_id": "1392560300952494083"
        }
    },
    {
        "data": {
            "text": "Example:\n\n    &gt;&gt;&gt; data = (x**2 for x in range(10))\n    &gt;&gt;&gt; list(remove_last(data, 3))\n    [0, 1, 4, 9, 16, 25, 36]\n\nGives the same answer as:\n\n    &gt;&gt;&gt; data = (x**2 for x in range(10))\n    &gt;&gt;&gt; list(data)[ : -3]\n    [0, 1, 4, 9, 16, 25, 36]\n\n2/",
            "id": "1392560301736828929",
            "edit_history_tweet_ids": [
                "1392560301736828929"
            ],
            "conversation_id": "1392560300952494083"
        }
    },
    {
        "data": {
            "id": "1392560300952494083",
            "edit_history_tweet_ids": [
                "1392560300952494083"
            ],
            "conversation_id": "1392560300952494083",
            "text": "#Python tip:  Emulating negative slice offsets with iterators is awkward because the total length isn't known in advance.  But it is possible:\n\ndef remove_last(it, n):\n    # Like s[ : -n]\n    t1, t2 = tee(it, 2)\n    list(islice(t2, n))\n    return (x for x, y in zip(t1, t2)\n\n1/"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1392222825994354688"
            ],
            "text": "Extensible (adj):  That which can be extensed.",
            "id": "1392222825994354688",
            "conversation_id": "1392177673581985792"
        }
    },
    {
        "data": {
            "conversation_id": "1392177673581985792",
            "edit_history_tweet_ids": [
                "1392209046359314432"
            ],
            "id": "1392209046359314432",
            "text": "ISTM programmers have conflated the original meaning of these words, the Java EXTENDS keyword or writing EXTENSIONS for example.\n\nPossibly this arose because tenses, conjugations, and participles of TO EXTEND are plentiful, but there isn't a good verb form of Extensible."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1392203994819223553"
            ],
            "text": "Not to be confused with Expendable.  \ud83d\ude09",
            "conversation_id": "1392177673581985792",
            "id": "1392203994819223553"
        }
    },
    {
        "data": {
            "text": "With respect to software, do you think Extendible, Extensible, and Extendable are interchangeable synonyms?\n\nAre there situations where one makes more sense than another?",
            "id": "1392177673581985792",
            "edit_history_tweet_ids": [
                "1392177673581985792"
            ],
            "conversation_id": "1392177673581985792"
        }
    },
    {
        "data": {
            "conversation_id": "1391909286599544833",
            "edit_history_tweet_ids": [
                "1391909288235257856"
            ],
            "id": "1391909288235257856",
            "text": "Guido has said that it was a mistake for the += operator on lists to accept any iterable.  This is a common mistake:\n\n&gt;&gt;&gt; s = ['one', 'three']\n&gt;&gt;&gt; s += 'three'\n&gt;&gt;&gt; s\n['one', 'three', 't', 'h', 'r', 'e', 'e']\n\nIt should have been restricted to only take other lists."
        }
    },
    {
        "data": {
            "conversation_id": "1391909286599544833",
            "text": "s = [10, 20, 30]\n\ndef add_on(t):\n    s.extend(t)           # this works\n\ndef add_on(t):\n    s +=t           # this doesn't work\n\ndef add_on(t):\n    global s\n    s +=t           # this works",
            "edit_history_tweet_ids": [
                "1391909287400677377"
            ],
            "id": "1391909287400677377"
        }
    },
    {
        "data": {
            "conversation_id": "1391909286599544833",
            "edit_history_tweet_ids": [
                "1391909286599544833"
            ],
            "text": "#Python factlet:  The += operator on a list works about the same as the extend() method; however, the operator also makes an assignment back to the target variable.\n\n   s += t\n\nWorks like:\n\n   s.extend(t)\n   s = s\n\nDepending on the namespace for s, this can make a difference.",
            "id": "1391909286599544833"
        }
    },
    {
        "data": {
            "text": "Now with the same equipment devise a test to determine whether the gravity you feel is the result of being in a centrifuge.",
            "id": "1391499966036672512",
            "edit_history_tweet_ids": [
                "1391499966036672512"
            ],
            "conversation_id": "1391458376672894976"
        }
    },
    {
        "data": {
            "conversation_id": "1391458376672894976",
            "edit_history_tweet_ids": [
                "1391498891250438144"
            ],
            "id": "1391498891250438144",
            "text": "MacGyver pop quiz:   You wake up in a sealed room and notice that gravity seems \u201coff\u201d.  Given a stopwatch and a homemade pendulum of known length and unknown mass, compute a reasonably accurate estimate of the force of gravity."
        }
    },
    {
        "data": {
            "text": "Just finished Andy Weir's new book, \"Hail Mary.\"\n\nVerdict:  Definitely worth it!  \ud83d\ude04\n\nLike \"The Martian\", it's fast paced and full of science, engineering, and problem solving.\n\nFor maximum enjoyment, have a calculator at hand and check the math for yourself.",
            "id": "1391458376672894976",
            "edit_history_tweet_ids": [
                "1391458376672894976"
            ],
            "conversation_id": "1391458376672894976"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1389790630633611266"
            ],
            "text": "Just started reading Andy Weir's new book:  Hail Mary.\n\nOn page 5, he casually slipped in Euler's identity.  This is auspicious.",
            "conversation_id": "1389790630633611266",
            "id": "1389790630633611266"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1389278015406759938"
            ],
            "conversation_id": "1389278015406759938",
            "id": "1389278015406759938",
            "text": "#Python tip:  The list.insert() method can add elements one at a time, but slicing can more clearly and efficiently insert multiple elements at a time.\n\n&gt;&gt;&gt; s = ['three', 'four', 'five']\n&gt;&gt;&gt; s[0:0] = ['one', 'two']\n&gt;&gt;&gt; s\n['one', 'two', 'three', 'four', 'five']"
        }
    },
    {
        "data": {
            "id": "1388571764544851971",
            "text": "Reason behind #Python's str.split() API:\n\n\"People seem to mentally model field-splitting as a single concept even though more than one algorithm is involved.\"\n\nhttps://t.co/5DiGuJhD5G",
            "edit_history_tweet_ids": [
                "1388571764544851971"
            ],
            "conversation_id": "1388571764544851971"
        }
    },
    {
        "data": {
            "id": "1388234796447387648",
            "edit_history_tweet_ids": [
                "1388234796447387648"
            ],
            "conversation_id": "1388234795713404928",
            "text": "For non-dunder methods, people readily create bound methods without guilt:\n\n    seed = prng.seed\n    sorted(words, key=str.casefold)"
        }
    },
    {
        "data": {
            "conversation_id": "1388234795713404928",
            "id": "1388234795713404928",
            "edit_history_tweet_ids": [
                "1388234795713404928"
            ],
            "text": "#Python psychology quirk:  The dunder naming convention makes people feel icky when calling them directly.  This natural aversion steers people away from using them as bound methods:\n\n    map(parent.__getitem__, children)\n    fetch = data_stream.__next__"
        }
    },
    {
        "data": {
            "conversation_id": "1387910547648114688",
            "id": "1387910547648114688",
            "edit_history_tweet_ids": [
                "1387910547648114688"
            ],
            "text": "Computer experts on TV and Movies seem to magically know things.  You don't see them reading books, attending conferences, contributing to open source, debugging code, taking classes, working collaboratively, refactoring, or using StackOverflow."
        }
    },
    {
        "data": {
            "id": "1387166860190175232",
            "edit_history_tweet_ids": [
                "1387166860190175232"
            ],
            "conversation_id": "1387131523342635009",
            "text": "BTW, that code should be:\n\ndef shuffle(arr):\n    for i in reversed(range(1, len(arr))):\n        j = randrange(i + 1)\n        arr[i], arr[j] = arr[j], arr[i]\n\nI left-off the +1 in the earlier tweet."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1387161864346374145"
            ],
            "text": "#Python oddity:  super() treat doesn't treat descriptors all descriptors the same.  It will __get__() but not __set__ () and __delete__().\n\nhttps://t.co/ee38iFE05j",
            "id": "1387161864346374145",
            "conversation_id": "1387161864346374145"
        }
    },
    {
        "data": {
            "text": "Here's an alternative that runs left-to-right:\n\ndef shuffle(arr):\n    for i in range(1, len(arr)):\n        j = randrange(i + 1)\n        arr[i], arr[j] = arr[j], arr[i]",
            "id": "1387154699426488320",
            "edit_history_tweet_ids": [
                "1387154699426488320"
            ],
            "conversation_id": "1387131523342635009"
        }
    },
    {
        "data": {
            "conversation_id": "1387131523342635009",
            "id": "1387152418111066113",
            "edit_history_tweet_ids": [
                "1387152418111066113"
            ],
            "text": "https://t.co/MbisQnghA7"
        }
    },
    {
        "data": {
            "id": "1387131523342635009",
            "edit_history_tweet_ids": [
                "1387131523342635009"
            ],
            "conversation_id": "1387131523342635009",
            "text": "Algorithm question:   Does anyone know why the Fisher\u2013Yates shuffle is typically presented with a decreasing loop index?\n\ndef shuffle(arr):\n    for i in reversed(range(1, len(arr))):\n        j = randrange(i)\n        arr[i], arr[j] = arr[j], arr[i]\n\nThe reversed() isn't necessary."
        }
    },
    {
        "data": {
            "id": "1386503547890503682",
            "text": "Timings for:\n\n    s = {Wrecker() : i for i in range(n)}\n\n511 \u00b5s     # n = 100 \n44.8 ms    # n = 1,000\n4.34 s     # n = 10,000\n9 min 50s  # n = 100,000\n\nCompare with:\n\n    s = {object() : i for i in range(100000)}\n\nwhich only takes 17 ms.",
            "edit_history_tweet_ids": [
                "1386503547890503682"
            ],
            "conversation_id": "1386503546632249344"
        }
    },
    {
        "data": {
            "id": "1386503546632249344",
            "edit_history_tweet_ids": [
                "1386503546632249344"
            ],
            "conversation_id": "1386503546632249344",
            "text": "#Python factlet:  Here's an easy way to wreck hash table performance:\n    \nclass Wrecker:\n    def __eq__(self, other):\n        return False\n    def __hash__(self):\n        return 0"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1386464708593557506"
            ],
            "conversation_id": "1385694283114565635",
            "id": "1386464708593557506",
            "text": "Another recurring the theme is that whenever adults behave badly, the children suffer."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1385697860931362817"
            ],
            "text": "Even the morally depraved like Detective Miller have their limits for how much badness they are willing to be part of.",
            "id": "1385697860931362817",
            "conversation_id": "1385694283114565635"
        }
    },
    {
        "data": {
            "text": "At some point, all of the major characters have turned on their leaders.  James Holden wouldn't ignore a distress call. Fred Johnson and Bobbie Draper both turned on their respective militaries.  Amos is always willing to administer blunt force trauma but only for good guys :-)",
            "conversation_id": "1385694283114565635",
            "edit_history_tweet_ids": [
                "1385697860138659842"
            ],
            "id": "1385697860138659842"
        }
    },
    {
        "data": {
            "conversation_id": "1385694283114565635",
            "text": "Just finished Season 2 of The Expanse.\n\nAn interesting, relevant, and recurring moral theme is that it is not sufficient to be good at your job.  You must also figure-out whether the people you're working for are good guys or bad guys.",
            "edit_history_tweet_ids": [
                "1385694283114565635"
            ],
            "id": "1385694283114565635"
        }
    },
    {
        "data": {
            "conversation_id": "1385018981375889411",
            "edit_history_tweet_ids": [
                "1385295871638528002"
            ],
            "id": "1385295871638528002",
            "text": "A year ago, I wrote a PR for this but it didn't garner any interest\n\nhttps://t.co/UUdNdmrPhk"
        }
    },
    {
        "data": {
            "conversation_id": "1385018981375889411",
            "id": "1385295870548058112",
            "text": "Every example I can think of is a bit contrived.  Here's my latest attempt:\n\nmain_plan, backup_plan = sample(plans, k=2,\n    weights=probabilty_of_success)",
            "edit_history_tweet_ids": [
                "1385295870548058112"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1385295869390458881"
            ],
            "text": "So far, the only reasons to add it are:\n\n* numpy has it already\n* it is tricky to implement own your own\n   in a way that is efficient\n\nThe reasons against:\n\n* it seems to be a really confusing concept\n* no strong use cases have emerged\n* no one has ever asked for this",
            "conversation_id": "1385018981375889411",
            "id": "1385295869390458881"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1385295868220248064"
            ],
            "text": "What I'm trying to figure-out is whether anyone actually needs an API for weighted sampling without replacement.\n\nNote, we already have an API for \"urn\" problems:\n\n  sample(colors, k=2, counts=[7, 5, 3])\n\nBut that isn't same thing because the same color can be chosen twice.",
            "id": "1385295868220248064",
            "conversation_id": "1385018981375889411"
        }
    },
    {
        "data": {
            "conversation_id": "1385018981375889411",
            "id": "1385295866999676928",
            "edit_history_tweet_ids": [
                "1385295866999676928"
            ],
            "text": "The existing #Python sampling with replacement API:\n\n  choices(colors, k=2, weights=weights)\n\ndoes the same as this in #numpy:\n\n  np.random.choice(colors, 2, p=weights, replace=True)"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1385295865640734722"
            ],
            "conversation_id": "1385018981375889411",
            "id": "1385295865640734722",
            "text": "Given:\n   colors = ['red', 'green', 'blue']\n   weights = [0.5, 0.3, 0.2]\n\nThe proposed #Python sampling without replacement API:\n\n  sample(colors, k=2, weights=weights)\n\nwould do the same as this in #numpy:\n\n  np.random.choice(colors, 2, p=weights, replace=False)"
        }
    },
    {
        "data": {
            "conversation_id": "1385018981375889411",
            "id": "1385045021057961987",
            "text": "The \"weights\" parameter would have the same meaning as it does for random.choices(). It is the relative likelihood of being chosen.\n\nrandom.choices() makes selections with replacement.\n\nrandom.sample() makes selections without replacement.",
            "edit_history_tweet_ids": [
                "1385045021057961987"
            ]
        }
    },
    {
        "data": {
            "id": "1385018981375889411",
            "edit_history_tweet_ids": [
                "1385018981375889411"
            ],
            "conversation_id": "1385018981375889411",
            "text": "If #Python's random sampling without replacement had optional weights, what would you use it for?\n\nMy only example is choosing tributes for the hunger games.\n\n&gt;&gt;&gt; sample(['katniss', 'prim', 'gale', 'peeta'] , weights=[20, 1, 42, 10], k=2)\n['prim', 'peeta']"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1384525830471131137"
            ],
            "text": "#Python tip:  The \"counts\" argument for random.sample() makes it easy to model classic \u201curn problems\u201d where balls are chosen without replacement.\n\n&gt;&gt;&gt; sample(['white', 'blue', 'red'], counts=[8, 6, 9], k=6)\n['red', 'red', 'white', 'white', 'blue', 'red']\n\nhttps://t.co/Rpc06K8Gr2",
            "id": "1384525830471131137",
            "conversation_id": "1384525830471131137"
        }
    },
    {
        "data": {
            "conversation_id": "1382894553473052677",
            "edit_history_tweet_ids": [
                "1382894553473052677"
            ],
            "id": "1382894553473052677",
            "text": "#Python tip:  Fraction.limit_denominator() is useful for making rational approximations of real numbers:\n\n&gt;&gt;&gt; Fraction(pi).limit_denominator(10)\nFraction(22, 7)\n&gt;&gt;&gt; Fraction(pi).limit_denominator(10_000)\nFraction(355, 113)"
        }
    },
    {
        "data": {
            "id": "1382172793865834499",
            "text": "#Python news:  Next week, we'll reach 300,000 projects in the #PyPI package index.\n\nThat's up from 200,000 on 14 Oct 2019 and 100,000 on 4 Mar 2017.\n\nWhat is your prediction for when we'll reach 400,000? https://t.co/KeiSDCLc24",
            "edit_history_tweet_ids": [
                "1382172793865834499"
            ],
            "conversation_id": "1382172793865834499"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1380617138411425792"
            ],
            "id": "1380617138411425792",
            "text": "Probably, we should at least change the value of hash(math.nan) to not collide with hash(0).\n\n&gt;&gt;&gt; hash(math.nan) == hash(0)\nTrue",
            "conversation_id": "1380602207045787649"
        }
    },
    {
        "data": {
            "conversation_id": "1380602207045787649",
            "id": "1380602207783936004",
            "edit_history_tweet_ids": [
                "1380602207783936004"
            ],
            "text": "We could mitigate this issue by either:\n\n1) making the hash() of NaNs equal to their id()\n2) making NaNs into singletons\n\nHowever, both approaches have their downsides."
        }
    },
    {
        "data": {
            "id": "1380602207045787649",
            "edit_history_tweet_ids": [
                "1380602207045787649"
            ],
            "text": "#Python irritant:   Instances float('NaN') all have the same hash value but never compare as equal.\n\nThis causes catastrophic linear pileups in dict and set hash tables.\n\n&gt;&gt;&gt; nans = [float('NaN') for i in range(1000)]\n&gt;&gt;&gt; len(set(nans))\n1000\n&gt;&gt;&gt; len(set(map(hash, nans)))\n1",
            "conversation_id": "1380602207045787649"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1380240448606756865"
            ],
            "text": "#Python tip:  Database queries are especially fast if you copy the database into RAM:\n\nimport sqlite3\nsource = sqlite3.connect('main_database.db')\ndest = sqlite3.connect(':memory:')\nsource.backup(dest)\n\nhttps://t.co/ydIDVrAHqt",
            "conversation_id": "1380240448606756865",
            "id": "1380240448606756865"
        }
    },
    {
        "data": {
            "id": "1379520633244033025",
            "edit_history_tweet_ids": [
                "1379520633244033025"
            ],
            "conversation_id": "1379520630899449856",
            "text": "These API differences reflect the capabilities of the underlying implementations.\n\ndict() keeps keys in space-efficient sequence, so only right-side appends and pops are fast.\n\nOrderedDict uses a regular dict plus a doubly-linked list, the extra operations are fast.\n\n4/"
        }
    },
    {
        "data": {
            "id": "1379520632497442816",
            "edit_history_tweet_ids": [
                "1379520632497442816"
            ],
            "text": "OrderedDict can efficiently move entries to either end without a hash table update.\n\n&gt;&gt;&gt; d = OrderedDict(red=1, green=2, blue=3)\n\n&gt;&gt;&gt; d.move_to_end('green')\n&gt;&gt;&gt; list(d)\n['red', 'blue', 'green']\n\n&gt;&gt;&gt; d.move_to_end('green', last=False)\n&gt;&gt;&gt; list(d)\n['green', 'red', 'blue']\n\n3/",
            "conversation_id": "1379520630899449856"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1379520631692161026"
            ],
            "conversation_id": "1379520630899449856",
            "id": "1379520631692161026",
            "text": "In contrast, OrderedDict.popitem() supports both FIFO and LIFO extraction of key/value pairs.\n\n&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; d = OrderedDict(red=1, green=2, blue=3)\n\n&gt;&gt;&gt; d.popitem(last=False)  # FIFO\n('red', 1)\n\n&gt;&gt;&gt; d.popitem()  # LIFO\n('blue', 3)\n\n2/"
        }
    },
    {
        "data": {
            "conversation_id": "1379520630899449856",
            "edit_history_tweet_ids": [
                "1379520630899449856"
            ],
            "id": "1379520630899449856",
            "text": "#Python factlet:  The dict.popitem() method is guaranteed to remove key/value pairs in LIFO order.\n\n&gt;&gt;&gt; d = dict(red=1, green=2, blue=3)\n&gt;&gt;&gt; d.popitem()\n('blue', 3)\n&gt;&gt;&gt; d.popitem()\n('green', 2)\n&gt;&gt;&gt; d.popitem()\n('red', 1)\n\n1/"
        }
    },
    {
        "data": {
            "conversation_id": "1378783853087612931",
            "id": "1379222005598146560",
            "edit_history_tweet_ids": [
                "1379222005598146560"
            ],
            "text": "On my M1, deque.rotate() is twice as fast on my Mac with Intel silicon.  \n\nUsing Python3.9, a 500 step rotation of a 1000 element deque takes 138 nsec.\n\nThe throughput is 0.28 ns per object pointer.  Not bad!"
        }
    },
    {
        "data": {
            "conversation_id": "1379204180527607809",
            "id": "1379206836935516161",
            "edit_history_tweet_ids": [
                "1379206836935516161"
            ],
            "text": "This is comparable to @lemire recently discovering that mul and umulh are fused together.\n\nApple did a fine job with their new silicon."
        }
    },
    {
        "data": {
            "text": "Amazingly, the Apple M-1 chip fuses together division and modulo calculations.\n\nDivision has a single instruction.  Modulo requires an additional instruction.  But both computations run in the same total time.\n\nhttps://t.co/0Io6T3Nqa7",
            "conversation_id": "1379204180527607809",
            "edit_history_tweet_ids": [
                "1379204180527607809"
            ],
            "id": "1379204180527607809"
        }
    },
    {
        "data": {
            "conversation_id": "1378783853087612931",
            "id": "1378783853087612931",
            "edit_history_tweet_ids": [
                "1378783853087612931"
            ],
            "text": "#Python nerd happiness:  On the Apple M1, the inner loop for deque.rotate() moves 4 pointers at a time!\n\nLBB24_20:\n    ldpq0, q1, [x14, #-16]\n    stpq0, q1, [x13, #-16]\n    addx13, x13, #32\n    addx14, x14, #32\n    subsx15, x15, #4\n    b.neLBB24_20"
        }
    },
    {
        "data": {
            "conversation_id": "1378111105457815554",
            "edit_history_tweet_ids": [
                "1378111105457815554"
            ],
            "id": "1378111105457815554",
            "text": "Teaching tip for non-programmers:  Madlibs are a great way to explain #Python grammar constraints and what a SyntaxError means.\n\ndef \u00abvarname\u00bb():\n    return \u00abexpression\u00bb\n\nfor \u00abvarname\u00bb in \u00abiterable\u00bb:\n    if \u00abcond\u00bb:\n        \u00abvarname\u00bb = \u00abexpression\u00bb\n\nhttps://t.co/NwkcAnIS7v"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1377733692219555841"
            ],
            "text": "This is why user testing is important.\n\nThe problem being solved by the programmer may not reflect the actual problem as experienced by the user.\n\nA solution that is obvious to the person who wrote the feature may be opaque to user who has a different mental model.",
            "id": "1377733692219555841",
            "conversation_id": "1377733690676051970"
        }
    },
    {
        "data": {
            "conversation_id": "1377733690676051970",
            "edit_history_tweet_ids": [
                "1377733691451961344"
            ],
            "id": "1377733691451961344",
            "text": "Misfeatures:\n\n* It is opt-out rather than opt-in\n* No clean way to disable it.\n* It is unusual.\n* What to do isn't obvious.\n* A single click does nothing. \n* Triggers based on line count rather than line width (IDLE gets slow when wrapping long lines).\n* No re-squeeze option."
        }
    },
    {
        "data": {
            "text": "When teaching #Python with IDLE, my nemesis is a feature called the Squeezer.  Almost every week, it trips-up students and I have to show them how to disable it.\n\nA student doing homework types:\n&gt;&gt;&gt; help(str)\n\nThe next they day, they report, \"I couldn't see anything!\"\n\n1/",
            "id": "1377733690676051970",
            "edit_history_tweet_ids": [
                "1377733690676051970"
            ],
            "conversation_id": "1377733690676051970"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1375486230821888004"
            ],
            "text": "3/ The important underlying rule from #Python PEP 634 is:\n\nA match statement may have at most one irrefutable case block, and it must be last.\n\nhttps://t.co/F7mFNrU1Gg",
            "conversation_id": "1375486229160988677",
            "id": "1375486230821888004"
        }
    },
    {
        "data": {
            "conversation_id": "1375486229160988677",
            "id": "1375486230033362945",
            "text": "2/ #Python code example:\n\nmatch return_code:\n        case 200: ...\n        case 304: ...\ncase NOT_FOUND: ...\ncase _: raise ValueError\n\nSyntaxError: name capture 'NOT_FOUND' makes remaining patterns unreachable",
            "edit_history_tweet_ids": [
                "1375486230033362945"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1375486229160988677"
            ],
            "conversation_id": "1375486229160988677",
            "id": "1375486229160988677",
            "text": "1/ #Python 3.10 tip:  When pattern matching, include a default match with \"case _\".\n\nThen if someone mistakenly introduces a capture variable, a syntax error will be raised when the module is imported.\n\nIt also protects against unintentional fall through for unhandled cases."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1375237454018473984"
            ],
            "id": "1375237454018473984",
            "text": "5/ The lxml docs section title \"Elements are lists\" should expanded to say \"kinda, sorta, but not\" \ud83d\ude09\n\nhttps://t.co/K6yitxBonn",
            "conversation_id": "1375195718361620486"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1375217612758544384"
            ],
            "conversation_id": "1375217612758544384",
            "id": "1375217612758544384",
            "text": "The #Python super-considered-super video now has over 100,000 unique views.   The associated blog post is over a half million.\n\nThis seems to be an area of great interest. https://t.co/wssChWQLCd"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1375195720802729984"
            ],
            "text": "4/ Practical use of this knowledge:  Don't use random.shuffle() with lxml Element instances. \n\nInstead, either use Python's ElementTree or do the shuffling outside of the Element instance:\n\n    root[:] = sample(list(root), k=len(root))\n\nhttps://t.co/AWRKs3VqM1",
            "id": "1375195720802729984",
            "conversation_id": "1375195718361620486"
        }
    },
    {
        "data": {
            "conversation_id": "1375195718361620486",
            "edit_history_tweet_ids": [
                "1375195719955402753"
            ],
            "id": "1375195719955402753",
            "text": "3/ lxml's behavior is super surprising because it is so different from other mutable sequences like lists.\n\nHowever the #Python standard library ElementTree also surprised people because it didn't make a copy.  So, changes to root[0] would also show-up in root[1]."
        }
    },
    {
        "data": {
            "conversation_id": "1375195718361620486",
            "edit_history_tweet_ids": [
                "1375195719145902080"
            ],
            "id": "1375195719145902080",
            "text": "2/ #Python code:\n\nfrom lxml.etree import Element\n\nroot = Element('outer')\nroot.append(Element('zero'))\nroot.append(Element('one'))\nroot.append(Element('two'))\nroot[0] = root[1]\nprint([e.tag for e in root])\n\n# lxml prints: ['one', 'two']\n# ElementTree prints: ['one', 'one', 'two']"
        }
    },
    {
        "data": {
            "conversation_id": "1375195718361620486",
            "id": "1375195718361620486",
            "edit_history_tweet_ids": [
                "1375195718361620486"
            ],
            "text": "1/ TIL an essential difference between lxml and #Python's ElementTree:\n\n  elem[0] = elem[1]\n \nlxml will MOVE the element from position one to position zero, CHANGING the length of the outer element!?\n\nThe standard library is much more list like."
        }
    },
    {
        "data": {
            "conversation_id": "1374170505540816900",
            "id": "1374170505540816900",
            "edit_history_tweet_ids": [
                "1374170505540816900"
            ],
            "text": "UX complaint: more than one airline can't cope with my son and I having the same first and last names (the middle names are different).\n\nYet again, booking two separate reservations."
        }
    },
    {
        "data": {
            "id": "1373317619365814279",
            "edit_history_tweet_ids": [
                "1373317619365814279"
            ],
            "conversation_id": "1373315362062626823",
            "text": "BTW, if you're against the proposed short, fast form, it would be helpful to know why.\n\nIn your view, what makes the map(str, data) form better?"
        }
    },
    {
        "data": {
            "conversation_id": "1373315362062626823",
            "id": "1373315362863771655",
            "edit_history_tweet_ids": [
                "1373315362863771655"
            ],
            "text": "Besides being more compact, the second form can be made more efficient than the first.\n\nStill there isn't yet a consensus on whether to proceed.\n\nSee https://t.co/nJ6ctHZS3S"
        }
    },
    {
        "data": {
            "conversation_id": "1373315362062626823",
            "edit_history_tweet_ids": [
                "1373315362062626823"
            ],
            "text": "#Python user poll:  Would you like str.join() to work like print() and automatically coerce its arguments to strings?\n\nGiven:\n\n    data = [10, 20, 30, 40, 50]\n\nWhich do you prefer?",
            "id": "1373315362062626823"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1372376415195205635"
            ],
            "id": "1372376415195205635",
            "text": "Even worse anti-pattern:\n\n&gt;&gt;&gt; {} == {**{}}\nTrue\n\nYuck!",
            "conversation_id": "1372376414184296448"
        }
    },
    {
        "data": {
            "conversation_id": "1372376414184296448",
            "id": "1372376414184296448",
            "edit_history_tweet_ids": [
                "1372376414184296448"
            ],
            "text": "#Python anti-pattern:  you can create an empty set with generalized argument unpacking:\n\n&gt;&gt;&gt; set() == {*()}\nTrue\n\nBut I don't like it at all.\n\nUse set() instead.\n\nUnless you're in an obfuscated code contest \ud83d\ude09"
        }
    },
    {
        "data": {
            "text": "One part of the proposal may yet have a chance:\n\n   `x[*y]` including things like `x[a, *b, c]`\n\nThat part will likely be added to PEP 646, Variadic Generics.\n\nLike __class_getitem__(), that more modest proposal will be helpful for type annotations.\n\nhttps://t.co/VUkUCdaumk",
            "id": "1371609236765995009",
            "edit_history_tweet_ids": [
                "1371609236765995009"
            ],
            "conversation_id": "1371606366331150336"
        }
    },
    {
        "data": {
            "conversation_id": "1371606366331150336",
            "id": "1371606366331150336",
            "edit_history_tweet_ids": [
                "1371606366331150336"
            ],
            "text": "#Python news:  PEP 637 was rejected by the Steering Council today, so __getitem__, __setitem__, and __delitem__ will not be adding support for keyword arguments.\n\nYou square brackets are safe \ud83d\ude09\n\nhttps://t.co/3iIezp6MIJ"
        }
    },
    {
        "data": {
            "conversation_id": "1371232788762877952",
            "edit_history_tweet_ids": [
                "1371251901476392962"
            ],
            "id": "1371251901476392962",
            "attachments": {
                "media_keys": [
                    "3_1371251895742828547",
                    "3_1371251895730249729"
                ]
            },
            "text": "Histograms for the first, second, and third smallest: https://t.co/ly18elYDVt"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1371251895742828547",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/EweqVX9VEAMWHxD.jpg"
                },
                {
                    "media_key": "3_1371251895730249729",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/EweqVX6VIAEdfeL.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1371232788762877952",
            "id": "1371251128004841473",
            "edit_history_tweet_ids": [
                "1371251128004841473"
            ],
            "attachments": {
                "media_keys": [
                    "3_1371251123953098752"
                ]
            },
            "text": "Today\u2019s results rolling five 20 sided dice and tracking the first, second, and third smallest.\n\nBox and whisker plots with black for actual and red for expected: https://t.co/t8F4ub7EL0"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1371251123953098752",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/Ewepoc0UYAAOaqj.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "id": "1371232788762877952",
            "text": "Today's data science lesson for my son.  IQR interquartile ranges.\n\n#Python one-liners:\n\n&gt;&gt;&gt; quantiles([4, 4, 10, 11, 15, 7, 14, 12, 6])\n&gt;&gt;&gt; [5.0, 10.0, 13.0]\n\n&gt;&gt;&gt; quantiles(Counter({7:1, 9:2, 10:3, 11:1, 12:2, 14:1}).elements())\n[9.0, 10.0, 12.0]\n\nhttps://t.co/y1nL4vcXAn",
            "edit_history_tweet_ids": [
                "1371232788762877952"
            ],
            "conversation_id": "1371232788762877952"
        }
    },
    {
        "data": {
            "conversation_id": "1369774921010667520",
            "id": "1369798248639041539",
            "edit_history_tweet_ids": [
                "1369798248639041539"
            ],
            "text": "It's pretty cool to hear a nine year old properly using the terms \"statistical anomaly\" and \"reversion to the mean\".  \n\n\ud83d\ude00"
        }
    },
    {
        "data": {
            "conversation_id": "1369774921010667520",
            "id": "1369795378543951875",
            "edit_history_tweet_ids": [
                "1369795378543951875"
            ],
            "text": "Here's the output:\n\n{1: 2234,\n 2: 6135,\n 3: 8594,\n 4: 9915,\n 5: 9995,\n 6: 10399,\n 7: 9477,\n 8: 8967,\n 9: 8088,\n 10: 7068,\n 11: 5993,\n 12: 4577,\n 13: 3271,\n 14: 2428,\n 15: 1394,\n 16: 855,\n 17: 395,\n 18: 178,\n 19: 35,\n 20: 2}"
        }
    },
    {
        "data": {
            "id": "1369795262051360769",
            "edit_history_tweet_ids": [
                "1369795262051360769"
            ],
            "conversation_id": "1369774921010667520",
            "text": "Here are the imports:\n\nfrom random import choices\nfrom collections import Counter\nfrom pprint import pprint"
        }
    },
    {
        "data": {
            "conversation_id": "1369774921010667520",
            "attachments": {
                "media_keys": [
                    "3_1369794989438341123"
                ]
            },
            "text": "Just finished.  Here\u2019s the final tally : https://t.co/ObJkX6ZoDO",
            "edit_history_tweet_ids": [
                "1369795004776935425"
            ],
            "id": "1369795004776935425"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1369794989438341123",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/EwJ9SRCVEAM_dIj.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "text": "Running the histogram in #Python is faster but less satisfying than by hand.\n\nd20 = tuple(range(1, 21))\nwidth = 5\norder = 1\nn = 100_000\n\ndata = choices(d20, k = n + width - 1)\nhistogram = Counter(sorted(data[i: i+width])[order] for i in range(n))\npprint(dict(Counter(histogram)))",
            "conversation_id": "1369774921010667520",
            "edit_history_tweet_ids": [
                "1369781121462902786"
            ],
            "id": "1369781121462902786"
        }
    },
    {
        "data": {
            "id": "1369774921010667520",
            "edit_history_tweet_ids": [
                "1369774921010667520"
            ],
            "attachments": {
                "media_keys": [
                    "3_1369774914027220993"
                ]
            },
            "text": "Working with my 3rd grader on beta distributions.  This is his histogram for the second lowest of five 20-sided dice. https://t.co/94RIJQMBOg",
            "conversation_id": "1369774921010667520"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1369774914027220993",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/EwJrBuTVcAEmZIH.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1368997898382315520",
            "edit_history_tweet_ids": [
                "1368997898382315520"
            ],
            "text": "#Python tip:  Ways to call methods on integers without tokenizing as a float:\n\n&gt;&gt;&gt; 23 .bit_length()   # space after the digits\n5\n&gt;&gt;&gt; (23).bit_length()   # parens\n5\n&gt;&gt;&gt; x=23; x.bit_length()  # variable\n5\n&gt;&gt;&gt; getattr(23, 'bit_length')()  # the hard way ;-)\n5",
            "id": "1368997898382315520"
        }
    },
    {
        "data": {
            "conversation_id": "1367657741838213121",
            "id": "1367657741838213121",
            "text": "ISTM the number and duration of ads on YouTube is being dialed-up to an intolerable level, presumably in an effort to drive users to paying for premium access ($18 per month for the family plan).",
            "edit_history_tweet_ids": [
                "1367657741838213121"
            ]
        }
    },
    {
        "data": {
            "id": "1367195786522419202",
            "text": "7/ It isn't perfect.  Subclassers have to make their own decisions about __slots__.  Harder to inspect with vars().  Doesn't work with cached_property(), you have the nest property() and cache() instead.\n\nBut mostly, I like __slots__.  \ud83d\ude00",
            "edit_history_tweet_ids": [
                "1367195786522419202"
            ],
            "conversation_id": "1367195779954143232"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1367195785599721472"
            ],
            "conversation_id": "1367195779954143232",
            "id": "1367195785599721472",
            "text": "6/ You can turn-off weak-referencing just by omitting '__weakref__' from the __slots__ list."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1367195784572067846"
            ],
            "text": "5/ There are also speed and space benefits.\n\nPer Tools/scripts/var_access_benchmark.py:\n\n  17.7 nsread_instancevar\n  11.1 nsread_instancevar_slots\n\nSize for instances of Point as reported by sys.getsizeof(p):\n\n  152 bytes without __slots__\n   48 bytes without __slots__",
            "conversation_id": "1367195779954143232",
            "id": "1367195784572067846"
        }
    },
    {
        "data": {
            "text": "4/ Just like classes in compiled OOP languages, __slots__ makes code clearer by listing all instance variables at the top.\n  \nIn Lib/fractions.py, the structure of the Fraction class is immediately apparent:\n\nclass Fraction:\n    __slots__ = ('_numerator', '_denominator')",
            "conversation_id": "1367195779954143232",
            "edit_history_tweet_ids": [
                "1367195783540264960"
            ],
            "id": "1367195783540264960"
        }
    },
    {
        "data": {
            "conversation_id": "1367195779954143232",
            "edit_history_tweet_ids": [
                "1367195782126960642"
            ],
            "id": "1367195782126960642",
            "text": "3/ Create immutable objects with read-only properties.\n\nclass Point:\n  __slots__ = ('_x', '_y')\n\n  def __init__(self, x, y):\n      self._x = x\n      self._y = y\n\n  @property\n  def x(self):\n      return self._x\n\n  @property\n  def y(self):\n      return self._y\n\n  def hypot(self):"
        }
    },
    {
        "data": {
            "id": "1367195780855918593",
            "text": "2/  Immediately detects misspelled attribute assignments.\n\nclass Vehicle:\n    __slots__ = ('id_number', 'make', 'model')\n\n&gt;&gt;&gt; auto = Vehicle()\n&gt;&gt;&gt; https://t.co/RJ4FsYVVkK_nubmer = 'VYE483814LQEX'\n    ...\nAttributeError: 'Vehicle' object has no attribute 'id_nubmer'",
            "edit_history_tweet_ids": [
                "1367195780855918593"
            ],
            "conversation_id": "1367195779954143232"
        }
    },
    {
        "data": {
            "text": "1/  Controversial #Python opinion:  I really like __slots__.\n\n\ud83d\ude0f",
            "id": "1367195779954143232",
            "edit_history_tweet_ids": [
                "1367195779954143232"
            ],
            "conversation_id": "1367195779954143232"
        }
    },
    {
        "data": {
            "id": "1366805959155224577",
            "edit_history_tweet_ids": [
                "1366805959155224577"
            ],
            "conversation_id": "1366805959155224577",
            "text": "#Python 3.10 tip:  There is a new way to explicitly declare type aliases:\n \n   from typing import TypeAlias \n   Timestamp: TypeAlias = float\n\nFormerly, we just wrote:\n\n   Timestamp = float\n\nBut that was challenging to reliably identify as a type alias.\n\nhttps://t.co/8t7bDYOlLQ"
        }
    },
    {
        "data": {
            "text": "#Python has a new alpha release.  This is you big chance to get ahead of the game and experiment with pattern matching.\n\nGo get it! https://t.co/kHnXnnlZvP",
            "id": "1366513514601275392",
            "edit_history_tweet_ids": [
                "1366513514601275392"
            ],
            "conversation_id": "1366513514601275392"
        }
    },
    {
        "data": {
            "id": "1366136857939992578",
            "edit_history_tweet_ids": [
                "1366136857939992578"
            ],
            "conversation_id": "1366136856962736134",
            "text": "Mostly, I can't think of a strong reason to do this, but there are some minor benefits:\n\n* Hide private attributes from vars().\n* Speed-up private attribute reads and writes.\n* Make required private attributes undeleteable.\n* Preclude an instance from being weakly referenced."
        }
    },
    {
        "data": {
            "conversation_id": "1366136856962736134",
            "id": "1366136856962736134",
            "edit_history_tweet_ids": [
                "1366136856962736134"
            ],
            "text": "Interestingly, #Python allows '__dict__' in __slots__ and it works.\n\nclass C:\n    __slots__ = ['_x', '__dict__']\n    def __init__(self, x, y):\n        self._x = x\n        self.y = y\n\n&gt;&gt;&gt; c = C(4, 6)\n&gt;&gt;&gt; vars(c)\n{'y': 6}"
        }
    },
    {
        "data": {
            "text": "Welp, after one year of lockdown, today was the day it finally happened.  I left my microphone unmuted during a 10 minute break in a #Python training course.\n\nSo now a whole class heard me sing Willie Nelson's, \u201dGood hearted woman\u201d to my wife. \ud83d\ude32\n\n#lockdownfail #hotmike",
            "conversation_id": "1365465916436140032",
            "edit_history_tweet_ids": [
                "1365465916436140032"
            ],
            "id": "1365465916436140032"
        }
    },
    {
        "data": {
            "id": "1364794072263626752",
            "edit_history_tweet_ids": [
                "1364794072263626752"
            ],
            "conversation_id": "1364794069222707201",
            "text": "BTW, just because I announce these event doesn't mean I had any hand in proposing or approving these changes.\n\nIOW, don't shoot the messenger \ud83d\ude09"
        }
    },
    {
        "data": {
            "id": "1364794071240249346",
            "edit_history_tweet_ids": [
                "1364794071240249346"
            ],
            "conversation_id": "1364794069222707201",
            "text": "\u201cThe teacher will now show some practical real world examples, explaining the semantics of the feature in the shown library. At the time of writing these examples do not exist, \u2026\u201d"
        }
    },
    {
        "data": {
            "id": "1364794070246125570",
            "edit_history_tweet_ids": [
                "1364794070246125570"
            ],
            "conversation_id": "1364794069222707201",
            "text": "Other examples in the PEP:\n\n&gt;&gt;&gt; grid_position[x=3, y=5, z=8]\n&gt;&gt;&gt; rain_amount[time=0:12, location=location]\n&gt;&gt;&gt; matrix[row=20, col=40]\n&gt;&gt;&gt; ds[\"empty\"][lon=1:5, lat=6:] = 10\n\ndef function(value: MyType[T=int]):\n    \u2026\n\ndef __getitem__(self, index, *, direction='north'):\n    \u2026"
        }
    },
    {
        "data": {
            "conversation_id": "1364794069222707201",
            "edit_history_tweet_ids": [
                "1364794069222707201"
            ],
            "id": "1364794069222707201",
            "text": "In #Python's near future, indexing will support keyword arguments.\n\nThese will be valid:\n\n&gt;&gt;&gt; val = x[1, 2, a=3, b=4]  # getitem\n&gt;&gt;&gt; val = x[*(1, 2), **{a=3, b=4}] # getitem\n&gt;&gt;&gt; x[1, 2, a=3, b=4] = val  # setitem\n&gt;&gt;&gt; del x[1, 2, a=3, b=4]    # delitem\n\nhttps://t.co/3iIezp6MIJ"
        }
    },
    {
        "data": {
            "conversation_id": "1364083019414298624",
            "edit_history_tweet_ids": [
                "1364083020571975685"
            ],
            "id": "1364083020571975685",
            "text": "A single ExceptionGroup can cause several except* clauses to execute, but each such clause executes at most once (for all matching exceptions from the group) and each exception is either handled by exactly one clause (the first one that matches its type) or is reraised at the end"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1364083019414298624"
            ],
            "id": "1364083019414298624",
            "text": "In #Python's near future, you can raise groups of exceptions at a time.  A new grammar feature, except*, will allow multiple except clauses to match and execute.\n\nhttps://t.co/n4m9z5wKbR",
            "conversation_id": "1364083019414298624"
        }
    },
    {
        "data": {
            "conversation_id": "1363654613933547524",
            "text": "\u201cI like to think\n(it has to be!)\nof a cybernetic ecology\nwhere we are free of our labors\nand joined back to nature,\nreturned to our mammal\nbrothers and sisters,\nand all watched over\nby machines of loving grace.\u201d\n\nhttps://t.co/pq1WkzWkNI",
            "edit_history_tweet_ids": [
                "1363654613933547524"
            ],
            "id": "1363654613933547524"
        }
    },
    {
        "data": {
            "conversation_id": "1361780585635536897",
            "id": "1361780586570948609",
            "edit_history_tweet_ids": [
                "1361780586570948609"
            ],
            "text": "x \u27fc assign x = subject\n'x' \u27fc test subject == 'x'\nx.y \u27fc test subject == x.y\nx() \u27fc test isinstance(subject, x)\n{'x': 'y'} \u27fc test isinstance(subject, Mapping) and subject.get('x') == 'y'\n['x'] \u27fc test isinstance(subject, Sequence) and len(subject) == 1 and subject[0] == 'x'"
        }
    },
    {
        "data": {
            "conversation_id": "1361780585635536897",
            "text": "Reading #Python's new match-case requires two key insights:\n\n\u2022 Nothing in a case clause behaves as it does elsewhere. In particular, expressions don't evaluate.\n\n\u2022 Pattern matching is driven entirely by syntax.\n\n(1 of 2)",
            "edit_history_tweet_ids": [
                "1361780585635536897"
            ],
            "id": "1361780585635536897"
        }
    },
    {
        "data": {
            "conversation_id": "1360675588382412800",
            "edit_history_tweet_ids": [
                "1360675588382412800"
            ],
            "text": "My advice on learning new #Python features:   Don't approach it from the \"I like it\" or \"I don't like it\" point of view. Once approved, it is just a fact of life, neither good nor bad.\n\nLearn it deeply and see where it fits or doesn't fit in your life. Then use as needed. \ud83d\ude42",
            "id": "1360675588382412800"
        }
    },
    {
        "data": {
            "conversation_id": "1360661368777568261",
            "edit_history_tweet_ids": [
                "1360661368777568261"
            ],
            "id": "1360661368777568261",
            "text": "Here's a worked out example of #Python's new structural pattern matching:\n\nhttps://t.co/DaFkJgPSjY"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1360395091458682883"
            ],
            "conversation_id": "1360395090477285377",
            "id": "1360395091458682883",
            "text": "I expect that syntax highlighters will need to get a little smarter to handle this.\n\nThis choice was necessity because \"case\" and \"match\" are both likely to already be used as variable or function names.  Making them keywords would break code.\n\n2/"
        }
    },
    {
        "data": {
            "conversation_id": "1360395090477285377",
            "id": "1360395090477285377",
            "text": "#Python PEP 634 introduces a new grammar concept called soft keywords.\n\n \u201cThe match and case keywords are soft keywords, i.e. they are not reserved words in other grammatical contexts (including at the start of a line if there is no colon where expected).\u201d\n\n1/",
            "edit_history_tweet_ids": [
                "1360395090477285377"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1360098079135858689",
            "attachments": {
                "media_keys": [
                    "3_1360098061490343938"
                ]
            },
            "text": "Only a little progress today on Chapter 2 of The Haskell School of Music.\n\nLearning a new language is fun but vacation presents compelling distractions like boogie boarding with my son. https://t.co/3LdnboNlIz",
            "edit_history_tweet_ids": [
                "1360098079135858689"
            ],
            "id": "1360098079135858689"
        },
        "includes": {
            "media": [
                {
                    "media_key": "3_1360098061490343938",
                    "type": "photo",
                    "url": "https://pbs.twimg.com/media/EuAJ-xbUUAI3XEF.jpg"
                }
            ]
        }
    },
    {
        "data": {
            "text": "Structural Pattern Matching is coming to #Python.\n\nThe best way to learn about it is to reading the adventure game tutorial.\n\nhttps://t.co/dtKR64mHJY",
            "id": "1359966467328888834",
            "edit_history_tweet_ids": [
                "1359966467328888834"
            ],
            "conversation_id": "1359966467328888834"
        }
    },
    {
        "data": {
            "conversation_id": "1359624991868817409",
            "edit_history_tweet_ids": [
                "1359624991868817409"
            ],
            "id": "1359624991868817409",
            "text": "Am reading The Haskell School of Music while on vacation.   As of Chapter 1, it looks beautiful. Already we have a short function to harmonize a melody."
        }
    },
    {
        "data": {
            "id": "1358469668990644225",
            "edit_history_tweet_ids": [
                "1358469668990644225"
            ],
            "conversation_id": "1358469667627560961",
            "text": "Of course, \"continue\" and \"break\" only make sense inside a loop:\n\nSyntaxError: 'continue' not properly in loop\nSyntaxError: 'break' outside loop\n\n3/"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1358469668235661312"
            ],
            "text": "The related error messages are:\n\nSyntaxError: 'return' outside function\nSyntaxError: 'yield' outside function\nSyntaxError: no binding for nonlocal 'x' found\nSyntaxError: import * only allowed at module level\nSyntaxError: nonlocal declaration not allowed at module level\n\n2/",
            "conversation_id": "1358469667627560961",
            "id": "1358469668235661312"
        }
    },
    {
        "data": {
            "id": "1358469667627560961",
            "text": "#Python factlets:   The \"return\" and \"yield\" keywords can only be used inside functions.  The \"nonlocal\" keyword can only be used in a nested scope.  In contract, a star import can only be used at the module level.\n\n1/",
            "edit_history_tweet_ids": [
                "1358469667627560961"
            ],
            "conversation_id": "1358469667627560961"
        }
    },
    {
        "data": {
            "conversation_id": "1357478486647005187",
            "id": "1357535423417839617",
            "edit_history_tweet_ids": [
                "1357535423417839617"
            ],
            "text": "Also, imports are now faster for modules that have type annotations.\n\nThe annotations are initially loaded as strings and only evaluated later if needed.\n\nThe only downside is that it easy to forget to make the relevant typing imports."
        }
    },
    {
        "data": {
            "conversation_id": "1357478486647005187",
            "id": "1357526513315270659",
            "edit_history_tweet_ids": [
                "1357526513315270659"
            ],
            "text": "Here are the timings:\n\nPython 3.9.1\n  14.3 nsread_instancevar\n  12.4 nsread_instancevar_slots\n\nPython 3.10.0a5\n  10.0 nsread_instancevar\n   6.5 nsread_instancevar_slots"
        }
    },
    {
        "data": {
            "conversation_id": "1357478486647005187",
            "id": "1357504860309000192",
            "edit_history_tweet_ids": [
                "1357504860309000192"
            ],
            "text": "Also, I'm running Python on the build targeted for Apple Silicon.  The M1 chip gives another 1.5x to 1.7x speed-up.\n\nThat work was mostly done by Ronald Oussoren and Ned Deily with package specific contributions by people like Stefan Krah."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1357478487364231169"
            ],
            "id": "1357478487364231169",
            "text": "This work was mostly done by Pablo, Yury, and Guido.",
            "conversation_id": "1357478486647005187"
        }
    },
    {
        "data": {
            "id": "1357478486647005187",
            "text": "#Python optimization news:  Inline caching has been a huge success. In 3.9, access to builtins and globals had sped-up considerably.  In 3.10, regular attribute access and access to __slots__ are also faster.   Most everyday Python programs will benefit.  This is a huge win.",
            "edit_history_tweet_ids": [
                "1357478486647005187"
            ],
            "conversation_id": "1357478486647005187"
        }
    },
    {
        "data": {
            "id": "1354853388207329280",
            "edit_history_tweet_ids": [
                "1354853388207329280"
            ],
            "text": "Be thankful that you don't have to trim character sets using regular expressions:\n\n&gt;&gt;&gt; s = 'massachusetts'\n&gt;&gt;&gt; s.strip('stam')\n'chuse'\n&gt;&gt;&gt; https://t.co/wyz8py7yAs('^[stam]*(.*?)[stam]*$', s).group(1)\n'chuse'\n\n2/",
            "conversation_id": "1354853387490086913"
        }
    },
    {
        "data": {
            "id": "1354853387490086913",
            "text": "#Python tip:  The argument to lstrip() is a set of leading characters to be removed as many times as they occur:\n\n&gt;&gt;&gt; s = 'mississippi'\n&gt;&gt;&gt; s.lstrip('mis')\n'ppi'\n\nA more common need is to remove an exact match:\n\n&gt;&gt;&gt; s.removeprefix('mis')\n'sissippi'\n\nThis method is new in 3.9\n\n1/",
            "edit_history_tweet_ids": [
                "1354853387490086913"
            ],
            "conversation_id": "1354853387490086913"
        }
    },
    {
        "data": {
            "conversation_id": "1352745819057786881",
            "id": "1352868209003646976",
            "edit_history_tweet_ids": [
                "1352868209003646976"
            ],
            "text": "Dave's five day course really helped.  @dabeaz\n\nMost of the other participants has also reported that their previous efforts had only gotten part way through the book before being overwhelmed by the enormity of it."
        }
    },
    {
        "data": {
            "conversation_id": "1352745819057786881",
            "id": "1352745819057786881",
            "edit_history_tweet_ids": [
                "1352745819057786881"
            ],
            "text": "For the last month, I've been working through the book: Structure and Interpretation of Computer Programs.  \n\nMy goodness, it gets tedious. Even with help from @dabeaz, I still have half of Chapter 5 to go (and a few parts I skipped in Chapters 3 and 4)."
        }
    },
    {
        "data": {
            "conversation_id": "1351964420742606849",
            "text": "\"The new dawn balloons as we free it.\n\nFor there is always light, if only we\u2019re brave enough to see it.\n\nIf only we\u2019re brave enough to be it.\"",
            "edit_history_tweet_ids": [
                "1352128594097553409"
            ],
            "id": "1352128594097553409"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1352128593355132928"
            ],
            "text": "\"And so we lift our gaze, not to what stands between us, but what stands before us.\n\nWe close the divide because we know to put our future first, we must first put our differences aside.\"",
            "conversation_id": "1351964420742606849",
            "id": "1352128593355132928"
        }
    },
    {
        "data": {
            "conversation_id": "1351964420742606849",
            "id": "1352128592717598726",
            "text": "\"And, yes, we are far from polished, far from pristine, but that doesn\u2019t mean we are striving to form a union that is perfect.\"",
            "edit_history_tweet_ids": [
                "1352128592717598726"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1352018456401440769",
            "id": "1352021890957627392",
            "text": "10/ That one is also simpler when the constraints are relaxed:\n\n&gt;&gt;&gt; fib = lambda n: n if n &lt; 2 else (fib(n - 1) + fib(n - 2))\n&gt;&gt;&gt; fib(8)\n21\n\nThis should give you some appreciation for the ability to have free variables and the ability to make assignments :-)",
            "edit_history_tweet_ids": [
                "1352021890957627392"
            ]
        }
    },
    {
        "data": {
            "text": "9/ BONUS: Here is the same technique applied to the fibonacci function:\n\n&gt;&gt;&gt; (\n    lambda n: (lambda fib: fib(n, fib))(\n        lambda n, inner: n if n &lt; 2 else (inner(n - 1, inner) + inner(n - 2, inner))\n    )\n)(8)\n21",
            "id": "1352021890148171777",
            "edit_history_tweet_ids": [
                "1352021890148171777"
            ],
            "conversation_id": "1352018456401440769"
        }
    },
    {
        "data": {
            "conversation_id": "1352018456401440769",
            "id": "1352018463024242688",
            "edit_history_tweet_ids": [
                "1352018463024242688"
            ],
            "text": "8/ Life is much simpler if we allow a free variable and the ability to make an assignment in the enclosing environment:\n\n    fact = lambda n: 1 if n==0 else n * fact(n - 1)\n    fact(5)"
        }
    },
    {
        "data": {
            "id": "1352018461656903682",
            "edit_history_tweet_ids": [
                "1352018461656903682"
            ],
            "conversation_id": "1352018456401440769",
            "text": "7/ The three level combinator shows how powerfully expressive lambdas can be.  This is its principal theoretical significance.\n\nHowever, it's too awkward to use in practice.\n\nDropping some of the constraints leads us to a more practical, efficient, and understandable solution"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1352018460755181568"
            ],
            "id": "1352018460755181568",
            "text": "6/ The middle level lambda has one free variable \"n\".\n\nWe close this off with an outer lambda that uses \"n\" as a formal parameter:\n\n    lambda n: middle\n\nNow, we run the three nested lambdas, passing in a value whose factorial we want to compute:\n\n    outer(5)",
            "conversation_id": "1352018456401440769"
        }
    },
    {
        "data": {
            "id": "1352018459899564033",
            "edit_history_tweet_ids": [
                "1352018459899564033"
            ],
            "conversation_id": "1352018456401440769",
            "text": "5/ Steps for:\n\n    (lambda fact: fact(n, fact))(inner)\n\n1) The formal parameter \"fact\" is bound to the argument \"inner\".\n\n2) The body of this middle level lambda calls the inner function AND passes in a reference to inner function."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1352018459027095552"
            ],
            "id": "1352018459027095552",
            "text": "4/ Now we need to give the function a name to let us call it and pass it in as an argument at the same time.\n\nWith lambdas, we can name a function by passing it into another function which binds it to the formal parameters:\n\n    lambda fact: fact(n, fact))",
            "conversation_id": "1352018456401440769"
        }
    },
    {
        "data": {
            "conversation_id": "1352018456401440769",
            "text": "3/ To get around this limitation, we create an inner function where we can pass in both the variable n and a reference to the function itself:\n\nlambda n, inner: 1 if n == 0 else (n * inner(n - 1, inner)",
            "edit_history_tweet_ids": [
                "1352018458188255232"
            ],
            "id": "1352018458188255232"
        }
    },
    {
        "data": {
            "conversation_id": "1352018456401440769",
            "edit_history_tweet_ids": [
                "1352018457315868672"
            ],
            "id": "1352018457315868672",
            "text": "2/ A combinator is a closed lambda expression.  This means that it has no free variables.\n\nThat creates a challenge for recursion because the function body has no direct way to refer to the definition of the function."
        }
    },
    {
        "data": {
            "id": "1352018456401440769",
            "edit_history_tweet_ids": [
                "1352018456401440769"
            ],
            "text": "1/ Writing a recursive combinator version of factorial in #Python is a real brain-teaser:\n\n&gt;&gt;&gt; (\n    lambda n: (lambda fact: fact(n, fact))(\n        lambda n, inner: 1 if n == 0 else (n * inner(n - 1, inner))\n    )\n)(5)\n120",
            "conversation_id": "1352018456401440769"
        }
    },
    {
        "data": {
            "conversation_id": "1351964420742606849",
            "id": "1351964420742606849",
            "edit_history_tweet_ids": [
                "1351964420742606849"
            ],
            "text": "The youth laureate Amanda Gorman was amazing.\n\nWith this auspicious inauguration, I am full of hope."
        }
    },
    {
        "data": {
            "text": "After the decimal place, a common convention is to put digits in groups of five:\n\n3.14159_26535_89793_23846\n\nThe statistics module follows this convention:\n\nhttps://t.co/rLsvfbv9GM\n\n3/",
            "conversation_id": "1351629691631796224",
            "edit_history_tweet_ids": [
                "1351629692961316866"
            ],
            "id": "1351629692961316866"
        }
    },
    {
        "data": {
            "id": "1351629692332249090",
            "text": "European style takes more effort\n\n&gt;&gt;&gt; x = 1_234_567.89\n&gt;&gt;&gt; f'{x:_.2f}'.replace('.', ',').replace('_', '.')\n'1.234.567,89'\n\n/2",
            "edit_history_tweet_ids": [
                "1351629692332249090"
            ],
            "conversation_id": "1351629691631796224"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1351629691631796224"
            ],
            "id": "1351629691631796224",
            "text": "#Python tip:  Hard-coded constants should use the optional underscore as a thousands separator:\n\n&gt;&gt;&gt; x = 1_234_567\n\nAlso, you can output numbers in that format:\n\n&gt;&gt;&gt; f'{x:_d}'\n'1_234_567'\n\nOr with commas:\n\n&gt;&gt;&gt; f'{x:,d}'\n'1,234,567'\n\n1/",
            "conversation_id": "1351629691631796224"
        }
    },
    {
        "data": {
            "conversation_id": "1351256859680800770",
            "edit_history_tweet_ids": [
                "1351256859680800770"
            ],
            "text": "Given an attribute name like \"load_id\", do you also expect to see \"load_ego\" and \"load_superego\"?\n\n\ud83d\ude0f",
            "id": "1351256859680800770"
        }
    },
    {
        "data": {
            "text": "I believe the primary use case for bit_count() is in computing Hamming Distance:\n\nhttps://t.co/sLZXo0J93j\n\n4/",
            "id": "1350191654485934081",
            "edit_history_tweet_ids": [
                "1350191654485934081"
            ],
            "conversation_id": "1350185890073640960"
        }
    },
    {
        "data": {
            "text": "I suppose you could use it to make a Galton Board demo.\n\nfrom collections import Counter\nfrom random import getrandbits\n\ngalton = Counter(getrandbits(20).bit_count() for i in range(500))\nfor i in range(21):\n    print(f'{i:2} : ' + '*' * galton[i])\n\nhttps://t.co/fQ9ruHgXPv\n\n3/",
            "conversation_id": "1350185890073640960",
            "edit_history_tweet_ids": [
                "1350190833274765313"
            ],
            "id": "1350190833274765313"
        }
    },
    {
        "data": {
            "conversation_id": "1350185890073640960",
            "edit_history_tweet_ids": [
                "1350185890778234886"
            ],
            "text": "In case you're wondering about negative integers, x.bit_count() first applies abs(x):\n\n&gt;&gt;&gt; all(x.bit_count() == (-x).bit_count() for x in range(100_000))\nTrue\n\n2/",
            "id": "1350185890778234886"
        }
    },
    {
        "data": {
            "conversation_id": "1350185890073640960",
            "id": "1350185890073640960",
            "text": "Coming soon in #Python 3.10:  A faster way to count bits in an integer:\n\n&gt;&gt;&gt; x = 451\n&gt;&gt;&gt; bin(x)\n'0b111000011'\n&gt;&gt;&gt; bin(x).count('1')    # &lt;-- old\n5\n&gt;&gt;&gt; x.bit_count()      # &lt;-- new\n5\n\n1/",
            "edit_history_tweet_ids": [
                "1350185890073640960"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1349161090354085888",
            "edit_history_tweet_ids": [
                "1349161090354085888"
            ],
            "id": "1349161090354085888",
            "text": "#Python doesn't change eternal truths.\n\n\u201cGod made the integers; all else is the work of man.\u201d \u2014 Leopold Kronecker\n\n&gt;&gt;&gt; x = 10 ** 16\n&gt;&gt;&gt; x == x + 1\nFalse\n&gt;&gt;&gt; x == x + 1.0\nTrue"
        }
    },
    {
        "data": {
            "conversation_id": "1348558030778953730",
            "edit_history_tweet_ids": [
                "1348558030778953730"
            ],
            "id": "1348558030778953730",
            "text": "#Python fun:\n\n&gt;&gt;&gt; madlib = '{snake} is an {adjective} programming language for {plural_noun}'\n\n&gt;&gt;&gt; responses = dict(snake='Asp', adjective='uptight', plural_noun='guitars')\n\n&gt;&gt;&gt; madlib.format_map(responses)\n'Asp is an uptight programming language for guitars'"
        }
    },
    {
        "data": {
            "conversation_id": "1348408393099141122",
            "edit_history_tweet_ids": [
                "1348553113368555520"
            ],
            "id": "1348553113368555520",
            "text": "I'm deleting this tweet because it was being interpreted negatively as a comment about a specific user rather than as a general observation about the limitations of documentation in resolving differences between mental models and actual implementations."
        }
    },
    {
        "data": {
            "conversation_id": "1348408393099141122",
            "id": "1348439294000594946",
            "edit_history_tweet_ids": [
                "1348439294000594946"
            ],
            "text": "BTW, the point of the original tweet is that docs don't prevent bug reports like this.\n\nWhenever an implementation doesn't match a model formed in your head, one of the two will need to change \ud83d\ude09"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1348438177476792320"
            ],
            "text": "Later, there needs to be a decision about whether any of those ideas are worth it.\n\nIf the answer is yes, then implement it, document it, test it, and maintain it forever.\n\n2/",
            "id": "1348438177476792320",
            "conversation_id": "1348408393099141122"
        }
    },
    {
        "data": {
            "text": "For those reading the bug report, note that there are no judgments there.\n\nThe first step in triaging a bug report is to identify exactly what is happening in the reported example.\n\nThe next step is generating possible solutions, such a log10() method for Fractions.\n\n1/",
            "id": "1348438176684146689",
            "edit_history_tweet_ids": [
                "1348438176684146689"
            ],
            "conversation_id": "1348408393099141122"
        }
    },
    {
        "data": {
            "text": "If this use case was important, we could introduce a __log10__ dunder method and move the responsibility to the Fraction module.\n\nThat would retain loose coupling and Python both understandable and maintainable.\n\nThis question is whether it is worth it.",
            "id": "1348424307383259138",
            "edit_history_tweet_ids": [
                "1348424307383259138"
            ],
            "conversation_id": "1348408393099141122"
        }
    },
    {
        "data": {
            "id": "1348423741387128838",
            "edit_history_tweet_ids": [
                "1348423741387128838"
            ],
            "conversation_id": "1348408393099141122",
            "text": "The design issue here is that Python achieves loose coupling by its dunder methods, but the __float__() method loses some information during the coercion.\n\nIn this case, the information loss was important.  In most day to day work, it won't matter at all."
        }
    },
    {
        "data": {
            "conversation_id": "1348408393099141122",
            "edit_history_tweet_ids": [
                "1348418737242664960"
            ],
            "text": "Keep in mind that this user isn't wrong here.  The numeric tower suggests that Rationals be able to do whatever Reals can do.  And in fact most fractions do work with math.log10().",
            "id": "1348418737242664960"
        }
    },
    {
        "data": {
            "text": "def __iadd__(my, your):\n     https://t.co/lf7HHmu1S4 += https://t.co/bTeE5OdYKM\n     return my",
            "id": "1347712562058518530",
            "edit_history_tweet_ids": [
                "1347712562058518530"
            ],
            "conversation_id": "1347668251015217152"
        }
    },
    {
        "data": {
            "text": "OH:  #Python's instance variable \"self\" isn't self-centered enough.  Perhaps it should be shortened to \"me\" or \"my\". \ud83d\ude09\n\ndef __init__(my, house, car, money):\n    https://t.co/45V2unIqG3 = house\n    https://t.co/pM3IgYvXmt = car\n    https://t.co/YbMYB3BBwo = money",
            "id": "1347668251015217152",
            "edit_history_tweet_ids": [
                "1347668251015217152"
            ],
            "conversation_id": "1347668251015217152"
        }
    },
    {
        "data": {
            "conversation_id": "1346630207931785216",
            "edit_history_tweet_ids": [
                "1346630207931785216"
            ],
            "id": "1346630207931785216",
            "text": "#Python tip:  Not enough people know about itertools.tee(). \n\nThink of it any time you want consume an iterator value more than once.\n\nhttps://t.co/7boLZyjyZs"
        }
    },
    {
        "data": {
            "conversation_id": "1345822930127650816",
            "edit_history_tweet_ids": [
                "1345822932405108736"
            ],
            "id": "1345822932405108736",
            "text": "The upshot is that random's choice() function is size constrained because it calls len(seq):\n\n&gt;&gt;&gt; choice(range(10**100))\n ...\nOverflowError: Python int too large to convert to C ssize_t\n\nMeanwhile randrange() works fine because len() isn't called:\n\n&gt;&gt;&gt; x = randrange(10**100)\n\n4/"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1345822931645972481"
            ],
            "id": "1345822931645972481",
            "text": "Classes written in C typically implement __len__() with the mp_length or sq_length slot.  That constrains them to sys.maxsize limits:\n\n&gt;&gt;&gt; r = range(10**100)\n&gt;&gt;&gt; r.__len__()\nTraceback (most recent call last):\n   ...\nOverflowError: Python int too large to convert to C ssize_t\n\n3/",
            "conversation_id": "1345822930127650816"
        }
    },
    {
        "data": {
            "conversation_id": "1345822930127650816",
            "edit_history_tweet_ids": [
                "1345822930899402753"
            ],
            "id": "1345822930899402753",
            "text": "You could call __len__() successfully, but the len() function fails:\n\nclass A:\n    def __len__(self):\n        return -1\n\n&gt;&gt;&gt; a = A()\n\n&gt;&gt;&gt; a.__len__()\n-1\n\n&gt;&gt;&gt; len(a)\n  ...\nValueError: __len__() should return &gt;= 0\n\n2/"
        }
    },
    {
        "data": {
            "conversation_id": "1345822930127650816",
            "id": "1345822930127650816",
            "edit_history_tweet_ids": [
                "1345822930127650816"
            ],
            "text": "#Python factlet: The len() function insists that the corresponding __len__() method return a value x such that:\n\n     0 \u2264 x.__index__() \u2264 sys.maxsize\n\n* 3.0 and '3' don't have an __index__ method.\n* -1 is too small.\n* sys.maxsize+1  is too big.\n\n1/"
        }
    },
    {
        "data": {
            "id": "1345121743959015424",
            "text": "#Python tip:  Of all the ways to handle encoding errors, \"namereplace\" stands out as a way to preserve information readably and beautifully:\n\n&gt;&gt;&gt; 'In the meadow, we can build a \u2603'.encode('latin-1', errors='namereplace')\nb'In the meadow, we can build a \\\\N{SNOWMAN}'",
            "edit_history_tweet_ids": [
                "1345121743959015424"
            ],
            "conversation_id": "1345121743959015424"
        }
    },
    {
        "data": {
            "conversation_id": "1344693511426199558",
            "id": "1344761561009668096",
            "edit_history_tweet_ids": [
                "1344761561009668096"
            ],
            "text": "Guido has consistently commented that PEP 8 checkers and reformatters are by definition not PEP 8 compliant.  They all lack essential human judgment and aesthetics.\n\nSee for example:\n\nhttps://t.co/lBAcf9CZQk"
        }
    },
    {
        "data": {
            "conversation_id": "1344693511426199558",
            "id": "1344693511426199558",
            "text": "New year prediction:  Automated code formatting will be mandated for the #Python standard library despite clearcut examples of it making the code less readable:\n\nhttps://t.co/sfFvdVQjEF",
            "edit_history_tweet_ids": [
                "1344693511426199558"
            ]
        }
    },
    {
        "data": {
            "text": "TL;DR  \n* Follow the example in:  help(property)\n* Use a private variable name for a managed attribute\n* Don't shoot yourself in the foot \ud83d\ude09\n\n5/",
            "conversation_id": "1344363471597490176",
            "edit_history_tweet_ids": [
                "1344363474424500225"
            ],
            "id": "1344363474424500225"
        }
    },
    {
        "data": {
            "id": "1344363473724006400",
            "edit_history_tweet_ids": [
                "1344363473724006400"
            ],
            "text": "Also, it won't work out well if you later switch to a cached_property (because the cached value is stored in the attribute with same name).\n\nclass A:\n    @cached_property \n    def x(self):\n        return vars(self)['x'] * 12\n\n4/",
            "conversation_id": "1344363471597490176"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1344363473027833857"
            ],
            "text": "Seeing a non-private 'x' in vars(inst), a user or utility may reasonably may reasonably access the data directly, inadvertently bypassing the getter and setter methods.\n\nError messages are likely to be confusing as well. \n\nHmm, is that the property x or the stored x?\n\n3/",
            "id": "1344363473027833857",
            "conversation_id": "1344363471597490176"
        }
    },
    {
        "data": {
            "conversation_id": "1344363471597490176",
            "edit_history_tweet_ids": [
                "1344363472302211072"
            ],
            "id": "1344363472302211072",
            "text": "It is possible to use the same variable name, but it is awkward, confusing, and risks creating hard to find bugs:\n\nclass A:\n    @property \n    def x(self):\n        return vars(self)['x'] * 12\n\n2/"
        }
    },
    {
        "data": {
            "id": "1344363471597490176",
            "edit_history_tweet_ids": [
                "1344363471597490176"
            ],
            "conversation_id": "1344363471597490176",
            "text": "#Python tip:  When using property() to manage access to a variable, give the variable a different name than the property.\n\nIndicate that the attribute is private by using an underscore:\n\nclass A:\n    @property \n    def x(self):\n        return self._x      #  private name\n\n1/"
        }
    },
    {
        "data": {
            "id": "1344176537994625024",
            "text": "def manhattan_distance(p, q):\n    return sum(map(abs, map(operator.sub, p, q)))",
            "edit_history_tweet_ids": [
                "1344176537994625024"
            ],
            "conversation_id": "1344176537994625024"
        }
    },
    {
        "data": {
            "id": "1343063498482282496",
            "edit_history_tweet_ids": [
                "1343063498482282496"
            ],
            "text": "4/ Signature objects have their limitations.\n\nIn particular, it isn't able to express the actual calling patterns for range() which are a combination of two signatures:\n\nrange(stop)\nrange(start, stop, step=1)",
            "conversation_id": "1343063496330637313"
        }
    },
    {
        "data": {
            "conversation_id": "1343063496330637313",
            "edit_history_tweet_ids": [
                "1343063497739931648"
            ],
            "id": "1343063497739931648",
            "text": "3/ Tooltips and help() will now be more informative:\n\n&gt;&gt;&gt; help(randrange)\nrandrange(start, stop, step, /)\n    Choose a random value from range(start[, stop[, step]])."
        }
    },
    {
        "data": {
            "conversation_id": "1343063496330637313",
            "edit_history_tweet_ids": [
                "1343063497119158274"
            ],
            "text": "2/ The attribute is accessed by the inspect module:\n\n&gt;&gt;&gt; inspect.signature(randrange)\n&lt;Signature (start, stop, step, /)&gt;",
            "id": "1343063497119158274"
        }
    },
    {
        "data": {
            "id": "1343063496330637313",
            "edit_history_tweet_ids": [
                "1343063496330637313"
            ],
            "conversation_id": "1343063496330637313",
            "text": "1/ #Python tip:  Override the signature for *args with the __text_signature__ attribute:\n\ndef randrange(*args):\n    'Choose a random value from range(start[, stop[, step]]).'\n    return random.choice(range(*args))\n\nrandrange.__text_signature__ = '(start, stop, step, /)'"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1340048350968569856"
            ],
            "text": "The ascii() function is especially helpful in terminal sessions where the terminal isn't configured to display unicode.\n\n3/",
            "conversation_id": "1340042364363046914",
            "id": "1340048350968569856"
        }
    },
    {
        "data": {
            "text": "The algorithm for ascii(obj) starts with repr(obj) and then escapes the non-ASCII characters with \\\\x, \\\\u or \\\\U escapes.\n\n&gt;&gt;&gt; print(ascii(['Calle del Le\u00f3n', 'Champs-Elys\u00e9es']))\n['Calle del Le\\xf3n', 'Champs-Elys\\xe9es']\n\n2/",
            "conversation_id": "1340042364363046914",
            "edit_history_tweet_ids": [
                "1340042365071835136"
            ],
            "id": "1340042365071835136"
        }
    },
    {
        "data": {
            "id": "1340042364363046914",
            "text": "#Python tip:  The ascii() function is like repr() but its output only contains ASCII printable characters or escapes:\n\n&gt;&gt;&gt; s = 'Bismarckstra\u00dfe'\n\n&gt;&gt;&gt; print(repr(s))\n'Bismarckstra\u00dfe'\n\n&gt;&gt;&gt; print(ascii(s))\n'Bismarckstra\\xdfe'\n\n&gt;&gt;&gt; 'Bismarckstra\\xdfe' == 'Bismarckstra\u00dfe'\nTrue\n\n1/",
            "edit_history_tweet_ids": [
                "1340042364363046914"
            ],
            "conversation_id": "1340042364363046914"
        }
    },
    {
        "data": {
            "conversation_id": "1337613111218434049",
            "id": "1337613112078319617",
            "text": "Tools/scripts/var_access_benchmark.py shows the improvements are uneven.\n\nread_local, read_nonlocal, write_local, and write_nonlocal are unchanged\n\nMost of the other core operations have speedups from 50% to 90%:  read_global, read_builtin, read_instancevar, read_list, etc.",
            "edit_history_tweet_ids": [
                "1337613112078319617"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1337613111218434049",
            "text": "#Python runs fast on an Apple M1.\n\n303,461 pystones/second on my new Macbook Air\n\n159,497 pystones/second on my old Macbook Pro\n(2.6/3.8 Ghz Haswell)",
            "edit_history_tweet_ids": [
                "1337613111218434049"
            ],
            "id": "1337613111218434049"
        }
    },
    {
        "data": {
            "conversation_id": "1337505615204106240",
            "edit_history_tweet_ids": [
                "1337505618089758721"
            ],
            "id": "1337505618089758721",
            "text": "4/ Example\n\nclass D(dict):\n\n    def __missing__(self, name):\n        print('Fallback', name)\n        return 42\n\n    def __getitem__(self, name):\n        print('Main', name)\n        raise KeyError\n\n&gt;&gt;&gt; d = D()\n&gt;&gt;&gt; d['x']\nMain x\nTraceback (most recent call last):\n...\nKeyError"
        }
    },
    {
        "data": {
            "id": "1337505617376788481",
            "edit_history_tweet_ids": [
                "1337505617376788481"
            ],
            "conversation_id": "1337505615204106240",
            "text": "3/ In contrast, the [ ] square brackets operator only calls __getitem__().\n\nThe fallback to __missing__() for dict subclasses is embedded in dict.__getitem__().\n\nConsequently, overriding dict.__getitem__() disables the __missing__() hook."
        }
    },
    {
        "data": {
            "id": "1337505615808135170",
            "text": "2/ Example\n\nclass A:\n\n    def __getattr__(self, name):\n        print('Fallback', name)\n        return 42\n\n    def __getattribute__(self, name):\n        print('Main', name)\n        raise AttributeError\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x\nMain x\nFallback x\n42",
            "edit_history_tweet_ids": [
                "1337505615808135170"
            ],
            "conversation_id": "1337505615204106240"
        }
    },
    {
        "data": {
            "conversation_id": "1337505615204106240",
            "text": "1/ #Python fact:  The dot operator is hardwired to call __getattribute__() and to fallback to __getattr__() if an AttributeError is raised.\n\nOverriding __getattribute__ won't disable the __getattr__() hook.",
            "edit_history_tweet_ids": [
                "1337505615204106240"
            ],
            "id": "1337505615204106240"
        }
    },
    {
        "data": {
            "id": "1336851339138109440",
            "edit_history_tweet_ids": [
                "1336851339138109440"
            ],
            "conversation_id": "1336851339138109440",
            "text": "#Python tip: One way to learn about the inspirations and aspirations for Python's design is to read the books that Guido reads.\n\nWhen Python 2.2 came out, he suggested reading \u201cPutting Metaclasses to Work\u201d by Ira R. Forman.\n\nThat book gives a pretty good idea of what is possible."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1335284171669815297"
            ],
            "conversation_id": "1335284170965221376",
            "id": "1335284171669815297",
            "text": "2/ The same goes for sorting multiple unsorted sequences:\n\n    sorted(chain(a, b, c, d, e))   # O(n) + O(n log n)\n\nIf the subsequences are already sorted, combine them with heapq.merge():\n\n    list(merge(a, b, c, d, e))   # O(n)"
        }
    },
    {
        "data": {
            "conversation_id": "1335284170965221376",
            "edit_history_tweet_ids": [
                "1335284170965221376"
            ],
            "text": "1/ #Python tip:  Join sequences with itertools.chain() instead of with addition:\n\n    list(chain(a, b, c, d, e))   # O(n)\n\n    a + b + c + d + e   # O(n\u00b2)",
            "id": "1335284170965221376"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1334669385621860353"
            ],
            "id": "1334669385621860353",
            "text": "Of course, if you misspell it as __setname__, it won't do anything at all ;-)",
            "conversation_id": "1334669384170627073"
        }
    },
    {
        "data": {
            "text": "That prints:\n\n&lt;__main__.A object at 0x7fcf2ba1a3d0&gt; was named x by &lt;class '__main__.B'&gt;\n&lt;__main__.A object at 0x7fcf2ba1ad60&gt; was named y by &lt;class '__main__.B'&gt;",
            "id": "1334669384875327488",
            "edit_history_tweet_ids": [
                "1334669384875327488"
            ],
            "conversation_id": "1334669384170627073"
        }
    },
    {
        "data": {
            "conversation_id": "1334669384170627073",
            "edit_history_tweet_ids": [
                "1334669384170627073"
            ],
            "id": "1334669384170627073",
            "text": "#Python factlet:  The __set_name__() method isn't part of the descriptor protocol.  It will work with any class:\n\nclass A:\n    def __set_name__(self, owner, name):\n        print(f'{self} was named {name} by {owner}')\n\nclass B:\n    x = A()\n    y = A()"
        }
    },
    {
        "data": {
            "id": "1332777418004729856",
            "edit_history_tweet_ids": [
                "1332777418004729856"
            ],
            "conversation_id": "1332777417170010112",
            "text": "Syntax highlighters do good job of finding these conflicts, but they can still be annoying:\n\nprev, next, value = linked_list_node\n\nformat = '%d %B %Y %H:%M:%S'\n\nsum += term(x, i)\n\nid = lookup_id(username)\n\nhash = sha256(buffer).hexdigest()"
        }
    },
    {
        "data": {
            "conversation_id": "1332777417170010112",
            "edit_history_tweet_ids": [
                "1332777417170010112"
            ],
            "text": "#Python practice:  Occasionally, I need to alter a natural and preferred variable name just to avoid shadowing a builtin function.\n\nIn order of frequency, the most likely to get in my way are:\n\nnext()\nformat()\nsum()\ninput()\nid()\nmax()\nmin()\nhash()",
            "id": "1332777417170010112"
        }
    },
    {
        "data": {
            "id": "1331850115674345473",
            "edit_history_tweet_ids": [
                "1331850115674345473"
            ],
            "conversation_id": "1331850115674345473",
            "text": "When did Ohm's law become V = I R instead of E = I R ?\n\nAll the older textbooks used E with the justification that it stood for Electromotive force.  Of course, V for Voltage makes more sense.   But what made the conventions change?"
        }
    },
    {
        "data": {
            "conversation_id": "1331745704436404224",
            "edit_history_tweet_ids": [
                "1331745705149353989"
            ],
            "id": "1331745705149353989",
            "text": "&gt;&gt;&gt; source = partial(next, iter(['-42']))\n&gt;&gt;&gt; for token in generate_tokens(source):\n        print(token)\n\nTokenInfo(type=54 (OP), string='-', start=(1, 0), end=(1, 1), line='-42')\nTokenInfo(type=2 (NUMBER), string='42', start=(1, 1), end=(1, 3), line='-42')"
        }
    },
    {
        "data": {
            "conversation_id": "1331745704436404224",
            "id": "1331745704436404224",
            "text": "Alliterative #python factlet:  The core language specification has no notion of negative numbers. \n\n\"-42\", gets parsed as two tokens:\n* the operator \"-\" \n* the integer \"42\". \n\nA unary minus operation is needed to build the negative number.",
            "edit_history_tweet_ids": [
                "1331745704436404224"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1331677995057115136",
            "edit_history_tweet_ids": [
                "1331678888443871232"
            ],
            "id": "1331678888443871232",
            "text": "Is there a @thephysicsgirl or @3blue1brown for homotopy theory?"
        }
    },
    {
        "data": {
            "conversation_id": "1331677995057115136",
            "id": "1331677995057115136",
            "edit_history_tweet_ids": [
                "1331677995057115136"
            ],
            "text": "You want to learn something new, to grow your mind, to satisfy a little curiosity, and to step a little outside your comfort zone.\n\nSo, you google for, \"homotopy theory for beginners\" and find this.  \n\nOMG!  Time to retreat to my comfort zone.\n\nhttps://t.co/BNSlGwpg35"
        }
    },
    {
        "data": {
            "conversation_id": "1331393609204072450",
            "id": "1331393609204072450",
            "text": "#Python #Sphinx help:  Does anyone know the magic words to get Sphinx's doctest directive to be able to see and test logging output in addition to normal return values?\n\n&gt;&gt;&gt; dave.get_age()\nINFO:root:Accessing 'age' giving 40\n40",
            "edit_history_tweet_ids": [
                "1331393609204072450"
            ]
        }
    },
    {
        "data": {
            "id": "1330593395333447680",
            "text": "\"Excuse me, where can I find the conference registration desk?\"\n\n\"Sorry, that question has been asked before.\"",
            "edit_history_tweet_ids": [
                "1330593395333447680"
            ],
            "conversation_id": "1330593394465275905"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1330593394465275905"
            ],
            "id": "1330593394465275905",
            "text": "Am thinking of organizing a #StackOverflow conference.\n\nAny time two people start talking about something interesting, I'll have moderators break-up their group because similar conversations have happened before. \ud83d\ude09",
            "conversation_id": "1330593394465275905"
        }
    },
    {
        "data": {
            "conversation_id": "1330388128666935301",
            "text": "#Python tip:  Slice's are objects.\n\nYou can store them in variables or containers just as you would with a regular integer index.\n\n&gt;&gt;&gt; s = slice(6, 12)\n&gt;&gt;&gt; title = \"Monty python's flying circus\"\n&gt;&gt;&gt; title[s]\n'python'",
            "edit_history_tweet_ids": [
                "1330388128666935301"
            ],
            "id": "1330388128666935301"
        }
    },
    {
        "data": {
            "conversation_id": "1328219101316018176",
            "id": "1328219103648047106",
            "text": "There was also harrowing flat plank walkway between towers with no rails on either side. In fact, the descent presented me and my companion with a number of ways to die by falling from a great height.\n\nWe lived and had a tale to tell.",
            "edit_history_tweet_ids": [
                "1328219103648047106"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1328219102905659392"
            ],
            "text": "As a tourist, I was once trapped near the top of this Basilica. I missed the Spanish language announcement that they were closing.The attendants shut off the elevator and left. A medieval adventure ensued.\n\nUnlit spiral staircases with no handrails and long drops down the center.",
            "conversation_id": "1328219101316018176",
            "id": "1328219102905659392"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1328219102196842497"
            ],
            "text": "Here's what the whole basilica looks like:\n\nhttps://t.co/k97keCJ5OA",
            "conversation_id": "1328219101316018176",
            "id": "1328219102196842497"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1328219101316018176"
            ],
            "conversation_id": "1328219101316018176",
            "id": "1328219101316018176",
            "text": "The technology of yesteryear is amazing.  Here is an analog computer to calculate the distribution of forces in Antoni Gaudi's La Sagrada Familia:\n\nhttps://t.co/v0AIqo6zxp"
        }
    },
    {
        "data": {
            "id": "1328074206387474432",
            "edit_history_tweet_ids": [
                "1328074206387474432"
            ],
            "conversation_id": "1328074206387474432",
            "text": "Many years ago, I learned the programming language Forth.\n\nOn the plus side, it permanently changed the way I think about writing programs.\n\nOn the minus side, I always hesitate when trying to spell the word that comes between \"third\" and \"fifth\". The English word feels odd."
        }
    },
    {
        "data": {
            "conversation_id": "1327682831728873472",
            "edit_history_tweet_ids": [
                "1327682831728873472"
            ],
            "id": "1327682831728873472",
            "text": "#Python news:  The video is up for my #PyConEstonia keynote:  \n\n\"Object Oriented Programming from scratch (four times)\"\n\nHope this expands your world view.\n\nEnjoy!\n\nhttps://t.co/VWRiuBPDGN"
        }
    },
    {
        "data": {
            "text": "Music theory in a nutshell:\n\n    2 ** 7 \u2248 1.5 ** 12\n\nSeven octaves \u2248 Twelve perfect fifths\n\n\u2234 12 semitones close to small integer ratios",
            "id": "1327464240316252160",
            "edit_history_tweet_ids": [
                "1327464240316252160"
            ],
            "conversation_id": "1327464240316252160"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1326989314467581952"
            ],
            "conversation_id": "1326987462128754688",
            "id": "1326989314467581952",
            "text": "In moderator elections, I vote against people who brag that they've closed thousands of questions.\n\nThey remind me of people on Wikipedia who \"clean up\" by deleting mountains of original and important content.\n\nI \"cleaned\" the city by burning the library."
        }
    },
    {
        "data": {
            "text": "The Python topic has over a million questions.  So in theory, a powerful moderator could close every new question and reasonably claim that at some point in history someone discussed something similar.\n\nUnhelpfully, they could end all new questions and just convert SO to a FAQ.",
            "id": "1326987463999377409",
            "edit_history_tweet_ids": [
                "1326987463999377409"
            ],
            "conversation_id": "1326987462128754688"
        }
    },
    {
        "data": {
            "text": "Guido himself could helping an end-user and someone would cut him off in favor of a less helpful variant of the same question.",
            "conversation_id": "1326987462128754688",
            "edit_history_tweet_ids": [
                "1326987463437369344"
            ],
            "id": "1326987463437369344"
        }
    },
    {
        "data": {
            "conversation_id": "1326987462128754688",
            "id": "1326987462766284800",
            "text": "I'm happy to volunteer time to help people asking questions on StackOverflow, but I can't stand people who close the question right in the middle of the conversation.\n\nIt is an insult to the question asker and the question answerer.  All it does it make the closer feel powerful.",
            "edit_history_tweet_ids": [
                "1326987462766284800"
            ]
        }
    },
    {
        "data": {
            "id": "1326987462128754688",
            "edit_history_tweet_ids": [
                "1326987462128754688"
            ],
            "conversation_id": "1326987462128754688",
            "text": "StackOverflow is plagued by people who aggressively mark questions as duplicates.\n\nThere are many distinct questions that happen to use the same library function in their answers.\n\nFor example, I can think of many distinct and nuanced questions whose answer is itertool.product()."
        }
    },
    {
        "data": {
            "text": "#Python practices survey:  What variable name do you use for the first argument to a classmethod?",
            "id": "1326976012068929536",
            "edit_history_tweet_ids": [
                "1326976012068929536"
            ],
            "conversation_id": "1326976012068929536"
        }
    },
    {
        "data": {
            "conversation_id": "1326450694342144000",
            "edit_history_tweet_ids": [
                "1326450694342144000"
            ],
            "text": "TIL:  #Python's __set_name__() method works in regular classes even if they aren't descriptors.\n\n class A:\n    def __set_name__(self, owner, name):\n        print(self, owner, name)\n\nclass B:\n    x = A()\n\n&lt;__main__.A object at 0x7fae3831a0d0&gt; &lt;class '__main__.B'&gt; x",
            "id": "1326450694342144000"
        }
    },
    {
        "data": {
            "id": "1325605759317540864",
            "edit_history_tweet_ids": [
                "1325605759317540864"
            ],
            "conversation_id": "1325528169139462145",
            "text": "The letter \u03c4 has only one vertical stroke as compared to the two in \u03c0.  That falsely suggests that is it half of pi.\n\nTo indicate the correct relationship , seems like it would be better to call it \"twopi\" \ud83d\ude09"
        }
    },
    {
        "data": {
            "id": "1325533259460091904",
            "edit_history_tweet_ids": [
                "1325533259460091904"
            ],
            "text": "I haven't yet seen it appear in any math, engineering, science, or statistics books or journal articles.\n\nAFAICT, the \"establishment\" is rejecting or ignoring it.",
            "conversation_id": "1325528169139462145"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1325532300847714304"
            ],
            "text": "Another interesting question is where you first heard of tau being used for two pi?  Was it in Python or elsewhere?\n\nIs Python the lead promoter of the idea or is it popular in other circles?\n\npun intended ;-)",
            "conversation_id": "1325528169139462145",
            "id": "1325532300847714304"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1325528169760215040"
            ],
            "id": "1325528169760215040",
            "text": "Put another way:  Is \"The Tau Manifesto\" accepted, nascent but going to be accepted, going to fall by the wayside, just a joke or junk science, flat-out wrong, or just doomed to insignificance?\n\nhttps://t.co/B9OtjxAi71",
            "conversation_id": "1325528169139462145"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1325528169139462145"
            ],
            "text": "Question for scientists and engineers using #Python:  Do you use math.tau in professional work?",
            "conversation_id": "1325528169139462145",
            "id": "1325528169139462145"
        }
    },
    {
        "data": {
            "conversation_id": "1325126589370150914",
            "id": "1325126589370150914",
            "edit_history_tweet_ids": [
                "1325126589370150914"
            ],
            "text": "Thank heavens."
        }
    },
    {
        "data": {
            "conversation_id": "1324858366716358656",
            "id": "1324858366716358656",
            "edit_history_tweet_ids": [
                "1324858366716358656"
            ],
            "text": "The crown jewel of #Python's descriptor howto guide is the pure python translation for object.__getattribute__().\n\nThat one code snippet shows the engine that drives descriptors.\n\nhttps://t.co/wQjhvTEcKy"
        }
    },
    {
        "data": {
            "conversation_id": "1324587487067426817",
            "id": "1324587487067426817",
            "edit_history_tweet_ids": [
                "1324587487067426817"
            ],
            "text": "I can understand how pollsters can mispredict an election by a few percentage points.  What I don't understand is how we can be ten months into a pandemic and still have no reasonable estimate of what percentage of the population is currently infected."
        }
    },
    {
        "data": {
            "id": "1324221587759882240",
            "edit_history_tweet_ids": [
                "1324221587759882240"
            ],
            "conversation_id": "1324221587759882240",
            "text": "Interesting idea.  I think I like it.\nAm not sure.  Yes, I like it. \ud83d\ude42 \n\ndef __main__(func):\n    if __name__ == '__main__':\n        func() https://t.co/YDLQfno8L2"
        }
    },
    {
        "data": {
            "conversation_id": "1324072867273715712",
            "text": "My entire Twitter feed in a single #Python f-string \ud83e\uddd0 https://t.co/ApzN909hw2",
            "edit_history_tweet_ids": [
                "1324072867273715712"
            ],
            "id": "1324072867273715712"
        }
    },
    {
        "data": {
            "conversation_id": "1323787219799191552",
            "id": "1323787220474454018",
            "text": "2/\n\nLogic:\n\u2022 Modus ponens:  A \u2192 B \u2227 A \u22a2 B\n\u2022 Modus tollens: A \u2192 B \u2227 \u00acB \u22a2  \u00acA\n\nFacts:\n\u2022 By default, __name__ is '__main__'\n\u2022 Import changes the __name__\n\nDeductions:\n\u2022 If imported, the name is not '__main__'\n\u2022 If __name__ == '__main__', the module was not imported\n\u25a1",
            "edit_history_tweet_ids": [
                "1323787220474454018"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1323787219799191552",
            "edit_history_tweet_ids": [
                "1323787219799191552"
            ],
            "id": "1323787219799191552",
            "text": "1/ It is no fun to teach #Python's __name__ test beginners.\n\nI've seen many super smart people baffled at their first encounter with it.\n\nHere my latest iteration of how to explain it:"
        }
    },
    {
        "data": {
            "text": "Since the original tweet, I've made a couple of edits to simulation code.  Here is the latest version:\n\nhttps://t.co/zEUEzfB2mp",
            "conversation_id": "1322992732441206784",
            "edit_history_tweet_ids": [
                "1323031093168148480"
            ],
            "id": "1323031093168148480"
        }
    },
    {
        "data": {
            "conversation_id": "1322992732441206784",
            "id": "1323001482950569984",
            "edit_history_tweet_ids": [
                "1323001482950569984"
            ],
            "text": "Ideally book writers and blog posters can use this as a primary source rather than having to read the complex C code for themselves."
        }
    },
    {
        "data": {
            "conversation_id": "1322992732441206784",
            "edit_history_tweet_ids": [
                "1323000809756389376"
            ],
            "id": "1323000809756389376",
            "text": "I've aspired to the old Scientific American style with gentle user relevant examples and commentary up front, then moving toward deeper technical content with direct references to the C source."
        }
    },
    {
        "data": {
            "conversation_id": "1322992732441206784",
            "edit_history_tweet_ids": [
                "1322992732441206784"
            ],
            "id": "1322992732441206784",
            "text": "I've posted a #Python PR to add member objects to the Descriptor HowTo Guide. Let me know if you have any comments or suggestions \ud83d\ude42\n\nThe goal was to talk about __slots__ and translate its C implementation as well as possible into pure Python code.\n\nhttps://t.co/LAr7pHhWPt"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1322607969754775552"
            ],
            "text": "#Python userland question:  Do you any of you use/need the feature of randrange() that allowed integral float arguments?\n\n&gt;&gt;&gt; randrange(100.0, 200.0, 10.0)\n140\n\nIf not, we can clean-up and speed-up the implementation.",
            "conversation_id": "1322607969754775552",
            "id": "1322607969754775552"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1322365907650269184"
            ],
            "conversation_id": "1322365907650269184",
            "id": "1322365907650269184",
            "text": "As of #Python 3.9, there is a deprecation warning for using NotImplemented as a test expression.  Identity tests are now preferred:   \"if x is NotImplemented: ...\"\n\n&gt;&gt;&gt; bool(NotImplemented)\n&lt;stdin&gt;:1: DeprecationWarning: NotImplemented should not be used in a boolean context\nTrue"
        }
    },
    {
        "data": {
            "conversation_id": "1321917936668340227",
            "id": "1321935670558912518",
            "edit_history_tweet_ids": [
                "1321935670558912518"
            ],
            "text": "If so, be sure to speak-up.  There is a proposal to remove Solaris support:\n\nhttps://t.co/olksPZSiqs"
        }
    },
    {
        "data": {
            "id": "1321917936668340227",
            "edit_history_tweet_ids": [
                "1321917936668340227"
            ],
            "conversation_id": "1321917936668340227",
            "text": "Do any of you use #Python on Solaris?"
        }
    },
    {
        "data": {
            "conversation_id": "1321536669355372544",
            "id": "1321536670886289408",
            "text": "Your move:  @dabeaz @ramalhoorg @dontusethiscode \n\n3/\n\n* Reposted with spaces instead of tabs",
            "edit_history_tweet_ids": [
                "1321536670886289408"
            ]
        }
    },
    {
        "data": {
            "text": "Let the games begin!\n\n&gt;&gt;&gt; d = Dict(\n        cm = classmethod(lambda cls: cls.__name__.upper()),\n        pr = property(lambda self: self['x'] ** 2),\n        x = 5,\n)\n\n&gt;&gt;&gt; d['cm']()\n'DICT'\n\n&gt;&gt;&gt; d['pr']\n25\n&gt;&gt;&gt; d['x'] = 6\n&gt;&gt;&gt; d['pr']\n36\n\n2/",
            "id": "1321536670156513280",
            "edit_history_tweet_ids": [
                "1321536670156513280"
            ],
            "conversation_id": "1321536669355372544"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1321536669355372544"
            ],
            "id": "1321536669355372544",
            "text": "Egregious #Python hack of the day:  Add descriptor logic to dictionaries.\n\nclass Dict(dict):\n\n    def __getitem__(self, key):\n        value = super().__getitem__(key)\n        if hasattr(value, '__get__'):\n            return value.__get__(self, type(self))\n        return value\n\n1/",
            "conversation_id": "1321536669355372544"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1321201674954784770"
            ],
            "text": "The @cached_property() decorator only works if there is a writeable instance dictionary, so it won't work with __slots__ or metaclasses.\n\nAlso the writeback does not play well with PEP 412 key-sharing dicts, so you lose the space savings.\n\n5/",
            "id": "1321201674954784770",
            "conversation_id": "1321201671532285952"
        }
    },
    {
        "data": {
            "conversation_id": "1321201671532285952",
            "id": "1321201674271113217",
            "edit_history_tweet_ids": [
                "1321201674271113217"
            ],
            "text": "For cached_property(), being a non-data descriptor is the key to how it works.\n\nWhen it is first called, the result is written back to the instance dictionary.  Subsequent calls find the attribute instead of the cached property.\n\n4/"
        }
    },
    {
        "data": {
            "id": "1321201673428107265",
            "edit_history_tweet_ids": [
                "1321201673428107265"
            ],
            "conversation_id": "1321201671532285952",
            "text": "&gt;&gt;&gt; d = {'__get__', '__set__', '__delete__'}\n\n&gt;&gt;&gt; d &amp; set(dir(property))\n{'__set__', '__get__', '__delete__'}\n&gt;&gt;&gt; d &amp; set(dir(lambda : None))\n{'__get__'}\n&gt;&gt;&gt; d &amp; set(dir(classmethod))\n{'__get__'}\n&gt;&gt;&gt; d &amp; set(dir(cached_property))\n{'__get__'}\n\n3/"
        }
    },
    {
        "data": {
            "conversation_id": "1321201671532285952",
            "id": "1321201672656281601",
            "edit_history_tweet_ids": [
                "1321201672656281601"
            ],
            "text": "class A:\n\n@property\ndef p(self):\nreturn 'boop'\n\ndef m(self):\nreturn 'pop'\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.p\n'boop'\n&gt;&gt;&gt; a.m()\n'pop'\n\n&gt;&gt;&gt; vars(a)['p'] = 'hiss'\n&gt;&gt;&gt; vars(a)['m'] = 'bonk'\n\n&gt;&gt;&gt; a.p      # instance variable ignored\n'boop'\n&gt;&gt;&gt; a.m      # instance variable honored\n'bonk'\n\n2/"
        }
    },
    {
        "data": {
            "conversation_id": "1321201671532285952",
            "id": "1321201671532285952",
            "edit_history_tweet_ids": [
                "1321201671532285952"
            ],
            "text": "#Python tip:  A descriptor defining __set__() or __delete__() is considered a data descriptor and has precedence over an instance variable with the same name.\n\nproperty() is a data descriptor.\n\nFunction, classmethod, staticmethod, and cached_property are non-data descriptors.\n\n1/"
        }
    },
    {
        "data": {
            "id": "1320835737462263808",
            "edit_history_tweet_ids": [
                "1320835737462263808"
            ],
            "text": "5/ People are always asking about how to kill another thread.\n\nWe don't provide an API for that.\n\nReason: you never know when that thread is holding a lock.\n\nBut if you're clever, you can use ctypes to kill it.\n\nAfterwards, feel free to contract me for help with the deadlocks. \ud83e\udd72",
            "conversation_id": "1320835734702469120"
        }
    },
    {
        "data": {
            "conversation_id": "1320835734702469120",
            "id": "1320835736866676736",
            "edit_history_tweet_ids": [
                "1320835736866676736"
            ],
            "text": "4/ Integers are immutable in #Python, but if you're clever, ctypes can be used to alter the value field.\n\nNothing good can come of this. \ud83e\udd78"
        }
    },
    {
        "data": {
            "id": "1320835736166305792",
            "edit_history_tweet_ids": [
                "1320835736166305792"
            ],
            "conversation_id": "1320835734702469120",
            "text": "3/ Once upon a time, True and False weren't keywords.\n\nYou could write:\n\n     True, False = False, True\n\nand watch the world fall apart.\n\nUltimately, it was decided that constants should be constant. \ud83d\ude07"
        }
    },
    {
        "data": {
            "conversation_id": "1320835734702469120",
            "text": "2/ Today a Pythonista wanted to how to make \"C() is None\" always return True, by overriding #Python's is-operator.\n\n@ramalhoorg correctly advised that this would be \"catastrophic\".\n\nThis conversation is still continuing as people look for ways to lie about object identity. \ud83e\udd14",
            "edit_history_tweet_ids": [
                "1320835735398707200"
            ],
            "id": "1320835735398707200"
        }
    },
    {
        "data": {
            "conversation_id": "1320835734702469120",
            "text": "1/ Many years ago, I maintained General Ledger software.\n\nA customer wanted to know how to disable the debits==credits check. We strongly advised against it. Never the less, the customer demanded to know.\n\nA month later, they called back saying their books were out of balance \ud83e\uddd0",
            "edit_history_tweet_ids": [
                "1320835734702469120"
            ],
            "id": "1320835734702469120"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1320415642525134848"
            ],
            "id": "1320415642525134848",
            "text": "5/ The @cache decorator is new in #Python version 3.9.\n\nPrior to that, you can get the same effect with an lru_cache where the maxsize is set to None:\n\n@lru_cache(maxsize=None)\ndef f(x):\n   ...\n\nSo, really @cache is just a pretty way to spell it.",
            "conversation_id": "1320411456597209089"
        }
    },
    {
        "data": {
            "text": "4/ It's implemented with fast C code, equivalent to:\n\nkey = make_key(args, kwds, typed)\nresult = cache_get(key, sentinel)\nif result is not sentinel:\n    hits += 1\n    return result\nmisses += 1\nresult = user_function(*args, **kwds)\ncache[key] = result\nreturn result",
            "id": "1320411461194190848",
            "edit_history_tweet_ids": [
                "1320411461194190848"
            ],
            "conversation_id": "1320411456597209089"
        }
    },
    {
        "data": {
            "conversation_id": "1320411456597209089",
            "edit_history_tweet_ids": [
                "1320411458425909248"
            ],
            "id": "1320411458425909248",
            "text": "3/ Behind the scenes, there is a single dictionary lookup and a counter increment.\n\nSome kinds arguments will take longer to hash, but you get the idea, @cache has very little overhead."
        }
    },
    {
        "data": {
            "id": "1320411457607983105",
            "text": "2/ Here are the timings:\n\n$ python3.9 -m timeit -r11 -s 'def s(x):pass' 's(5)'\n5000000 loops, best of 11: 72.1 nsec per loop\n\n$ python3.9 -m timeit -r11 -s 'from functools import cache' -s 'def s(x):pass' -s 'c=cache(s)' 'c(5)'\n5000000 loops, best of 11: 60.6 nsec per loop",
            "edit_history_tweet_ids": [
                "1320411457607983105"
            ],
            "conversation_id": "1320411456597209089"
        }
    },
    {
        "data": {
            "text": "1/ #Python tip:  The functools.cache() decorator is astonishingly fast.\n\nEven an empty function that returns None can be sped-up by caching it. \ud83e\udd28\n\nhttps://t.co/quBgxkdDdD",
            "id": "1320411456597209089",
            "edit_history_tweet_ids": [
                "1320411456597209089"
            ],
            "conversation_id": "1320411456597209089"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1320102411470426113"
            ],
            "conversation_id": "1320019801784213506",
            "id": "1320102411470426113",
            "text": "Here is the new rendered version with those edits:\n\nhttps://t.co/9wk2aZSdTy"
        }
    },
    {
        "data": {
            "conversation_id": "1320019801784213506",
            "edit_history_tweet_ids": [
                "1320102410656727040"
            ],
            "id": "1320102410656727040",
            "text": "Here's a  live draft for the second round of edits.\n\nIn particular, please look at the new Descriptor Example:\n\nhttps://t.co/SGhnW4KUkg"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1320019801784213506"
            ],
            "id": "1320019801784213506",
            "text": "The #Python descriptor howto guide has been updated to include a gentle primer and a complete practical example.\n\nI'm working on a second round of edits now. Let me know if you have any suggestions.\n\nhttps://t.co/ZUUb8TDj1f",
            "conversation_id": "1320019801784213506"
        }
    },
    {
        "data": {
            "id": "1319533718998904832",
            "edit_history_tweet_ids": [
                "1319533718998904832"
            ],
            "conversation_id": "1319526252282171394",
            "text": "Here's a better link:\n\nhttps://t.co/4XWsYRp9zS"
        }
    },
    {
        "data": {
            "text": "#Python user feedback wanted.  I'm adding a gentle primer and a complete example to the Descriptor HowTo guide.\n\nPlease read through it and let me know what you think about it and whether you have any suggestions.\n\nhttps://t.co/2wRDD5HrCe",
            "conversation_id": "1319526252282171394",
            "edit_history_tweet_ids": [
                "1319526252282171394"
            ],
            "id": "1319526252282171394"
        }
    },
    {
        "data": {
            "id": "1319383948972101633",
            "edit_history_tweet_ids": [
                "1319383948972101633"
            ],
            "conversation_id": "1319383948972101633",
            "text": "#Python tip:   Remember that https://t.co/0cJdoMoGGO is a function and https://t.co/BCvhwJd1mr is an integer.\n\nI've long known this and would never accidentally write:\n\n    logging.basicConfig(level=https://t.co/0cJdoMoGGO)\n\nThat would never happen.\nNo siree.\nNoch nie.\nNunca.\n\ud83e\udd25"
        }
    },
    {
        "data": {
            "id": "1318618553562525697",
            "edit_history_tweet_ids": [
                "1318618553562525697"
            ],
            "conversation_id": "1318616781871669249",
            "text": "Would any of you be interested if I offered one-day online course to level-up your statistics and data analysis skills?\n\n7/"
        }
    },
    {
        "data": {
            "text": "For more on Solution 1, see:\n\nhttps://t.co/q1CGgCQE6k\n\nFor more on Solution 2, see:\n\nhttps://t.co/2pmSW1NrFV\n\nFor more on Solution 3, see:\n\nhttps://t.co/IP7EugMjnJ\n\n6/",
            "id": "1318616785592053760",
            "edit_history_tweet_ids": [
                "1318616785592053760"
            ],
            "conversation_id": "1318616781871669249"
        }
    },
    {
        "data": {
            "conversation_id": "1318616781871669249",
            "edit_history_tweet_ids": [
                "1318616784807686146"
            ],
            "id": "1318616784807686146",
            "text": "Solution 3:  Approximation using a simulation\n\n&gt;&gt;&gt; from random import choices\n&gt;&gt;&gt; from statistics import mean\n\n&gt;&gt;&gt; def trial():\n        return choices(('Python', 'Ruby'), (p, q), k=n).count('Python')\n\n&gt;&gt;&gt; mean(trial() &lt;= k for i in range(10_000))\n0.8398\n\n5/"
        }
    },
    {
        "data": {
            "text": "Solution 2:  Approximation with a normal distribution\n\n&gt;&gt;&gt; from statistics import NormalDist\n&gt;&gt;&gt; from math import sqrt\n\n&gt;&gt;&gt; round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n0.8402\n\n4/",
            "conversation_id": "1318616781871669249",
            "edit_history_tweet_ids": [
                "1318616784077942784"
            ],
            "id": "1318616784077942784"
        }
    },
    {
        "data": {
            "conversation_id": "1318616781871669249",
            "edit_history_tweet_ids": [
                "1318616783394201600"
            ],
            "text": "Solution 1:  Cumulative binomial distribution\n\n&gt;&gt;&gt; from math import comb, fsum\n\n&gt;&gt;&gt; round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n0.8402\n\n3/",
            "id": "1318616783394201600"
        }
    },
    {
        "data": {
            "conversation_id": "1318616781871669249",
            "id": "1318616782635069440",
            "edit_history_tweet_ids": [
                "1318616782635069440"
            ],
            "text": "Here are the parameters:\n\nn = 750             # Number of attendees\np = 0.65            # Preference for Python\nq = 1.0 - p         # Preference for Ruby\nk = 500             # Room capacity\n\nTry it yourself before looking at the three difference solutions that follow.\n\n2/"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1318616781871669249"
            ],
            "id": "1318616781871669249",
            "text": "A conference has 750 people and 2 rooms with a\n500 person capacity. One talk is about Python and the other about Ruby.\n\nHistorically, 65% of the attendees preferred to listen to #Python talks.  What is the probability that the Python room will stay within its capacity limits?\n\n1/",
            "conversation_id": "1318616781871669249"
        }
    },
    {
        "data": {
            "text": "#Python PSA:  Add this to your .gitattributes file:\n\n*.py    diff=python\n\nThis will help diff make a better choice about which context line to display in the hunk header.\n\nhttps://t.co/t7KchohL3m",
            "id": "1318260360789454848",
            "edit_history_tweet_ids": [
                "1318260360789454848"
            ],
            "conversation_id": "1318260360789454848"
        }
    },
    {
        "data": {
            "id": "1318242020461367296",
            "text": "#Python grammar pop quiz:  Will this assertion succeed or fail?  Why?\n\nt = 10 + 1, 20 + 2\nassert t == 11, 22",
            "edit_history_tweet_ids": [
                "1318242020461367296"
            ],
            "conversation_id": "1318242020461367296"
        }
    },
    {
        "data": {
            "text": "# Conversion to float and back doesn't round-trip:\n\n&gt;&gt;&gt; Decimal(float(Decimal('1.1')))\nDecimal('1.100000000000000088817841970012523233890533447265625')\n\n&gt;&gt;&gt; Fraction(float(Fraction(8, 9)))\nFraction(2001599834386887, 2251799813685248)",
            "id": "1317899013589331968",
            "edit_history_tweet_ids": [
                "1317899013589331968"
            ],
            "conversation_id": "1317897021219426304"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1317897022104457216"
            ],
            "conversation_id": "1317897021219426304",
            "id": "1317897022104457216",
            "text": "# Lossless conversions:\n\n&gt;&gt;&gt; Fraction(True)\nFraction(1, 1)\n&gt;&gt;&gt; Fraction(100)\nFraction(100, 1)\n&gt;&gt;&gt; Fraction(5.75)\nFraction(23, 4)\n&gt;&gt;&gt; Fraction(Decimal('3.1'))\nFraction(31, 10)"
        }
    },
    {
        "data": {
            "text": "#Python's numeric tower has Integral inheriting from Rational which inherits from Real.  That suggests treating float() as a common type.\n\nBut if you want lossless conversion, use Fraction() because it can exactly express the values in bool(), int(), float(), and Decimal().",
            "id": "1317897021219426304",
            "edit_history_tweet_ids": [
                "1317897021219426304"
            ],
            "conversation_id": "1317897021219426304"
        }
    },
    {
        "data": {
            "conversation_id": "1317558839588212736",
            "text": "The origin of the float_info constants is the C language spec's model for floats:\n\nx = sign * base ** exp * sum(fraction[k] * base ** -k for k in range(1, prec+1))\n\nThe  sum \u00bdb\u2081 + \u00bcb\u2082 + \u215bb\u2083 + \u2026 starts with one-half which is why the exponent is one less than expected.",
            "edit_history_tweet_ids": [
                "1317655079076331520"
            ],
            "id": "1317655079076331520"
        }
    },
    {
        "data": {
            "conversation_id": "1317558839588212736",
            "id": "1317652878404669440",
            "text": "The min/max exponents are for mantissas in the range 0.5 \u2264 x &lt; 1.0.\n \n&gt;&gt;&gt; ldexp(0.5, -1021) == float_info.min\nTrue\n&gt;&gt;&gt; ldexp(1.0 - float_info.epsilon/2, 1024) == float_info.max\nTrue",
            "edit_history_tweet_ids": [
                "1317652878404669440"
            ]
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1317651629596835840"
            ],
            "conversation_id": "1317558839588212736",
            "id": "1317651629596835840",
            "text": "The resolution of the paradoxes lies in knowing that none of float_info constants has the expected meaning \ud83e\uddd0\n\nmin_10_exp: lowest integer exponent where 10**exp is a  normalized floating-point number.\n\n2.23-308 is normalized.\n1E-308 isn't.\n\nSee \u00a7371 in https://t.co/fJbH2IVzXr"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1317558840292896768"
            ],
            "text": "#3) Can it really be the maximum if it overflows?\n\n&gt;&gt;&gt; float_info.max_exp\n1024\n\n&gt;&gt;&gt; 2.0 ** float_info.max_exp\n...\nOverflowError: (34, 'Result too large')\n\n&gt;&gt;&gt; math.ldexp(1.0,  float_info.max_exp)\n...\nOverflowError: math range error",
            "conversation_id": "1317558839588212736",
            "id": "1317558840292896768"
        }
    },
    {
        "data": {
            "id": "1317558839588212736",
            "edit_history_tweet_ids": [
                "1317558839588212736"
            ],
            "conversation_id": "1317558839588212736",
            "text": "Can you resolve these three #Python floating point paradoxes?\n\n&gt;&gt;&gt; float_info.min_10_exp\n-307\n\n#1) Lower than the minimum?\n&gt;&gt;&gt; float_info.min\n2.2250738585072014e-308\n\n&gt;&gt;&gt; float_info.min_exp\n-1021\n\n#2) Lower than the minimum?\n&gt;&gt;&gt; float_info.min == 2 ** -1022\nTrue"
        }
    },
    {
        "data": {
            "conversation_id": "1316882355043266561",
            "id": "1316882360260988928",
            "text": "6/ Python floats have the concept of NaNs and Infinities.  Neither of these is a feature of the real numbers you learned in school.\n\nPython floats also have signed zeros but real numbers don't:\n\n&gt;&gt;&gt; 0.0\n0.0\n&gt;&gt;&gt; -0.0\n-0.0",
            "edit_history_tweet_ids": [
                "1316882360260988928"
            ]
        }
    },
    {
        "data": {
            "text": "5/ Since floats have finite precision, basic mathematical relationships reach a breaking point:\n\n&gt;&gt;&gt; x = 12345678901234567.0\n&gt;&gt;&gt; x == x + 1\nTrue",
            "id": "1316882357995986945",
            "edit_history_tweet_ids": [
                "1316882357995986945"
            ],
            "conversation_id": "1316882355043266561"
        }
    },
    {
        "data": {
            "conversation_id": "1316882355043266561",
            "id": "1316882357308149761",
            "edit_history_tweet_ids": [
                "1316882357308149761"
            ],
            "text": "4/ Ints have some methods that floats don't have.  Likewise, floats have some methods that ints don't have.\n\n&gt;&gt;&gt; set(dir(int)) - set(dir(float))\n{'from_bytes', 'to_bytes', 'bit_length', ...}\n\n&gt;&gt;&gt; set(dir(float)) - set(dir(int))\n{'hex', 'is_integer', 'fromhex', ...}"
        }
    },
    {
        "data": {
            "text": "3/ In Python, all floats and Decimals are rational.  So, irrational numbers aren't really irrational \ud83d\ude44\n\n&gt;&gt;&gt; https://t.co/gIk9ajfjcm_integer_ratio()\n(884279719003555, 281474976710656)\n\nOf course, special values like NaN and Inf are special in this regard.",
            "id": "1316882356469342210",
            "edit_history_tweet_ids": [
                "1316882356469342210"
            ],
            "conversation_id": "1316882355043266561"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1316882355764645888"
            ],
            "id": "1316882355764645888",
            "text": "2/ In Python, there are more ints and Fractions than there are floats.\n\nSince Python ints and Fractions are unbounded, there are countably infinitely many of them.\n\nBut floats have to fit in a 64-bit C double, so there are only a finite number of them. \ud83e\uddd0",
            "conversation_id": "1316882355043266561"
        }
    },
    {
        "data": {
            "conversation_id": "1316882355043266561",
            "edit_history_tweet_ids": [
                "1316882355043266561"
            ],
            "id": "1316882355043266561",
            "text": "1/ #Python inconvenient truth:   The number systems we learned in pure math are somewhat different from their concrete counterparts in Python.\n\nIn pure math, \u2124 \u2282 \u211a \u2282 \u211d.  Integers are a proper subset of rationals which are themselves a proper subset of the real numbers."
        }
    },
    {
        "data": {
            "conversation_id": "1316467183837278208",
            "id": "1316494025554186240",
            "edit_history_tweet_ids": [
                "1316494025554186240"
            ],
            "text": "* rub off on"
        }
    },
    {
        "data": {
            "text": "Collaborating with Allen Downey and Tim Peters is a wonderful experience.\n\nI have a secret hope that some of their superpowers will rub on me.",
            "id": "1316471393517625344",
            "edit_history_tweet_ids": [
                "1316471393517625344"
            ],
            "conversation_id": "1316467183837278208"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1316467183837278208"
            ],
            "conversation_id": "1316467183837278208",
            "id": "1316467183837278208",
            "text": "Today, a new #Python recipe was added to the random module docs. https://t.co/uEl731sx8s"
        }
    },
    {
        "data": {
            "id": "1315855141183004672",
            "edit_history_tweet_ids": [
                "1315855141183004672"
            ],
            "conversation_id": "1315855141183004672",
            "text": "#Python happenings:  It seems like the proposal for indexing with keyword arguments has come back to life.\n\n@dabeaz @ramalhoorg  What say you?  Net decrease or increase in language complexity?\n\nhttps://t.co/3iIezp6MIJ"
        }
    },
    {
        "data": {
            "conversation_id": "1314729569279074304",
            "edit_history_tweet_ids": [
                "1314729569279074304"
            ],
            "id": "1314729569279074304",
            "text": "#Python floating point lingo:  A \"binade\" is the set of numbers in a binary IEEE 754 floating-point format that all have the same exponent. In other words, a binade is the interval [2n, 2n+1) for some integer n.\n\nAll mantissas returned by math.frexp() lie in the same binade."
        }
    },
    {
        "data": {
            "id": "1312851500679356416",
            "edit_history_tweet_ids": [
                "1312851500679356416"
            ],
            "conversation_id": "1312851498934575104",
            "text": "3/ #Python code:\n\n&gt;&gt;&gt; (0.05954861408025609).as_integer_ratio()\n(4290929858916333, 72057594037927936)\n\n&gt;&gt;&gt; 2 ** 56\n72057594037927936\n\ndef my_random():\n    return randrange(2**53) * 2.0**-53"
        }
    },
    {
        "data": {
            "conversation_id": "1312851498934575104",
            "id": "1312851499823759361",
            "edit_history_tweet_ids": [
                "1312851499823759361"
            ],
            "text": "2/ The random() function starts with an integer in the range 0 \u2264 X &lt; 2\u2075\u00b3 and divides it by 2\u2075\u00b3 to give a random float.\n\n0.05954861408025609 isn't possible because its binary fraction, 4290929858916333 \u00f7 2\u2075\u2076, has a denominator that is greater than 2\u2075\u00b3."
        }
    },
    {
        "data": {
            "conversation_id": "1312851498934575104",
            "edit_history_tweet_ids": [
                "1312851498934575104"
            ],
            "text": "1/ #Python factlet:  random() gives you floats in the range 0.0 \u2264 X &lt; 1.0, but not all floats in that range are possible selections.\n\nFor example, 0.05954861408025609 isn't a possible selection.",
            "id": "1312851498934575104"
        }
    },
    {
        "data": {
            "id": "1312239865103220736",
            "edit_history_tweet_ids": [
                "1312239865103220736"
            ],
            "text": "#Python tip from Benjamin Franklin:\n\nThose who would give up high cohesion and loose coupling, to purchase a little convenience or speed, deserve the lifetime of maintenance problems that will ensue.",
            "conversation_id": "1312239865103220736"
        }
    },
    {
        "data": {
            "conversation_id": "1311835587255689221",
            "edit_history_tweet_ids": [
                "1311835589612720128"
            ],
            "id": "1311835589612720128",
            "text": "4/ The cost-benefit analysis isn't always easy:\n\n* Tools don't seem complex to the person who built them.\n\n* New tools create new problems you didn't have before.\n\n* Tools that work well in isolation don't necessary work well together."
        }
    },
    {
        "data": {
            "id": "1311835588924854272",
            "edit_history_tweet_ids": [
                "1311835588924854272"
            ],
            "conversation_id": "1311835587255689221",
            "text": "3/ This isn't to pick on the enum tool \u2013 lots of people like it.\n\nThe goal is to habitually ask whether a solution is more complex than the problem it solves.\n\nThe answer isn't fixed. It depends on your tolerance for complexity and on how much you care about the problem."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1311835588106940416"
            ],
            "conversation_id": "1311835587255689221",
            "id": "1311835588106940416",
            "text": "2/ The enum module has proven to be popular.\n\nOTOH few people know the module very well. It has 1,000 lines of complex code backed by 5,000 words of docs.\n\nThe problem solved is changing the repr of https://t.co/HYkGRDCwfx_INET from:\n\n  2\n\nto:\n\n  &lt;https://t.co/90KY4Eeq3T_INET: 2&gt;"
        }
    },
    {
        "data": {
            "id": "1311835587255689221",
            "edit_history_tweet_ids": [
                "1311835587255689221"
            ],
            "text": "1/ Programming in the large is almost entirely about management of complexity.\n\nWhen evaluating additions to the #Python standard library, it is reasonable to ask whether a solution is more complex than the problem it solves.",
            "conversation_id": "1311835587255689221"
        }
    },
    {
        "data": {
            "id": "1311191591663489027",
            "edit_history_tweet_ids": [
                "1311191591663489027"
            ],
            "conversation_id": "1311191591663489027",
            "text": "Best reply so far :-)\nThis one definitely needs underscores! https://t.co/wlDmiNIufk"
        }
    },
    {
        "data": {
            "conversation_id": "1311009985283854336",
            "id": "1311009985283854336",
            "edit_history_tweet_ids": [
                "1311009985283854336"
            ],
            "text": "More excellent examples, courtesy of Aaron Meurer: https://t.co/q1Lx5Dhrty"
        }
    },
    {
        "data": {
            "conversation_id": "1311003482531401729",
            "edit_history_tweet_ids": [
                "1311008418480570370"
            ],
            "text": "It is little known that Sauron had his own orc/hobbit crossbreed from an anti-shire in Mordor.  Frodo's doppelganger was named \"Fromordinal\".",
            "id": "1311008418480570370"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1311006487750164480"
            ],
            "conversation_id": "1311003482531401729",
            "id": "1311006487750164480",
            "text": "Is _abcoll.py short for:\n\n   abc_oll.py\n\nor:\n\n   ab_coll.py\n\nAnswer:  None of the above. \ud83d\ude07"
        }
    },
    {
        "data": {
            "id": "1311004449251360771",
            "edit_history_tweet_ids": [
                "1311004449251360771"
            ],
            "text": "Another tidbit of hard won programming wisdom: https://t.co/TeFdW9lAnI",
            "conversation_id": "1311004449251360771"
        }
    },
    {
        "data": {
            "text": "9/ Seriously, we have tab completion nowadays, so saving one keystroke isn't much of an advantage.\n\nAlso, we spend *much* more time reading code than writing it.\n\nAs Uncle Timmy taught us in the Zen of Python:\n\n    Readability counts.",
            "id": "1311003488877338624",
            "edit_history_tweet_ids": [
                "1311003488877338624"
            ],
            "conversation_id": "1311003482531401729"
        }
    },
    {
        "data": {
            "conversation_id": "1311003482531401729",
            "edit_history_tweet_ids": [
                "1311003488164278273"
            ],
            "id": "1311003488164278273",
            "text": "8/ Omitting the underscore isn't always bad.\n\nPeople seem to have no problem with:\n\n    d = dict.fromkeys(data)\n\nBut it still would have been a little more readable as:\n\n    d = dict.from_keys(data)"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1311003487476412419"
            ],
            "conversation_id": "1311003482531401729",
            "id": "1311003487476412419",
            "text": "7/ In the datetime module, many of the names could read better:\n\nfromisocalendar \u27f6 from_iso_calendar\nfromisoformat \u27f6 from_iso_format\nfromordinal \u27f6 from_ordinal\nisoweekday \u27f6 iso_weekday"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1311003486776033282"
            ],
            "id": "1311003486776033282",
            "text": "6/ The statistics module also has a minor irritant:\n\n    stdev()\n\nThe \"dev\" part clearly relates to \"deviation\".\n\nSo that leaves \"st\" for \"standard\" rather than the expected \"std\".\n\nThat said, other established APIs are evenly split between stdev() and stddev().",
            "conversation_id": "1311003482531401729"
        }
    },
    {
        "data": {
            "conversation_id": "1311003482531401729",
            "id": "1311003485324759041",
            "edit_history_tweet_ids": [
                "1311003485324759041"
            ],
            "text": "5/ From https://t.co/oLLyuly7Qc:\n\nThe submodule used to be named:  _abcoll.py\n\nThat was short for ABCs (abstract base classes) for Collections.   \n\nNote that there is only one C in the module name\ud83e\udd14.\n\nOne day I couldn't stand it, so now it is named:\n\n_collections_abc.py"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1311003484624310272"
            ],
            "text": "4/ From itertools:\n\nThe islice() tool should have been called \"iter_slice()\" so it wouldn't be misread as \"is_lice\".\n\nBTW, the answer is no.  There are no lice in the itertools module \ud83d\ude09",
            "id": "1311003484624310272",
            "conversation_id": "1311003482531401729"
        }
    },
    {
        "data": {
            "id": "1311003483936489472",
            "edit_history_tweet_ids": [
                "1311003483936489472"
            ],
            "text": "3/ From urllib:\n\nThe name \"addinfourl\" is terrible.  \n\nFor me, it shimmers like an optical illusion between \"add_in_four_l\" and \"add_info_url\".",
            "conversation_id": "1311003482531401729"
        }
    },
    {
        "data": {
            "conversation_id": "1311003482531401729",
            "id": "1311003483231854593",
            "edit_history_tweet_ids": [
                "1311003483231854593"
            ],
            "text": "2/ From the math module:\n\nif not isfinite(x):\n    ...\n\nIt is so easy to ready this as \"not infinite(x)\" rather than \"not is_finite\".\n\nArguably, the \"is\" could have been dropped altogether:\n\nif not finite(x):\n    ..."
        }
    },
    {
        "data": {
            "conversation_id": "1311003482531401729",
            "edit_history_tweet_ids": [
                "1311003482531401729"
            ],
            "id": "1311003482531401729",
            "text": "1/ #Python tip:  Resist the urge to elide the underscore in multiword function or method names."
        }
    },
    {
        "data": {
            "conversation_id": "1309935931818831874",
            "id": "1309938312459595776",
            "edit_history_tweet_ids": [
                "1309938312459595776"
            ],
            "text": "People also seem to have enjoyed my 45 minute talk on #python's super().\n\nhttps://t.co/uMGsbUAev0"
        }
    },
    {
        "data": {
            "id": "1309935931818831874",
            "edit_history_tweet_ids": [
                "1309935931818831874"
            ],
            "text": "The instructions for how to successfully use #Python's super() has been my most successful bit of technical writing.\n\nIt has had over a half-million readers.  If if it were a book, it might have been a New York Times bestseller \ud83e\udd74\n\nhttps://t.co/vV0CaKdXyt",
            "conversation_id": "1309935931818831874"
        }
    },
    {
        "data": {
            "id": "1309578865434484736",
            "edit_history_tweet_ids": [
                "1309578865434484736"
            ],
            "conversation_id": "1309578865434484736",
            "text": "#Python tip:  A \"bag\" of objects can be modeled with collections.Counter().  To get the individual values out of the bag, use the elements() method:\n\n&gt;&gt;&gt; bag_of_colors = Counter(red=3, blue=1, yellow=1)\n&gt;&gt;&gt; list(bag_of_colors.elements())\n['red', 'red', 'red', 'blue', 'yellow']"
        }
    },
    {
        "data": {
            "text": "Amusing excerpt from the Google C++ style guide:\n\nfor (int i = 0; i &lt; kSomeNumber; ++i)\n  printf(\"I love you\\n\");\n\nfor (int i = 0; i &lt; kSomeNumber; ++i) {\n  printf(\"I take it back\\n\");\n}\n\nhttps://t.co/Xr2fmwotos",
            "conversation_id": "1309014838304268288",
            "edit_history_tweet_ids": [
                "1309014838304268288"
            ],
            "id": "1309014838304268288"
        }
    },
    {
        "data": {
            "text": "3/ In contrast, dict() accepts another dict or an iterable of key/value pairs.\n\n&gt;&gt;&gt; pairs = [('red', 3), ('blue', 2), ('green', 1)]\n&gt;&gt;&gt; dict(pairs)\n{'red': 3, 'blue': 2, 'green': 1}",
            "id": "1307371458696368128",
            "edit_history_tweet_ids": [
                "1307371458696368128"
            ],
            "conversation_id": "1307371456909643776"
        }
    },
    {
        "data": {
            "conversation_id": "1307371456909643776",
            "edit_history_tweet_ids": [
                "1307371457849122817"
            ],
            "id": "1307371457849122817",
            "text": "2/ Counter() accepts a dict or an iterable of elements to be counted.\n\n&gt;&gt;&gt; colors = ['red', 'red', 'blue', 'red', 'green', 'blue']\n&gt;&gt;&gt; Counter(colors)\nCounter({'red': 3, 'blue': 2, 'green': 1})"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1307371456909643776"
            ],
            "id": "1307371456909643776",
            "text": "1/ #Python tip:  To load a Counter when the counts are known in advance, first build a dict:\n\n&gt;&gt;&gt; colors = ['red', 'green', 'blue', 'orange']\n&gt;&gt;&gt; counts = [150, 125, 800, 575]\n&gt;&gt;&gt; Counter(dict(zip(colors, counts)))\nCounter({'blue': 800, 'orange': 575, 'red': 150, 'green': 125})",
            "conversation_id": "1307371456909643776"
        }
    },
    {
        "data": {
            "text": "Me: What is my name?\nSiri: Your name is Laura but I will call you \"sexy\"\nMe: What is my full name?\nSiri: Sorry\nMe: What is my email address?\nSiri: Sorry\nMe: Notify owner their iphone is lost.\nSiri: Sorry\n\nSo, I turned the phone into lost and found.  Hope it finds its way home. \ud83d\ude1f",
            "id": "1307098790009110529",
            "edit_history_tweet_ids": [
                "1307098790009110529"
            ],
            "conversation_id": "1307096871232516096"
        }
    },
    {
        "data": {
            "conversation_id": "1307096871232516096",
            "id": "1307096871232516096",
            "edit_history_tweet_ids": [
                "1307096871232516096"
            ],
            "text": "Locked iphones have an Emergency Call button.  They should also have a Notify Owner That Their Phone is Lost button.  That could send an email via their iTunes account with a message about where to find their phone."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1306387490048098304"
            ],
            "conversation_id": "1306387490048098304",
            "id": "1306387490048098304",
            "text": "#Python typing question:  Is there ever a time when you would need to write \"Union[float, int]\" rather than just \"float\" for a function input?"
        }
    },
    {
        "data": {
            "conversation_id": "1305073120886226944",
            "id": "1305073120886226944",
            "edit_history_tweet_ids": [
                "1305073120886226944"
            ],
            "text": "There are some people who routinely post issues that roughly equate to, \"you built a me car, so I drove it off a cliff and now want to complain about its aerodynamics on the way down\"."
        }
    },
    {
        "data": {
            "id": "1304521506463064066",
            "text": "#Python tip:  Counters can easily be converted to and from regular dictionaries:\n\n&gt;&gt;&gt; c = Counter(a=10, b=5)\n&gt;&gt;&gt; d = dict(c)\n&gt;&gt;&gt; d\n{'a': 10, 'b': 5}\n&gt;&gt;&gt; Counter(d)\nCounter({'a': 10, 'b': 5})\n\nBoth directions use fast C code that copies the hash tables and updates ref counts.",
            "edit_history_tweet_ids": [
                "1304521506463064066"
            ],
            "conversation_id": "1304521506463064066"
        }
    },
    {
        "data": {
            "conversation_id": "1303394312181276673",
            "edit_history_tweet_ids": [
                "1303394314647531520"
            ],
            "id": "1303394314647531520",
            "text": "It was in triplicate because there were binders organized by subject, by title, and by creator.\n\nThanks to carbon paper, the function description forms only had to be typed once.\n\nhttps://t.co/o15YqrMazz"
        }
    },
    {
        "data": {
            "conversation_id": "1303394312181276673",
            "edit_history_tweet_ids": [
                "1303394313812860928"
            ],
            "text": "I'm old enough to remember long desks covered with updatable binder books having one page per function for thousands of functions.\n\nEvery time a function was updated, its documentation was typed in triplicate and the old pages in each book were replaced.\n\nhttps://t.co/nFQ9Xjb2gN",
            "id": "1303394313812860928"
        }
    },
    {
        "data": {
            "conversation_id": "1303394312181276673",
            "id": "1303394313104097280",
            "text": "Incorrect answer:  Single large namespace with lots of similarly named functions:  printf, wprintf, sprintf, fprintf, atoi, atol, atof, matinv, matinv_hessian, matinv_pos_def, matinv_pos_semi_def, matinv_upper_tri, matinv_lower_tri, ...",
            "edit_history_tweet_ids": [
                "1303394313104097280"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1303394312181276673",
            "edit_history_tweet_ids": [
                "1303394312181276673"
            ],
            "id": "1303394312181276673",
            "text": "#Python Programming in the large is mostly about management of complexity.   Object oriented programming and functional programming can be viewed as organizing principles for managing complexity.\n\nIt's okay to not do OOP or FP, but do you have an alternative natural organization?"
        }
    },
    {
        "data": {
            "conversation_id": "1302741585730310144",
            "id": "1302773943154012165",
            "text": "5/ \"In practical terms, if the combined error is in fact of interest, then a combined estimator should be used, even if the underlying parameters are independent.\" -- Wikipedia article.\n\nhttps://t.co/h1YlGviw2e",
            "edit_history_tweet_ids": [
                "1302773943154012165"
            ]
        }
    },
    {
        "data": {
            "id": "1302741588074881025",
            "edit_history_tweet_ids": [
                "1302741588074881025"
            ],
            "conversation_id": "1302741585730310144",
            "text": "4/ The previously linked article is an easy read and explains the phenomenon in plain English and with understandable examples.\n\nFor a more terse and mathy explanation, see\n\nhttps://t.co/4RBYNR7Wbp"
        }
    },
    {
        "data": {
            "conversation_id": "1302741585730310144",
            "id": "1302741587206651904",
            "edit_history_tweet_ids": [
                "1302741587206651904"
            ],
            "text": "3/ If this seems unintuitive, then you're not alone.  That is why it is called Stein's paradox \ud83d\ude09\n\nThe reason it works is that errors in one estimate tend to cancel the errors in the other estimates.\n\nhttps://t.co/Vz5novkOQk"
        }
    },
    {
        "data": {
            "id": "1302741586510397440",
            "edit_history_tweet_ids": [
                "1302741586510397440"
            ],
            "text": "2/ One example comes from baseball.\n\nIndividual batting averages near the beginning of the season aren't as good of a performance predictor as individual batting averages that have been \u201cshrunk\u201d toward the collective mean.\n\nShockingly, this also works for unrelated variables.",
            "conversation_id": "1302741585730310144"
        }
    },
    {
        "data": {
            "conversation_id": "1302741585730310144",
            "id": "1302741585730310144",
            "edit_history_tweet_ids": [
                "1302741585730310144"
            ],
            "text": "1/ #Python data science tip: To obtain a better estimate (on average) for a vector of multiple parameters, it is better to analyze sample vectors in aggregate than to use the mean of each component.\n\nSurprisingly, this works even if the components are unrelated to one another."
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1302414573094330369"
            ],
            "text": "I've always been mildly amused by the name of the assertLessEqual() method #python's unittest module.\n\nIt strikes as, \"we're all equal here; it's just that some of you are less equal than others\" \ud83d\ude09\n\nPython's version of \"four legs good, two legs better.\"",
            "id": "1302414573094330369",
            "conversation_id": "1302414573094330369"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1302314110172803077"
            ],
            "text": "Why it works:\n\n* At each step, the intermediate result gets rounded.\n\n* When two addends are of similar magnitude, less information gets lost to the rounding.\n\n* The more information that survives between steps, the more that information is able to influence the final sum.",
            "id": "1302314110172803077",
            "conversation_id": "1302301255700627456"
        }
    },
    {
        "data": {
            "text": "Example:\n\n&gt;&gt;&gt; getcontext().prec = 6\n&gt;&gt;&gt; a = Decimal( '3.00004')\n&gt;&gt;&gt; b = Decimal('24.6813')\n&gt;&gt;&gt; a + a + a + b\nDecimal('33.6814')\n&gt;&gt;&gt; b + a + a + a\nDecimal('33.6813')\n\n# Build-up small values\n&gt;&gt;&gt; a + a + a\nDecimal('9.00012')\n\n# Or immediately lose the 4\n&gt;&gt;&gt; b + a\nDecimal('27.6813')",
            "conversation_id": "1302301255700627456",
            "edit_history_tweet_ids": [
                "1302312560880803846"
            ],
            "id": "1302312560880803846"
        }
    },
    {
        "data": {
            "conversation_id": "1302301255700627456",
            "edit_history_tweet_ids": [
                "1302301255700627456"
            ],
            "id": "1302301255700627456",
            "text": "#Python floating point ninja tip:  Summation accuracy is improved when terms are arranged in order of increasing magnitude.\n\nInstead of:\n   giant + large + medium + small + tiny\n\nWrite:\n   tiny + small + medium + large + giant"
        }
    },
    {
        "data": {
            "conversation_id": "1301800636866940928",
            "edit_history_tweet_ids": [
                "1301800637911322626"
            ],
            "text": "#numpy uses pairwise summation in numpy.sum() when no axis is given.\n\nhttps://t.co/VzPEIvFicX",
            "id": "1301800637911322626"
        }
    },
    {
        "data": {
            "id": "1301800636866940928",
            "edit_history_tweet_ids": [
                "1301800636866940928"
            ],
            "conversation_id": "1301800636866940928",
            "text": "#Python floating point ninja tip:  Use parentheses to regroup sums to minimize accumulated round-off error.\n\nInstead of:\n    a + b + c + d + e + f + g + h\n\nWrite:\n    ((a + b) + (c + d)) + ((e + f) + (g + h))\n\nNote, the total work is unchanged.\n\nhttps://t.co/jnJuYzay7j"
        }
    },
    {
        "data": {
            "conversation_id": "1300470272470908935",
            "id": "1300470276354760704",
            "edit_history_tweet_ids": [
                "1300470276354760704"
            ],
            "text": "The part that is pure magic:  How do you split a 53 bit number into two 26 bit numbers?  Where did the extra bit go?\n\nAnswer: The extra bit is stored in the sign bit of the \"lo\" component.\n\n53 bits + 1 sign = 26 bits + 1 sign + 26 bits + 1 sign\n\nAll bits accounted for.\ud83e\uddd0\n\nCool!\ud83d\ude0f"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1300470275604054016"
            ],
            "text": "The payoff for Veltkamp-Dekker splitting and piecewise multiplication is that you can build quad precision arithmetic out of everyday double precision arithmetic.",
            "id": "1300470275604054016",
            "conversation_id": "1300470272470908935"
        }
    },
    {
        "data": {
            "text": "Use case:  The 26-bit precision components can be multiplied losslessly (without rounding):\n\n# Four exact components of e * pi:\n&gt;&gt;&gt; pi_hi*e_hi\n8.539734226211163\n&gt;&gt;&gt; pi_hi*e_lo\n7.207993525551209e-08\n&gt;&gt;&gt; pi_lo*e_hi\n-7.561753118743836e-08\n&gt;&gt;&gt; pi_lo*e_lo\n-6.382525038592985e-16",
            "conversation_id": "1300470272470908935",
            "edit_history_tweet_ids": [
                "1300470274823913473"
            ],
            "id": "1300470274823913473"
        }
    },
    {
        "data": {
            "id": "1300470274039582720",
            "edit_history_tweet_ids": [
                "1300470274039582720"
            ],
            "text": "Example:\n\n&gt;&gt;&gt; hi, lo = veltkamp_split(pi)\n&gt;&gt;&gt; hi + lo == pi\nTrue\n&gt;&gt;&gt; hi.hex()\n'0x1.921fb58000000p+1'\n&gt;&gt;&gt; lo.hex()\n'-0x1.dde9740000000p-26'\n\nNote all the trailing zeros and the difference between the two exponents. Also both the lo and hi values are signed.",
            "conversation_id": "1300470272470908935"
        }
    },
    {
        "data": {
            "id": "1300470273326546948",
            "edit_history_tweet_ids": [
                "1300470273326546948"
            ],
            "text": "Input:  one signed 53-bit precision float\n\nOutput:  two signed 26-bit precision floats\n\nInvariant:  x == hi + lo\n\nConstant:  134217729.0 == 2.0 ** 27 + 1.0",
            "conversation_id": "1300470272470908935"
        }
    },
    {
        "data": {
            "conversation_id": "1300470272470908935",
            "edit_history_tweet_ids": [
                "1300470272470908935"
            ],
            "id": "1300470272470908935",
            "text": "Another building block for a #Python floating point ninja toolset: \n\ndef veltkamp_split(x):\n    'Exact split into two 26-bit precision components'\n    t = x * 134217729.0\n    hi = t - (t - x)\n    lo = x - hi\n    return hi, lo\n\nhttps://t.co/KIkfGUvugW"
        }
    },
    {
        "data": {
            "conversation_id": "1299396820154474498",
            "text": "Example:\n\n&gt;&gt;&gt; total, fraction = lossless_add(pi, e)\n&gt;&gt;&gt; total\n5.859874482048838\n&gt;&gt;&gt; fraction\n4.440892098500626e-16\n\n&gt;&gt;&gt; total.hex()\n'0x1.77082efac4240p+2'\n&gt;&gt;&gt; fraction.hex()\n'0x1.0000000000000p-51'\n\n&gt;&gt;&gt; total + fraction == pi + e\nTrue\n&gt;&gt;&gt; fabs(fraction) &lt; ulp(total)\nTrue",
            "edit_history_tweet_ids": [
                "1299396821698056192"
            ],
            "id": "1299396821698056192"
        }
    },
    {
        "data": {
            "conversation_id": "1299396820154474498",
            "id": "1299396820922056705",
            "edit_history_tweet_ids": [
                "1299396820922056705"
            ],
            "text": "Precondition:\n     fabs(a) &gt;= fabs(b)\n\nPostconditions:\n    y - b + x == a   # lossless recovery of addend \"a\"\n    x - a + y == b   # lossless recovery of addend \"b\"\n    x + y == a + b   # sum preserving\n    fabs(y) &lt; ulp(x) # |y| smaller than all bits of x"
        }
    },
    {
        "data": {
            "conversation_id": "1299396820154474498",
            "edit_history_tweet_ids": [
                "1299396820154474498"
            ],
            "id": "1299396820154474498",
            "text": "Building block for a #Python floating point ninja toolset:  \n\ndef lossless_add(a, b):\n    x = a + b\n    y = (a - x) + b\n    return x, y\n\nhttps://t.co/ZlQrVAeG8T"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1298832283130933248"
            ],
            "text": "True words! https://t.co/JsVA9qBG4N",
            "id": "1298832283130933248",
            "conversation_id": "1298832283130933248"
        }
    },
    {
        "data": {
            "conversation_id": "1298399733719785472",
            "edit_history_tweet_ids": [
                "1298411674957799424"
            ],
            "text": "\\neq or \\ne  LaTeX\nDoublePlusUnequal   Newspeak",
            "id": "1298411674957799424"
        }
    },
    {
        "data": {
            "id": "1298399733719785472",
            "edit_history_tweet_ids": [
                "1298399733719785472"
            ],
            "conversation_id": "1298399733719785472",
            "text": "#Python people, which inequality do you like best?\n\n\u2260        Regular math\n.NE.     Fortran\n&lt;&gt;       Python 2\n!=       Python 3\n#        TLA\u207a\n= INVERT Forth\nNE or #  COBOL\n&gt;&lt; or &lt;&gt; COBOL\nCMP JNE  Assembly\nassertNotEqual Unittest\nabs(x - y) &lt; 0.0001 Floating point ;-)"
        }
    },
    {
        "data": {
            "id": "1298108213305290752",
            "text": "The lowest I've found so far is:\n\n&gt;&gt;&gt; s = 4503599761588224\n&gt;&gt;&gt; floor(sqrt(s))\n67108865\n&gt;&gt;&gt; isqrt(s)\n67108864\n\n&gt;&gt;&gt; s.bit_length()\n53\n&gt;&gt;&gt; bin(s)\n'0b10000000000000000000000001000000000000000000000000000'",
            "edit_history_tweet_ids": [
                "1298108213305290752"
            ],
            "conversation_id": "1297998442594091008"
        }
    },
    {
        "data": {
            "conversation_id": "1298106417065287682",
            "edit_history_tweet_ids": [
                "1298106417065287682"
            ],
            "id": "1298106417065287682",
            "text": "A nice compliment on #StackOverflow goes a long way towards rewarding a contributor.\n\n\u201cRachel to the Rescue\u201d has a nice ring to it, doesn't it?\n\nhttps://t.co/UISbesGVIH"
        }
    },
    {
        "data": {
            "id": "1297998442594091008",
            "text": "#Python math module challenge:  What is the smallest positive integer where isqrt(x) \u2260 floor(sqrt(x)) ?",
            "edit_history_tweet_ids": [
                "1297998442594091008"
            ],
            "conversation_id": "1297998442594091008"
        }
    },
    {
        "data": {
            "text": "#python tip:  Here are several ways to interactively display intermediate results during a calculation.\n\n# Two liner\n&gt;&gt;&gt; q = 3.5 * 1.5\n&gt;&gt;&gt; q\n5.25\n\n# Second expression\n&gt;&gt;&gt; q = 3.5 * 1.5; q\n5.25\n\n# Walrus\n&gt;&gt;&gt; (q := 3.5 * 1.5)\n5.25\n\n# Invisible\n&gt;&gt;&gt; q = 3.5 * 1.5",
            "id": "1297586506626785280",
            "edit_history_tweet_ids": [
                "1297586506626785280"
            ],
            "conversation_id": "1297586506626785280"
        }
    },
    {
        "data": {
            "conversation_id": "1297244672759230464",
            "id": "1297244673958789122",
            "text": "\"pep_boys\" and \"names\" are two references to the same list object (not unlike having two connections to one database).\n\n\"names[:]\" updates the list in-place\n\n\"pep_boys\" refers to the now updated list.",
            "edit_history_tweet_ids": [
                "1297244673958789122"
            ]
        }
    },
    {
        "data": {
            "conversation_id": "1297244672759230464",
            "edit_history_tweet_ids": [
                "1297244673346375681"
            ],
            "id": "1297244673346375681",
            "text": "&gt;&gt;&gt; pep_boys = ['manny', 'mo', 'jack']\n&gt;&gt;&gt; names = pep_boys\n&gt;&gt;&gt; names[:] = [name.title() for name in names if name.startswith('m')]\n&gt;&gt;&gt; pep_boys\n['Manny', 'Mo']"
        }
    },
    {
        "data": {
            "id": "1297244672759230464",
            "edit_history_tweet_ids": [
                "1297244672759230464"
            ],
            "conversation_id": "1297244672759230464",
            "text": "#python tip:  To update a list in-place, use a slice-assignment\n\nt = s\n...\ns[:] = [f(x) for x in s if c(x)]\n\nNow, both \"s\" and \"t\" reflect the new data."
        }
    },
    {
        "data": {
            "conversation_id": "1296865073747513344",
            "edit_history_tweet_ids": [
                "1296908553307877376"
            ],
            "text": "Anecdote:  I once lost two days of development time due to a persistent and fatal OutOfMemory error reported by DBase IV.\n\nThe actual underlying cause was the DBaseIV runtime erroneously reporting a printer-out-of-paper signal as an out-of-memory error. \ud83d\ude1e",
            "id": "1296908553307877376"
        }
    },
    {
        "data": {
            "edit_history_tweet_ids": [
                "1296865073747513344"
            ],
            "text": "#Python wish: With effort, we could make error reporting much smarter and more helpful.\n\n&gt;&gt;&gt; predict(unknown_flower, iris_measurements. iris_labels)\nAttributeError: 'list' object has no attribute 'iris_labels'\nHint: A period followed by a space is unusual, did you intend a comma?",
            "id": "1296865073747513344",
            "conversation_id": "1296865073747513344"
        }
    }
]